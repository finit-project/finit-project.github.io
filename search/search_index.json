{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Reverse engineered from the EeePC fastinit \"gaps filled with frog DNA \u2026\" \u2014 Claudio Matsuoka</p> <p>Finit is a process starter and supervisor designed to run as PID 1 on Linux systems.  It consists of a set of plugins and can be set up using configuration files.  Plugins start at hook points and can run various set up tasks and/or install event handlers that later provide runtime services, e.g., PID file monitoring, or conditions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Runlevels, defined per service</li> <li>One-shot tasks, services (daemons), or SysV init start/stop scripts</li> <li>Runparts and <code>/etc/rc.local</code> support</li> <li>Process supervision similar to systemd</li> <li>Sourcing environment files</li> <li>Conditions for network/process/custom dependencies</li> <li>Readiness notification; PID files (native) for synchronizing system     startup, support for systemd sd_notify(), or s6 style too</li> <li>Limited support for tmpfiles.d(5) (no aging, attributes, or subvolumes)</li> <li>Pre/Post script actions</li> <li>Rudimentary templating support</li> <li>Tooling to enable/disable services</li> <li>Built-in getty</li> <li>Built-in watchdog, with support for hand-over to watchdogd</li> <li>Built-in support for Debian/BusyBox <code>/etc/network/interfaces</code></li> <li>Cgroups v2, both configuration and monitoring in <code>initctl top</code></li> <li>Plugin support for customization</li> <li>Proper rescue mode with bundled <code>sulogin</code> for protected maintenance shell</li> <li>Integration with watchdogd for full system supervision</li> <li>Logging to kernel ring buffer before <code>syslogd</code> has started, see the     recommended sysklogd project for complete logging integration     and how to log to the kernel ring buffer from scripts using <code>logger</code></li> </ul> <p>For a more thorough overview, see the Features section.</p> <p>Tip</p> <p>See SysV Init Compatibility for help to quickly get going with an existing SysV or BusyBox init setup.</p>"},{"location":"#origin","title":"Origin","text":"<p>This project is based on the original finit by Claudio Matsuoka which was reverse engineered from syscalls of the EeePC fastinit.</p> <p>Finit is developed and maintained by Joachim Wiberg at GitHub. Please file bug reports, clone it, or send pull requests for bug fixes and proposed extensions.</p>"},{"location":"ChangeLog/","title":"Change Log","text":"<p>All relevant changes are documented in this file.</p>"},{"location":"ChangeLog/#415","title":"4.15","text":""},{"location":"ChangeLog/#changes","title":"Changes","text":"<ul> <li>Change default reboot to SOC reset from WDT reset, issue #460</li> <li>Bump required versions of libite (v2.6.2) and libuev (v2.4.1)</li> <li>Allow longer service identifiers (<code>:id</code>), up to 64 characters</li> <li>Allow skipping bootstrap wait (180 sec) with Ctrl-C</li> <li>Unlock <code>initctl</code> commands start/stop/restart/reload service during bootstrap,   shutdown, and reboot.  Also, allow <code>initctl reload</code> in bootstrap. This makes   it possible to start manual:yes type services at botostrap, for example, which   has been a common feature request</li> <li>Add support for <code>clone3()</code> syscall with atomic cgroup assignment, from Linux   kernel 5.3+.  Eliminates race conditions where forked processes (e.g., logger   processes) ended up in wrong cgroups. Falls back to <code>fork()</code> on older kernels</li> <li>Add support for cgroup delegation, useful for, e.g., container runtimes   creating sub-groups for the container instance's processes</li> <li>Add cgroup leaf name override: <code>cgroup.system,name:udevd</code> allows using   descriptive names like <code>/system/udevd/</code> instead of filename derived names   like <code>/system/10-hotplug/</code>.  Syntax supports combining with other options:   <code>cgroup.system,name:foo,delegate,cpu.max:10000</code></li> </ul>"},{"location":"ChangeLog/#fixes","title":"Fixes","text":"<ul> <li>Fix #453: RTC plugin fixes by Ming Liu, Atlas Copco</li> <li>Fix #455: ANSI escape sequences logged by tools using glib logging,   caused by use of PTY instead of pipe for stdout/stderr redirection</li> <li>getty: fix terminal scrollback issues after login on console TTY.  Mouse   scroll wheel and Shift+PgUp/PgDn sometimes would not work properly</li> <li>Fix flickering and artifacts in <code>initctl top</code></li> <li>Fix file descriptor leak in <code>initctl top</code></li> <li>Fix incorrect \"max\" limit reporting in <code>initctl [top|cgroup|--json]</code> output   for child cgroups.  Resolves effective limits by walking the cgroup hierarchy</li> <li>Ensure mount/unmount skips <code>noauto</code> entries</li> </ul>"},{"location":"ChangeLog/#414-2025-08-29","title":"4.14 - 2025-08-29","text":"<p>Minor bug fix release.</p>"},{"location":"ChangeLog/#changes_1","title":"Changes","text":"<ul> <li>Add exit status/signal info when a process dies, by Mattias Berthel</li> <li>Extend <code>service kill:SEC</code> to support up to 300 sec.</li> <li>Extend <code>norespawn</code> debug to cover <code>service_retry()</code></li> <li>Build without libsystemd replacement by default</li> </ul>"},{"location":"ChangeLog/#fixes_1","title":"Fixes","text":"<ul> <li>Fix #449: ALSA plugin fail-to-build-from-source</li> <li>Fix <code>sysv</code> stop command process environment, should be same as start</li> <li>Fix state machine ordering issue: enter new config generation after    services disabled in previous generation have been stopped</li> </ul>"},{"location":"ChangeLog/#413-2025-07-10","title":"4.13 - 2025-07-10","text":"<p>Note</p> <p>This release introduce a bare bones <code>libsystemd</code> replacement with an <code>&lt;systemd/sd-daemon&gt;.h</code> include file.  Other systemd features are the <code>reload:script</code> and <code>stop:script</code>, mimicking ExecReload and ExecStop.</p>"},{"location":"ChangeLog/#changes_2","title":"Changes","text":"<ul> <li><code>initctl signal</code> command has been renamed to <code>initctl kill</code></li> <li>Drop xz tarballs from distribution, gzip is good enough</li> <li>New <code>tmpfiles</code> stand-alone program, refactored from the existing    tmpfiles.d support in Finit, by Aaron Andersen, PR #439<ul> <li><code>--remove</code> command runs only the <code>r</code> and <code>R</code> rules</li> <li><code>--create</code> is used for all other cases (bootstrap)</li> </ul> </li> <li>All <code>notify:systemd</code> services now log with <code>logit</code> by default.  This    because it supports systemd style log severity, leading <code>\"&lt;NUM&gt;\"</code></li> <li>Support for quoted arguments to run/task/service options, issue #441</li> <li>Clear command line arguments after bootstrap, issue #442</li> <li>Support for <code>stop:'script [args]'</code> to stop a sysv/service instead of    the common <code>foo-stop-start.sh stop</code>, or <code>SIGTERM</code>, issue #412</li> <li>Support for <code>reload:'script [args]'</code> to trigger a configuration    reload in a service, issue #446</li> </ul>"},{"location":"ChangeLog/#fixes_2","title":"Fixes","text":"<ul> <li>Fix #437: buffer overflow in <code>initctl status</code></li> <li>Fix #438: support very long command lines in <code>initctl ps/top</code></li> <li>Fix #440: broken systemd and s6 readiness notification</li> <li>Fix #443: build warnings, by Ming Liu, Atlas Copco</li> <li>Fix #444: handle loooooong arguments, by Aaron Andersen</li> <li>Fix service's redirected stdout/stderr log priority in fallback mode,    when neither <code>logger</code> or <code>logit</code> is available.  This fix also checks    for systemd style log severity, leading <code>\"&lt;NUM&gt;\"</code> in log messages</li> <li>Ensure API socket used by <code>initctl</code> is non-blocking (event loop)</li> </ul>"},{"location":"ChangeLog/#412-2025-04-28","title":"4.12 - 2025-04-28","text":""},{"location":"ChangeLog/#changes_3","title":"Changes","text":"<ul> <li>Improve notify:s6 readiness compatibility, by Aaron Andersen</li> <li>Update <code>runparts</code> usage text</li> </ul>"},{"location":"ChangeLog/#fixes_3","title":"Fixes","text":"<ul> <li>Fix variable overloading in urandom plugin</li> <li>Fix buffer overwrite in urandom plugin, reported by Aaron Andersen</li> </ul>"},{"location":"ChangeLog/#411-2025-03-27","title":"4.11 - 2025-03-27","text":""},{"location":"ChangeLog/#changes_4","title":"Changes","text":"<ul> <li>Update documentation regarding transition from runlevel S to 2, how    run/tasks must \"complete\" before Finit can move to the next runlevel</li> <li>Improve argument handling in bundled getty when launching login</li> </ul>"},{"location":"ChangeLog/#fixes_4","title":"Fixes","text":"<ul> <li>Fix #432: allow services in <code>setup</code> state to be stopped.  This fixes    a serious blocker introduced in 4.10 that prevented systems from    being rebooted when any service was in this state</li> <li>Fix fallback <code>SIGKILL</code> when stopping a service with <code>SIGTERM</code> does    not work.  This fixes a serious issue with services not responding to    the default <code>SIGTERM</code></li> <li>Fix pre/post/ready/cleanup script execution if service has an    optional <code>env:file</code> (leading <code>-</code>)</li> <li>Fix blocked signals for pre/post/ready/cleanup scripts preventing    normal shutdown when a service/sysv is stopped in its setup state</li> <li>Fix issue where a pre:script creates a PID file in <code>/run</code> cause the    service to move from setup state to running.  Any <code>svc_t</code> in setup,    teardown, or cleanup state should be ignored in the pidfile plugin</li> </ul>"},{"location":"ChangeLog/#410-2025-03-03","title":"4.10 - 2025-03-03","text":""},{"location":"ChangeLog/#changes_5","title":"Changes","text":"<ul> <li>Add support for <code>cleanup:[0-3600,]script</code>, runs before service is    removed, unlike <code>post:script</code> that runs when service is stopped</li> <li>Improved entropy gathering in tertiary fallback of urandom plugin</li> <li>Reclassify <code>sysv</code> from run/task class to <code>service</code></li> </ul>"},{"location":"ChangeLog/#fixes_5","title":"Fixes","text":"<ul> <li>Fix #427: using an external getty with custom login program cause    Finit to use login program as the getty command</li> <li>Fix #428: allow <code>sysctl</code> path to be set at build time</li> <li>Fix #429: regression in v4.9 causing Finit to segfault at shutdown</li> <li>Fix possible memory leak when sourcing a service <code>env:file</code></li> <li>Finit now waits until all <code>post:scripts</code> have run before returning    OK to <code>initctl &lt;reload|runlevel&gt;</code>.  This also applies to the new    <code>cleanup:scripts</code> introduced in this release</li> <li>RFC3154 conformance formatting fix for <code>/dev/kmsg</code> fallback logging</li> </ul>"},{"location":"ChangeLog/#49-2025-02-15","title":"4.9 - 2025-02-15","text":"<p>Caution</p> <p>This release changes how Finit reacts to the exit status of <code>pre:</code> scripts.  Finit will now no longer start the main process if its <code>pre:</code> script fails for any reason.  So, if you have pre scripts that, e.g., create directories, make sure they are idempotent.</p>"},{"location":"ChangeLog/#changes_6","title":"Changes","text":"<ul> <li>Add individual timeout (optional) support for pre/post/ready scripts</li> <li>Add support for systems with broken RTC, i.e., those that at power-on    may reset the RTC to a random date instead of zero, issue #418</li> <li>Add support for detecting \"in-container\" when in <code>systemd-nspawn</code></li> <li>Check exit status of <code>pre:</code> scripts, on failure drive service/sysv to    <code>crashed</code> state.  (The exit code of <code>post:</code> scripts remain ignored)</li> <li>All pre/post/ready scripts are now also searched for in <code>$PATH</code></li> <li>Reset color attributes and clear screen when starting up.  This is    for boot loaders like GRUB, which leave background color artifacts</li> </ul>"},{"location":"ChangeLog/#fixes_6","title":"Fixes","text":"<ul> <li>Fix #415: only mark reverse-dependencies \"dirty\" if the main service    does not support SIGHUP.  This helps avoid unnecessary restarts of    services that depend on a service that supports SIGHUP</li> <li>Fix #417: leaking inotify watchers in the cgroup subsystem</li> <li>Fix #421: add support for <code>nofail</code> mount option in <code>/etc/fstab</code></li> <li>Fix #425: ordering bug in detecting .conf file changes to services    and <code>initctl reload</code>, or runlevel changes</li> <li>Fix <code>initctl touch</code> of template services, previously marking a    service created from a template as \"dirty\" did not take</li> <li>Fix unintended restart of template \"siblings\".  I.e., <code>initctl touch</code>    of instantiated template service A affected B from same template</li> <li>Fix buggy <code>--with-rtc-date=DATE</code> configure option</li> <li>Fix kill on timeout of pre/post/ready scripts</li> </ul>"},{"location":"ChangeLog/#48-2024-10-13","title":"4.8 - 2024-10-13","text":""},{"location":"ChangeLog/#changes_7","title":"Changes","text":"<ul> <li>Avoid remounting already mounted <code>/run</code> and <code>/tmp</code> directories.  This    extends the existing support for detecting mounted directories to    include complex mount hierarchies are in use, overlayfs and tmpfs    mounts.  Feature by Mathias Thore, Atlas Copco</li> <li>getty: trigger /etc/issue compat mode for Alpine Linux</li> <li>tmpfiles.d: skip <code>x11.conf</code> unless X11 common plugin is enabled</li> <li>tmpfiles.d: ignore x/X command, nos support for cleanup at runtime</li> <li>Drop debug mode <code>-D</code> from <code>udevd</code> in <code>hotplug.conf.in</code>, allow the    user to set this in <code>/etc/default/udevd</code> instead</li> <li>Certain initctl APIs at bootstrap are not supported, update warning    log to include command (number) for troubleshooting, issue #398</li> <li>Add support for hwrng to urandom plugin and check for empty seed</li> <li>Add <code>runparts -b</code> (batch mode) support, disables escape sequences</li> <li>New configure <code>--without-rc-local</code>, disables <code>/etc/rc.local</code> support</li> <li>New configure <code>--disable-cgroup</code> option, disables cgroup v2 detection</li> <li><code>initctl show template@foo.conf</code> now shows how an enabled template    service has been evaluated by Finit, issue #411</li> <li>Extend <code>initctl</code> timeout connecting and waiting for Finit reply.  The    previous 2 + 2 second poll timeout has proved to be too short on more    complex systems.  Now a 15 + 15 second timeout is applied which should    be more resistant to temporary overload scenarios, issue #407</li> </ul>"},{"location":"ChangeLog/#fixes_7","title":"Fixes","text":"<ul> <li>Fix #397: system shutdown/reboot can block on console input if action    is started remotely (ssh).  Caused by legacy TTY screen size probing,    removed from both bootstrap and shutdown/reboot</li> <li>Fix #400: both <code>HOOK_MOUNT_ERROR</code> and <code>sulogin()</code> fail to trigger on    either mount or <code>fsck</code> errors.  Problem caused by unresolved status    from pipe, calling <code>pclose()</code> without extracting exit status</li> <li>Fix #402: <code>initctl touch</code> does not respect <code>-n</code> (no error) flag</li> <li>Fix #403: <code>initctl touch</code> does not support template services</li> <li>Fix #404: possible undefined behavior when <code>--with-fstab=no</code> is set</li> <li>Fix #405: <code>@console</code> getty does not work with <code>tty0 ttyS0</code></li> <li>Fix #409: prevent tmpfiles from following symlinks for <code>L+</code> and <code>R</code>,    otherwise symlink targets would also be removed.  Found and fixed by    Mathias Thore and Ming Liu, Atlas Copco</li> <li>Fix #414: Frr Zebra immediately restarts on <code>initctl stop zebra</code>.    The fix likely works for all Frr/Quagga services due to the way they    create and delete their pid file</li> <li>Cosmetic issue with <code>[ OK ]</code> messages being printed out of order at    shutdown/reboot.  Caused by nested calls to <code>service_stop()</code></li> <li>Cosmetic issue with duplicate \"Restoring RTC\" message at bootstrap</li> </ul>"},{"location":"ChangeLog/#47-2024-01-07","title":"4.7 - 2024-01-07","text":""},{"location":"ChangeLog/#changes_8","title":"Changes","text":"<ul> <li>Silence \"not available\" messages for run/task/service with <code>nowarn</code></li> <li>Update docs, <code>cgroup.root</code> workaround for <code>SCHED_RR</code> tasks</li> <li>Drop runlevels 0 and 6 from <code>keventd</code>, not needed at reboot/poweroff</li> <li>Mount <code>/dev/shm</code> with mode 1777 (sticky bit)</li> <li>Mount <code>/dev/mqueue</code> if available, inspiration from Alpine Linux</li> <li>Update Alpine Linux installer and configuration files, tested on   Alpine v3.19, some assembly still required</li> </ul>"},{"location":"ChangeLog/#fixes_8","title":"Fixes","text":"<ul> <li>Fix confusing warning message when tmpfiles.d fails to install symlink</li> <li>Fix tmpfiles.d legacy <code>/run/lock/subsys</code>, ordering</li> <li>Add missing <code>/var/tmp</code> and <code>/var/lock -&gt; /run/lock</code> (tmpfiles.d)</li> <li>Fix #388: log redirection broken unless Finit runs in debug mode.   Found and fixed by Ryan Rorison</li> <li>Fix #389: must libc requires <code>libgen.h</code> for <code>basename()</code> function.   Reported and worked around with new <code>basenm()</code> function by Stargirl</li> <li>Fix #392: <code>service/foo/ready</code> condition reasserted on pidfile removal</li> </ul>"},{"location":"ChangeLog/#46-2023-11-13","title":"4.6 - 2023-11-13","text":""},{"location":"ChangeLog/#changes_9","title":"Changes","text":"<ul> <li>Add support for service <code>notify:pid</code> and <code>readiness none</code> global   option to change how Finit expects readiness notification, issue #386</li> </ul>"},{"location":"ChangeLog/#fixes_9","title":"Fixes","text":"<ul> <li>Fix #383: dbus and runparts regression in Finit v4.5.  The configure   script must expand <code>FINIT_RUNPATH_</code> before defining it in <code>config.h</code></li> <li>Fix #384: service environment variables drop everything but the first   argument, e.g., <code>VAR=\"foo bar qux\"</code> drops everything but <code>foo</code></li> <li>Fix #385: internal conditions, e.g., <code>&lt;int/bootstrap&gt;</code> turn into flux   when leaving bootstrap, causing depending services to stop</li> <li>Fix #387: global environment variables declared with <code>set VAR=NAME</code> do   not drop leading <code>set</code>, causing <code>'set VAR'='NAME'</code> in env.</li> <li>Sanity check environment variables, for services and globally.  Ensure   the variable name (key) does not contain spaces, or a leading <code>set</code></li> </ul>"},{"location":"ChangeLog/#45-2023-10-30","title":"4.5 - 2023-10-30","text":""},{"location":"ChangeLog/#changes_10","title":"Changes","text":"<ul> <li>Refactor <code>runparts</code> and <code>/etc/rc.local</code> to no longer block the main   loop, allowing <code>initctl</code> calls to interact with Finit.  Issue #356</li> <li>Refactor the <code>run</code> stanza to no longer block the main loop, issue #362</li> <li>Allow <code>sulogin</code> with a user different from <code>root</code>, issue #357</li> <li>Allow disabling invocation of rescue mode from kernel command line</li> <li>Add <code>initctl -f</code> to force-skip asking Finit for existing services   when creating new services during bootstrap, e.g. <code>/etc/rc.local</code></li> <li><code>initctl runlevel</code> now returns <code>N S</code> instead of <code>N 10</code> in bootstrap</li> <li><code>initctl runlevel N</code> during bootstrap is now allowed.  It changes   the next runlevel to go to when bootstrap has completed.  Effectively   overriding the <code>runlevel N</code> statement in <code>/etc/finit.conf</code></li> <li>Improved logging on failure to <code>execvp()</code> a run/task/service, now   with <code>errno</code>, e.g., \"No such file or directory\" when the command   is missing from <code>$PATH</code></li> <li>Add Bash completion support for <code>initctl</code>, configurable, issue #360</li> <li>Handle absolute path to <code>initctl [enable|disable]</code>, not supported</li> <li>Update <code>finit.conf(5)</code> man page with the recommended directory   hierarchy in <code>/etc/finit.d/</code></li> <li>The <code>runparts</code> code has been split into <code>/libexec/finit/runparts</code></li> <li>The <code>runparts</code> command now takes two options: <code>sysv</code> and <code>progress</code>.   The former ensures only <code>SNNfoo</code> and <code>KNNfoo</code> scripts are run.</li> <li>Add SysV Init Compatibility section to documentation</li> <li>Increased MAX path for commands, and arguments: 64 -&gt; 256</li> <li>The bundled watchdog daemon no longer tries to log at startup, because   syslog is not available yet, any startup message leak to console</li> <li>Extend <code>if:</code> option with runtime evaluation of conditions.  E.g., start   a task only <code>if:&lt;run/foo/failure&gt;</code> (here the run task 'foo' failed)</li> <li>Document new <code>if:</code>, <code>conflict:</code>, <code>nowarn</code> options for run/task/service   first introduced in v4.4</li> <li>Failure to open fstab should log to console, not just log to <code>/dev/kmsg</code></li> <li>Rename <code>/lib/finit/system/*.conf</code>, added numbered prefix to ensure   proper execution order, e.g., <code>udevd</code> should always run first</li> <li>Plugins and bundled services: dbus, keventd, watchdogd, and runparts,   are now loaded after all services in <code>/lib/finit/system/</code>.  A new   runtime-only path (for inspection) in <code>/run/finit/system/</code> is used</li> <li>Redirect <code>log*</code> output to console when <code>finit.debug</code> is enabled</li> <li>Assert <code>&lt;int/container&gt;</code> condition if we detect running in container</li> <li>Add support for mdev's netlink daemon mode, issue #367</li> <li>Add support for mdevd in <code>10-hotplug.conf</code>, preferred over plain mdev</li> <li>Disable modprobe plugin by default, udevd and mdev/mdevd loads modules</li> <li>Update documentation for run/task shell limitations, issue #376</li> <li>Update documentation regarding automount of <code>/run</code> and <code>/tmp</code></li> <li>Update plugin documentation, add section about limited tmpfiles.d(5) support</li> <li>Skip registering service when <code>if:!name</code> matches a known service.   This allows conditional loading of alternative services, e.g. if udevd   is already loaded we do not need mdevd</li> <li>Drop <code>doc/bootstrap.md</code>, inaccurate and confusing to users</li> </ul>"},{"location":"ChangeLog/#fixes_10","title":"Fixes","text":"<ul> <li>Fix #227: believed to have been fixed in v4.3, the root cause was   actually that Finit was waiting for a process that was no longer in   the system.  The fix is to ask the kernel on process-stop-timeout and   replay the lost PID so that Finit can continue with reboot/shutdown</li> <li>Fix #358: fix inotify events for <code>/etc/finit.conf</code>, improved log   messages and error handling</li> <li>Fix #361: cgroup move fail if run/task/services start as non-root.   Regression in the v4.4 release cycle while adding support for the   pre:/post:/ready: scripts.  Now the latter scripts also properly run   in their correct cgroup</li> <li>Fix #366: document <code>fsck.*</code> kernel command line options and simplify   the configure flags <code>--enable-fsckfix</code> and <code>--enable-fastboot</code> to   only adjust the default values for the <code>fsck.*</code> options.</li> <li>Fix #371: swap load order of <code>/lib/finit/system/*</code> vs <code>/etc/finit.d/*</code>   We must run <code>10-hotplug.conf</code> first to ensure devices and modules are   up and loaded before the user's run/task/services are called.  The order   at bootstrap is now saved in <code>/run/finit/conf.order</code> for inspection,   <code>/run/finit/exec.order</code> shows the start order of each process</li> <li>Fix #372: lost <code>udevadm</code> calls due to overloading</li> <li>Adjust final <code>udevadm settle</code> timeout: 5 -&gt; 30 sec</li> <li>Fixed dbus plugin, the function that located <code>&lt;pidfile&gt; ...</code> in the   <code>dbus/system.conf</code> caused spurious line breaks which led to the   service not being loaded properly</li> <li>The <code>runparts</code> executor now skips backup files (<code>foo~</code>)</li> <li>The <code>runparts</code> stanza now properly appends <code>start</code> to scripts that   start with <code>S[0-9]+</code>.  This has been broken for a very long time.</li> <li>Fix #377: expand service <code>env:file</code> variables, allow constructs like:<pre><code>RUNDIR=/var/run/somesvc\nDAEMON_ARGS=--workdir $RUNDIR --other-args...\n</code></pre> <ul> <li>Fix #378: warn on console if run/task times out during bootstrap</li> <li>Fix #378: add run/task support for <code>&lt;!&gt;</code> to allow transition from   bootstrap to multi-user runlevel even though task has not run yet.</li> <li>Fix #382: do not clear <code>&lt;service/foo/STATE&gt;</code> conditions on reload.   Introduced back in v4.3-rc2, 82cc10be8, the support for automatic   service conditions have had a weird and unintended behavior.  Any   change in state (see <code>doc/svc-machine.png</code>) caused Finit to clear   out all previously acquired service conditions.</li> </ul> </li> </ul> <p>However, when moving between RUNNING and PAUSED states, a service   should not have its conditions cleared.  The PAUSED state, seen   also by all conditions moving to FLUX, is only temporary while an   <code>initctl reload</code> is processed.  If a service has no changes to be   applied it will move back to RUNNING.</p> <p>Also, we cannot clear the service conditions because other run/task   or services may depend on it and clearing them would cause Finit to   <code>SIGTERM</code> these processes (since they are no longer eligible to run).</p>"},{"location":"ChangeLog/#44-2023-05-15","title":"4.4 - 2023-05-15","text":"<p>Note 1: this release contains changes to the <code>.conf</code> parser.  If you have .conf file statements with comment character (<code>#</code>) in the command options or description, you must now escape them (<code>\\#</code>).  Issue #186</p> <p>Note 2: prior to this release, runlevel <code>S</code> and <code>0</code> were after boot treated as the same runlevel.  This caused <code>task [06] ...</code>  to also run at bootstrap instead of just at shutdown and reboot.  The changes made to Finit to separate <code>S</code> from <code>0</code> require you to update the allowed runlevels for services that are allowed to continue running at shutdown.  I.e., change <code>[S123456789]</code> to <code>[S0123456789]</code> for, e.g., <code>sysklogd</code>.  Issue #352</p>"},{"location":"ChangeLog/#changes_11","title":"Changes","text":"<ul> <li>Add limited tmpfiles.d(5) support</li> </ul> <p>This change adds very basic <code>tmpfiles.d/</code> support to Finit.  Most of   the basic types are supported, but not all, so for now, please check   the code and examples for details on what is working.</p> <ul> <li>If a run/task/service command does not exist, skip registering it</li> </ul> <p>This changes the semantics of Finit a bit by checking for the command   to run when registering it, skipping commands that cannot be found in   the absolute path provided in the command, or in <code>$PATH</code></p> <p>This change includes a new <code>nowarn</code> flag that can be used to prevent   Finit from warning for missing commands.  See below for an example.</p> <ul> <li>Add run/task/service support for <code>conflict:foo</code> handling</li> <li>Add run/task/service support for <code>if:[!]ident</code> and <code>if:&lt;[!]cond&gt;</code></li> </ul> <p>Conditional loading of stanza depending on ident is already loaded (or   not), or condition satisfied (or not).  E.g., do not run <code>mdev</code> if we   found and registered <code>udevd</code>, or load service only if <code>&lt;boot/testing&gt;</code>   condition is set.</p> <p>The optional leading <code>!</code> negates the comparison, if NOT foo then ...</p> <ul> <li>Add support for static services in <code>/lib/finit/system/*.conf</code></li> </ul> <p>Slowly migrating away from hard-coded services in plugins.  This way   it's possible for the user to both inspect and override as needed.</p> <ul> <li>Migrate hotplug plugin to a conditional <code>/lib/finit/system/hotplug.conf</code></li> </ul> <p>This is the first example of the just minted advanced stanza syntax with   <code>if:</code>-statements, <code>conflict:</code> handling, and <code>nowarn</code> flags.</p> <ul> <li>Initial support for template services, <code>foo@.conf</code>, similar to systemd<pre><code>$ initctl show avahi-autoipd@\nservice :%i avahi-autoipd --syslog %i -- ZeroConf for %i\n</code></pre> </li> </ul> <p>To enable ZeroConf for, e.g., <code>eth0</code>, use</p> <pre><code>    $ initctl enable avahi-autoipd@eth0.conf\n</code></pre> <p>The enabled symlink will be set up to <code>avahi-autoipd@.conf</code> and every   instance of <code>%i</code> will in the instantiated directive be replaced with   <code>eth0</code>.  Inspect the result with:</p> <pre><code>    $ initctl status avahi-autoipd:eth0\n</code></pre> <ul> <li>Add <code>devmon</code>, a <code>&lt;dev/foo&gt;</code> condition provider, issue #185</li> <li> <p>Support for line continuation character <code>\\</code> in .conf files, issue #186</p> <pre><code>service name:sysklogd [S123456789]   \\\n    env:-/etc/default/sysklogd       \\\n    syslogd -F $SYSLOGD_ARGS         \\\n    -- System log daemon\n</code></pre> </li> <li> <p><code>HOOK_BASEFS_UP</code> has been moved!  External plugins that need to call   <code>service_register()</code>, please use <code>HOOK_SVC_PLUGIN</code> from now on.   Apologies for any inconveniences this might cause!</p> </li> <li>getty: add support for <code>/etc/os-release</code> to replace <code>uname</code> output   This change, which has a fallback to <code>/usr/lib/os-release</code>, overrides   traditional modifiers with the os-release variant.  These values were   taken from <code>uname</code>, which on Linux systems are pretty useless since   they always return the kernel name and version instead of the   distro/OS values.</li> </ul> <p>E.g., \\s becomes <code>PRETTY_NAME</code> instead of 'Linux' and \\v becomes the   pretty <code>VERSION</code>, while \\r becomes <code>VERSION_ID</code>. * Support for overriding <code>/etc/finit.conf</code> and <code>/etc/finit.d</code> issue #235   New (kernel) command line option <code>finit.config=PATH</code> which can be used   to redirect Finit to start up with, e.g., <code>/etc/factory.conf</code> instead of   <code>/etc/finit.conf</code>.</p> <p>For the complete experience a new top-level configuration file directive   <code>rcsd PATH</code> has also been added.  It in turn can be used by <code>factory.conf</code>   as follows to override <code>/etc/finit.d</code>:</p> <pre><code>    rcsd /etc/factory.d\n</code></pre> <ul> <li>Support for overriding <code>/etc/finit.d</code> from the alternate <code>finit.conf</code>   with a new <code>rcsd /path/to/dot.d/</code> .conf file directive</li> <li>Support for <code>fsck_mode=[auto,skip,force]</code> + <code>fsck_repair=[preen,no,yes]</code></li> <li>Add <code>set</code> keyword for environment variables set in <code>/etc/finit.conf</code></li> <li>Support <code>finit.cond=foo</code> cmdline <code>&lt;boot/foo&gt;</code> conditions, issue #250</li> <li><code>initctl</code> JSON output support for status and conditions, issue #273   Example:<pre><code>root@infix:~$ initctl status -j resolvconf\n{\n  \"identity\": \"resolvconf\",\n  \"description\": \"Update DNS configuration\",\n  \"type\": \"task\",\n  \"forking\": false,\n  \"status\": \"done\",\n  \"exit\": { \"code\": 0 },\n  \"origin\": \"/etc/finit.d/enabled/sysrepo.conf\",\n  \"command\": \"resolvconf -u\",\n  \"restarts\": 0,\n  \"pidfile\": \"none\",\n  \"pid\": 0,\n  \"user\": \"root\",\n  \"group\": \"root\",\n  \"uptime\": 0,\n  \"runlevels\": [ 1, 2, 3, 4, 5, 7, 8, 9 ]\n}\n</code></pre> </li> </ul> <p>The excellent tool <code>jq</code> can be used to extract parts of the output for   further scripting.  E.g. <code>initctl status -j foo | jq .exit.status</code></p> <ul> <li>Add JSON support to <code>initctl ls</code> command  </li> </ul> <p>This allows for easy access to the disabled services:</p> <pre><code>    root@anarchy:~# initctl ls --json |jq '.available - .enabled'\n    [\n      \"chronyd.conf\",\n      \"dnsmasq.conf\",\n      \"gdbserver.conf\",\n      \"inadyn.conf\",\n      \"inetd.conf\",\n      \"isisd.conf\",\n      \"lldpd.conf\",\n      \"mstpd.conf\",\n      \"ntpd.conf\",\n      \"ospf6d.conf\",\n      \"ospfd.conf\",\n      \"querierd.conf\",\n      \"ripd.conf\",\n      \"ripng.conf\",\n      \"sshd.conf\",\n      \"syslogd.conf\",\n      \"telnetd.conf\",\n      \"uftpd.conf\",\n      \"wpa_supplicant.conf\",\n      \"zebra.conf\"\n    ]\n</code></pre> <ul> <li>Allow <code>manual:yes</code> on sysv/service/run/task stanzas, issue #274</li> <li>Add support for <code>oncrash:script</code> to call the <code>post:script</code> action, if   defined, for a crashing service.  The <code>EXIT_CODE</code> variable sent to the   script is set to <code>crashed</code>. Issue #282</li> <li>Search for plugins in <code>/usr</code> and <code>/usr/local</code> as well, issue #284</li> <li>tty: add support for <code>passenv</code> flag to <code>/bin/login</code>, issue #286</li> <li>Add reboot/shutdown/poweroff timeout <code>-t SEC</code> to initctl, issue #295</li> <li>Add support for s6 and systemd readiness notification, issue #299.   Service readiness notification to support daemons employing systemd   and s6 notification.  Complementing the native Finit readiness support   using PID files that exist already.</li> </ul> <p>The two have slightly different ways of implementing readiness:</p> <ul> <li>https://www.freedesktop.org/software/systemd/man/sd_notify.html</li> <li>https://skarnet.org/software/s6/notifywhenup.html</li> </ul> <p>Finit now provides both a <code>NOTIFY_SOCKET</code> environment variable, for   systemd, and a way to start s6 daemons with a descriptor argument.</p> <p>For details on the syntax, see the <code>service</code> documentation.</p> <p>This change also renames internal states for run/task/services to   avoid any confusion with the introduction of <code>ready:scripts</code>:</p> <ul> <li><code>WAITING -&gt; PAUSED</code></li> <li><code>READY   -&gt; WAITING</code></li> </ul> <p>A service condition that used, e.g., <code>&lt;service/foo/ready&gt;</code> should now   instead use <code>&lt;service/foo/waiting&gt;</code></p> <ul> <li>Add <code>ready:script</code> for services, called when daemon is ready, issue #300</li> <li> <p>Add support for running scripts at shutdown at two new hook points   during the shutdown process, issue #302. See doc/plugins.md for details:</p> </li> <li> <p><code>HOOK_SVC_DN</code>: after all services and non-reserved processes have been     killed (and collected)</p> </li> <li> <p><code>HOOK_SYS_DN</code>: after all file systems have been unmounted, just prior     to Finit calling <code>reboot()</code> to shut down or reboot the system</p> </li> <li> <p>The <code>modules-load</code> plugin now default to runlevel <code>[S]</code>, in previous   releases it was <code>[2345]</code>.  This breaking change is to align it more   with what users mostly want (modules loaded before services start) and   can be changed back to the old behavior with a per-file setting:</p> <pre><code>set runlevel 2345\n</code></pre> </li> <li> <p>The <code>modules-load</code> plugin now adds silent tasks for modprobe.  This to   prevent confusing <code>[ OK ]</code> boot messages when in fact modprobe failed.</p> </li> <li>The <code>modules-load</code> plugin now support <code>set modprobe /path/to/modprobe</code></li> <li>The header files <code>finit/conf.h</code> and <code>finit/service.h</code> are now exported   for external plugins</li> <li>Add support for multiple args to <code>initctl cond set/clr</code>, issue #329</li> <li>Silence confusing <code>[ OK ]</code> progress from modules-load plugin, issue #332  </li> </ul> <p>This change drops the confusing status progress output, which was always   OK since the actual modprobe operation runs in the background.  No need   to show status of the \"added a task to finit, found modprobe\" command.</p> <ul> <li>dbus plugin: adapt to other operating systems</li> </ul> <p>Not all Linux systems are based on Debian, and even if they are inspired   by Debian (Buildroot), they do not necessarily use the same defaults.   Probes the system at runtime for:</p> <ul> <li>dbus user and group</li> <li>dbus PID file</li> </ul> <p>If the user/group cannot be found we fall back to <code>root</code>, if the PID   file cannot be determined we ignore PID file readiness.</p> <ul> <li>Improve documentation for runparts and hook scripts.  Issue #315, #320</li> <li>Add <code>HOOK_NETWORK_DN</code>, called after change to runlevel 6 or 0, issue #319</li> <li>Use sysklogd <code>logger</code> tool instead of legacy <code>logit</code> tool, issue #344</li> </ul> <p>For log redirection Finit has the legacy <code>logit</code> tool.  This change   allows Finit to use the <code>sysklogd</code> project's extended <code>logger</code> tool   instead, when available.  Allowing logging with the process' PID.</p> <ul> <li>Add <code>initctl</code> aliases: <code>cat -&gt; show</code>, <code>kill -&gt; signal</code></li> <li>Add <code>initctl -n,--noerr</code> to return OK(0) if services do not exist, for   integration with openresolv and scripts with similar requirements</li> <li>Add <code>initctl plugins</code>, list installed plugins</li> <li>Add timestamp to log messages in fallback and logging to <code>stderr</code>.   When there is no log daemon, and we are running in a container, or we   cannot log to the kernel ring buffer, then we log to <code>stderr</code>.  This   change improves log output by prefixing each message with a timestamp.</li> </ul>"},{"location":"ChangeLog/#fixes_11","title":"Fixes","text":"<ul> <li>Fix #254: document limitations in <code>rc.local</code> and <code>runparts</code> scripts</li> <li>Fix #269: add compulsory kernel symlinks in <code>/dev</code></li> <li>Fix #275: <code>initctl status foo</code> should list all instances, regression   introduced in v4.3</li> <li>Fix #278: enforce conditions also for running <code>pre:</code> scripts</li> <li>Fix #279: allow <code>restart:always</code>, of crashing services.  Similar to   <code>respawn</code> but honors <code>restart_sec</code></li> <li>Fix #280: allow calling <code>initctl restart foo</code> from within foo</li> <li>Fix #283: too quick timeout at bootstrap of lingering tasks</li> <li>Fix #285: <code>initctl restart</code> should start crashed service</li> <li>Fix #288: enable built-in <code>sulogin</code> in Alpine and Void Linux builds</li> <li>Fix #293: modprobe plugin: support for coldplugging more devices.  It   turns out, not all buses in Linux add <code>modalias</code> attributes to their   devices in sysfs.  One notable exception are MDIO buses.  The plugin's   scan routine would thus not pick them up.</li> <li>Fix #294: <code>shutdown --help</code> mistakenly shuts down system</li> <li>Fix #310: Always use configured restart delay for crashing services.   If no delay is configured, default to an initial 2000 msec for forking   daemons and start-stop scripts, and 1 msec for non-forking daemons</li> <li>Fix #311: document how to combine device tree with conditions</li> <li>Fix #312: restart services with respawn set, e.g. ttys, immediately</li> <li>Fix #313: Cancel pending restart timer on stop/start/restart/reload</li> <li>Fix #314: skip run/task/service restart if conditions are lost</li> <li>Fix #315: add environment variables to hook scripts</li> </ul> <p>All hook scripts are called with at least one environment variable   set, <code>FINIT_HOOK_NAME</code>, useful when reusing the same hook script for   multiple hook points.  It is set to the string name, also used by the   path, e.g., <code>hook/net/up</code></p> <p>For all hook points from hook/sys/shutdown and later, <code>FINIT_SHUTDOWN</code>   is also set, to one of: <code>halt</code>, <code>poweroff</code>, <code>reboot</code></p> <ul> <li>Fix #317: make sure hook scripts don't run twice, also fixes #316</li> <li>Fix #318: only show <code>[ OK ] Calling foo</code> progress for <code>runparts ...</code></li> <li>Fix #320: the API/IPC socket is closed immediately at shutdown/reboot   to protect hook scripts or services calling initctl.  There is no way   to service these requests safely at that time</li> <li>Fix #333: consider a service dirty if command line args have changed</li> </ul> <p>This fixes <code>initctl reload</code> correctly restarting all daemons that have   new command line arguments.</p> <p>Previously command line arguments changes were only acted upon if the   service was explicitly reloaded <code>initctl reload myservice</code>.</p> <p>Found and fixed by Jack Newman</p> <ul> <li>Fix #338: ensure shutdown hooks are called properly; <code>hook/sys/down</code>   and <code>hook/svc/down</code> hook scripts, found and fixed by Jack Newman</li> <li>Fix #339: use absolute path in <code>/etc/finit.d/enabled/</code> symlinks, for   use-cases when <code>/etc</code> is read-only and <code>/etc/finit.d/enabled -&gt;   /mnt/finit.d/enabled</code>, reported by Jack Newman</li> <li>Fix #340: Finit ignores deleted/moved <code>.conf</code> file sin <code>/etc/finit.d</code></li> <li>Fix #342: in runlevel S (bootstrap), not all <code>initctl</code> commands can be   supported, block the following: runlevel, reload, start/stop, restart,   reload, halt, poweroff, suspend.  Also, prevent <code>SIGHUP</code> and <code>SIGUSR1</code>   signals when in shutdown or reboot</li> <li>Fix #352: separate runlevel S from runlevel 0</li> <li>Fix #355: regression in v3.2 stopping a process and its group</li> </ul> <p>In Finit v3.2 a regression was introduced that affects the way Finit   stops a supervised process and its process group.</p> <p>Instead of sending SIGTERM to the process, and thus delegating the   responsibility to that process to inform any children it may have, as   of commit 91a9c83 Finit sends SIGTERM to the entire process group.   For SIGKILL this is fine, SIGKILL only runs as cleanup and as a last   ditch effort if the process doesn't respond to SIGTERM.</p> <p>This regression, introduced in v3.2, directly affects services like   <code>avahi-autoipd</code> that have forked off children that it needs to tell to   exit cleanly before it returns.  With the patch in question these   children are never allowed to complete, which in turn causes lingering   169.254 link-local addresses on interfaces.</p> <ul> <li> <p>Fix bootmisc plugin: octal permission on <code>/run/lock</code> and <code>/var/lock</code></p> </li> <li> <p>Ensure <code>initctl cond get</code> support the flux state (exit code 255)</p> </li> <li>Fix potential socket leak at bootstrap and shutdown</li> <li>Fix potential NULL pointer deref in kernel command line parser</li> <li>Fix lingering condition in service after reload of service with new   config that has no condition</li> <li>Fix wrong path to command in service after reload, may have changed</li> <li><code>logit</code>: fall back to package name if <code>$LOGNAME</code> and <code>$USER</code> are   unset.  Note: you should probably not use <code>logit</code> in your own   scripts, it is only meant for internal use by Finit.  We recommend   using <code>logger</code> from the <code>bsdutils</code> or <code>sysklogd</code> packages instead</li> <li>Fix issue where <code>env:</code>/<code>pre:</code>/<code>post:</code>/etc. is removed from a service</li> </ul> <p>The trick is when reloading a service like this:</p> <pre><code>    service env:/etc/env    serv -np -e foo:bar\n</code></pre> <p>into this:</p> <pre><code>    service pre:/bin/pre.sh serv -np\n</code></pre> <p>In the second the <code>env:</code> has been removed and <code>pre:</code> added.  Prior to   this patch, <code>env:</code> was kept leading to unintended behavior. * Fix parse/diff of command line args, e.g., <code>nginx -g 'daemon off;'</code></p> <p>Starting a service like this works fine:</p> <pre><code>    service [2345789] env:-/etc/default/nginx nginx -g 'daemon off;'\n</code></pre> <p>However, on <code>initctl reload</code> (and no change to .conf files) the arg   list was lost while parsing the .conf files.  Leading to a false   positive 'diff' in args causing nginx to be unnecessarily restarted. * Fix issue with disabled \"linewrap\" on the console TTY after login.   The root cause is <code>qemu-system-x86_64 -nographics</code> disabling it when   starting up.  The correct <code>\\e[?7h</code> escape code is now used.</p>"},{"location":"ChangeLog/#43-2022-05-15","title":"4.3 - 2022-05-15","text":"<p>Critical bug fix release.  If you run a 32-bit target with GLIBC 2.34 you need to upgrade!</p> <p>Note: system verbosity on console at start and shutdown has been           increased.  Now the output of all commands is logged to the           system logger, for early services <code>/dev/kmsg</code> is used.</p> <p>Also: please notice the updated support for enabling and disabling           kernel and Finit debug messages on the system console.  Very           useful when debugging either of them, e.g., a kernel module.           For details, see cmdline.md.</p>"},{"location":"ChangeLog/#changes_12","title":"Changes","text":"<ul> <li>Support for overriding default runlevel from kernel command line.  Any   runlevel <code>[1-9]</code> may be selected, except 6 (reboot).  Issue #261</li> <li>New command line option: <code>finit.fstab=/etc/fstab.custom</code>, with full   support for mounting, mount helpers, fsck, and swapon/off, issue #224</li> <li>Support for special device <code>/dev/root</code>, which may not exist in <code>/dev</code>.   Finit now looks up the matching block device for <code>/</code> in <code>/sys/block/</code></li> <li>Loading <code>module</code>s no longer shows arguments in progress output</li> <li>Warning messages in progress output now in yellow, not red, issue #214</li> <li><code>initctl</code>, new command line option <code>-V,--version</code> for ease of use</li> <li>New condition <code>done</code> for run task, issue #207 by Ming Liu, Atlas Copco</li> <li>Refactor parts of shutdown and reboot sequence for PREEMPT-RT kernels,   by Robert Andersson, Mathias Thore, and Ming Liu, Atlas Copco</li> <li>Conditions for run/task/sysv status, e.g. <code>run/foo/success</code> and   <code>task/bar/failure</code>.  Issue #232, by Ming Liu, Atlas Copco</li> <li>Conditions for services, can be used to synchronize other stanzas:</li> <li><code>service/foo/running</code></li> <li><code>service/foo/halted</code></li> <li><code>service/foo/missing</code></li> <li><code>service/foo/crashed</code></li> <li><code>service/foo/stopped</code></li> <li><code>service/foo/busy</code></li> <li><code>service/foo/restart</code></li> <li><code>initctl signal</code> support, by J\u00f6rgen Sigvardsson, issue #225</li> <li><code>initctl cond get</code> support to match <code>cond [set | clear]</code>, issue #255</li> <li><code>[WARN]</code> messages on console now printed in yellow, issue #214</li> <li>Network services now also stopped when going to runlevel 6 (reboot),   not just runlevel 0 (shutdown) or 1 (single-user)</li> <li>When <code>ifup</code> is missing on the system, bring at least <code>lo</code> up at boot</li> <li>Log output from <code>ifup -a</code> (and <code>ifdown -a</code>), to syslog</li> <li>Avoid blocking PID 1 when starting SysV init scripts</li> <li>Allow custom <code>pid:</code> for SysV init scripts</li> <li>Document supported types of forking/non-forking services</li> <li>Auto-detect running in some common forms of containers</li> <li>Simplify shutdown/reboot when running in a container</li> <li>Log to <code>stderr</code> when running in a container w/o syslog daemon</li> <li>Add support for <code>type:forking</code> to services, already supported but   with a very difficult <code>pid:</code> syntax, issue #223.  Docs updated</li> <li>Support for setting global environment variables in <code>finit.conf</code>,   please note: this also affects Finit itself, be careful!</li> <li>Extended environment variables for pre/post scripts, issue #189</li> <li>Document secret service option <code>respawn</code>, which bypasses the crash   semantics, allowing endless restarts</li> <li>Document secret <code>HOOK_BANNER</code>, the first hook point before the banner</li> <li>Document slightly confusing <code>initctl reload foo</code> command.  It does   not reload the service's <code>.conf</code> file!  Issue #263</li> <li>Log changes; all instances where previously the <code>basename cmd</code> of a   service was used to identify the service, now the proper <code>name:id</code> is   used instead.  Meaning, a service without a custom <code>:ID</code> or <code>name:</code>   will display the same as before, but with any of those customizations   the name and name:id will now be shown.  Note: this may affect any   log scrapers out there!</li> <li>New plugin: <code>hook-scripts</code>, allows run-parts(8) style scripts to   run on any hook point.  Contributed by Tobias Waldekranz</li> <li><code>initctl</code> (<code>reboot</code>) falls back to <code>-f</code> when it detects it is in   <code>sulogin</code> recovery mode, issue #247</li> <li>The bundled <code>sulogin</code> is no longer enabled by default, in favor of   distribution versions.  Enable with <code>./configure --with-sulogin</code></li> <li>Support args to sysv-like scripts, e.g. <code>bridge-stp br0 start</code></li> <li>The <code>modules-load</code> plugin now skips all lines starting with <code>#</code> and   <code>;</code>.  Furthermore, files in <code>/etc/modules-load.d/*.conf</code> are now read   in lexicographic order and UNIX backup files (<code>foo.conf~</code>) are skipped</li> <li>The <code>name:id</code> tuple is now more consistently used in all log and debug   messages instead of the basename of the command</li> <li>Simplify error output of <code>initctl start/stop/restart/signal</code>, no more   extra usage help, just a plain error message</li> <li>Exit codes of <code>initctl</code> have changed to use LSB script standard and BSD   sysexits.h exit codes.  As before, a non-zero exit is error or missing</li> <li>Add support for <code>initctl -q</code> to more commands: stop, start, restart,   reload, signal, etc.</li> </ul>"},{"location":"ChangeLog/#fixes_12","title":"Fixes","text":"<ul> <li>Fix nasty 32/64-bit alignment issue between finit and its plugins,   applicable to 32-bit targets with GLIBC 2.34 and later.  External   plugins must make sure to use, at least: <code>-D_TIME_BITS=64</code></li> <li>Fix #215: disable cgroup support at runtime if kernel lacks support   or does not have the required controllers (cpu)</li> <li>Fix #217: iwatcher initialization issue, by Ming Liu, Atlas Copco</li> <li>Fix #218: initctl matches too many services, by Ming Liu, Atlas Copco</li> <li>Fix #219: not all filesystems unmounted at shutdown, by Ming Liu,    Mathias Thore, and Robert Andersson, Atlas Copco</li> <li>Fix #226: initctl shows wrong PID for crashing services</li> <li>Fix #227: reboot stalls if process stopped with <code>[WARN]</code></li> <li>Fix #233: initctl shows wrong status for run/task, by Sergio Morlans   and Ming Liu, Atlas Copco</li> <li>Fix #248: source <code>env:file</code> also in <code>pre:</code> and <code>post</code> scripts</li> <li>Fix #260: drop limit on device name in <code>Checking filesystem...</code> output</li> <li>Fix start/stop and monitoring (restart) of SysV init scripts and   forking services, see the updated documentation for details</li> <li>Fix call to <code>swapoff</code> at shutdown, does not support <code>-e</code> flag</li> <li>Fix suspend to RAM issue.  Previously <code>reboot(RB_SW_SUSPEND)</code> was   used, now the modern <code>/sys/power/state</code> API is used instead.</li> <li>Fix nasty run/task/service matcher bug, triggered by stanzas using the   same basename of a command but different <code>:ID</code>.  Caused Finit to match   with already registered but different run/task/service</li> </ul>"},{"location":"ChangeLog/#42-2022-01-16","title":"4.2 - 2022-01-16","text":""},{"location":"ChangeLog/#changes_13","title":"Changes","text":"<ul> <li>Support for non-root users to use <code>initctl</code>, e.g. group wheel</li> <li>Support for new libite (-lite) header namespace</li> <li>RTC plugin now reset an invalid RTC time to the kernel default   time, 2000-01-01 00:00, prevents errors and is less crazy than   some systems coming with with &lt;= Jan 1, 1970</li> <li>urandom plugin now use RNDADDENTROPY ioctl to seed kernel rng,   incrementing entropy count.  Also, 32 kiB instead of 512 bytes are   now saved (and restored) on reboot.  This should greatly improve   reliability of systems with none or poor HWRNG</li> <li>Kernel logging to console (loglevel &gt;= 7, debug, when quiet mode is   not used) is now honored by Finit, regardless of the finit.debug   command line option</li> <li>Reduced default log level from <code>LOG_NOTICE</code> to <code>LOG_INFO</code></li> <li>Wrapped all calls to mount(2) to add logging in case of failure</li> <li>New configure options to control fastboot (no fsck) and fsck fix   options, by Ming Liu, Atlas Copco</li> <li>Support for overriding default <code>/etc/nologin</code> file with an external   <code>#define</code>, by Ming Liu, Atlas Copco</li> <li>Support for overriding default <code>/var/run/dbus/pid</code> file with an   external <code>#define</code>, by Ming Liu, Atlas Copco</li> <li>Support for more service options to control respawn behavior of   crashing services, by Robert Andersson and Ming Liu, Atlas Copco</li> <li>Support for <code>initctl ident [NAME]</code> which lists all instances of   <code>NAME</code>, or all enabled system run/tasks and services</li> <li>Show number of total restarts and current respawn count for a   service in <code>initctl status foo</code></li> <li>Crashing services no longer have the crash/restart counter reset as   soon as they have stabilized.  Instead, a background timer will   slowly (every 300 sec) age (decrement) the counter.  This will still   catch services that \"rage quit\", but also those that crash after a   longer period of activity</li> </ul>"},{"location":"ChangeLog/#fixes_13","title":"Fixes","text":"<ul> <li>Fix #180: user managed (<code>manual:yes</code>) services accidentally started   by <code>initctl reload</code>, regression introduced in Finit v4.0</li> <li>Fix #181: lots of typos all over the tree, by David Yang, Debian</li> <li>Fix #187: fix typos, incl. small cleanup, in doc/bootstrap.md</li> <li>Fix #188: support running on kernels that do not have cgroups v2.   When this is detect, all functions related to cgroups support in   Finit are disabled, except the .conf file parser.  Hence, you   may get parse error if you have invalid cgroup configuration in   your Finit .conf files</li> <li>Fix #197: <code>initctl status foo</code> now shows a focused overview of all   matching instances; foo:1, foo:2 -- if only one instance matches the   command line argument, or if onle one instance exists, the detailed   view is shown, as before</li> <li>Fix #198: a few typos found by Tim Gates</li> <li>Fix #199: avoid using C++ reserved keywords</li> <li>Fix #201: memory leak in usr condition plugin, by Ming Liu, Atlas Copco</li> <li>Fix #203: ensure all filesystems listed in /proc/mounts are properly   unumounted on shutdown/reboot, by Robert Andersson, Atlas Copco</li> <li>Fix #210: resizing terminal (smaller) after boot causes empty lines   to be inserted between boot progress</li> <li>Fix #211: drop hard-coded 32 character limit in getty, now reads   <code>_SC_LOGIN_NAME_MAX</code> from <code>sysconf(3)</code></li> <li>Fix #212: service PID file lost after inictl reload, visible from   the output from <code>initctl status foo</code></li> </ul>"},{"location":"ChangeLog/#41-2021-06-06","title":"4.1 - 2021-06-06","text":"<p>Bug fix release.  Also disables handlers for <code>SIGINT</code> and <code>SIGPWR</code>, a new set of <code>sys</code> conditions are instead generated which can be used to trigger external programs.</p>"},{"location":"ChangeLog/#changes_14","title":"Changes","text":"<ul> <li>Change behavior on SIGUSR1 to be compatible with sysvinit and systemd.   Previously SIGUSR1 caused Finit to halt, like BusyBox init.  This had   \"interesting\" side effects on Debian systems when coexisting with   sysvinit (upgrading/reinstalling causes scripts to <code>kill -USR1 1</code>)</li> <li>Change how <code>contrib/debian/install.sh</code> sets up a Grub boot entry for   finit.  We now modify the $SUPPORTED_INITS variable in <code>10_linux</code></li> <li>Disable default kernel ctrl-alt-delete handler and let Finit instead   catch <code>SIGINT</code> from kernel to be able to perform a proper reboot.   There is no default command for this, you need to set up a task that   triggers on <code>&lt;sys/key/ctrlaltdel&gt;</code> to issue <code>initctl reboot</code></li> <li>Added keventd to provide <code>&lt;sys/pwr/ac&gt;</code> condition to Finit.  keventd   is currently only responsible for monitoring <code>/sys/class/power_supply</code>   for changes to active AC mains power online status.  Enable keventd   with <code>configure --with-keventd</code></li> <li>For handling power fail events (from UPS and similar) a process may   send <code>SIGPWR</code> to PID 1. Finit no longer redirects this to <code>SIGUSR1</code>   (poweroff).  There is no default command for this, you need to set up   a task that triggers on <code>&lt;sys/pwr/fail&gt;</code> to issue <code>initctl poweroff</code></li> <li>Built-in Finit getty is now a standalone program</li> <li>Default termios for TTYs now enable <code>IUTF8</code> on input</li> <li>If <code>/bin/login</code> is not found, Finit now tries <code>sulogin</code> before it   falls back to an unauthenticated <code>/bin/sh</code></li> <li>Dropped (broken) support for multiple consoles.  Finit now follows   the default console selected by the kernel, <code>/dev/console</code></li> <li>Dropped signal handlers for SIGSTOP/TSTP and SIGCONT</li> <li>Added support for <code>\\n</code>, in addition to <code>\\r</code>, in \"Please press Enter\"   prompt before starting getty</li> <li>Finit no longer parses <code>/proc/cmdline</code> for its options.  Instead all   options are by default now read from <code>argv[]</code>, like a normal program,   this is also what the kernel does by default.  Please note, this may   not work if your systems boots with an initramfs (ymmv), for such   cases, see <code>configure --enable-kernel-cmdline</code></li> <li>The following plugins are now possible to disable (for containers):   <code>rtc.so</code>, <code>urandom.so</code>, you may also want to disable <code>hotplug.so</code>.   They are all enabled by default, as in Finit 4.0, but may be moved   to external tools or entries in <code>finit.conf</code> in Finit 5.0</li> <li>Added support for reading <code>PRETTY_NAME</code> from <code>/etc/os-release</code> to use   as heading in progress output, unless <code>--with-heading=GREET</code> is used.</li> <li>Added manual pages for finit(8), initctl(8), and finit.conf(5)</li> </ul>"},{"location":"ChangeLog/#fixes_14","title":"Fixes","text":"<ul> <li>Stricter interface name validation in netlink plugin, modeled after   the kernel.  Suggested by Coverity Scan</li> <li>Fix problem of re-registering a service as a task.  Previously, if a   fundamental change, like type, was made to an active service/run/task   it did not take.  Only possible workaround was to remove from config</li> <li>initctl: drop warning when removing a non-existing usr condition</li> <li>initctl: drop confusing <code>errno 0</code> when timing out waiting for reply</li> <li>Ensure services in plugins and from Finit main belong to a cgroup</li> <li>Ensure init top-level cgroup remains a leaf group</li> <li>Fix tty parse error for detecting use of external getty</li> <li>Fix default <code>name:</code> and <code>:ID</code> for tty's, e.g. <code>ttyS0</code> now gives   <code>tty:S0</code> as expected.  This was default for built-in getty already</li> <li>Fix max username (32 chars) in bundled Finit getty</li> <li>The <code>contrib/*/install.sh</code> scripts failed to run from tarball</li> <li>Finit no longer forcibly mounts; <code>/dev</code>, <code>/proc</code>, or <code>/sys</code>, instead   it checks first if they are already mounted (devtmpfs or container)</li> <li>Fix <code>/etc/fstab</code> parser to properly check for 'ro' to not remount the   root filesystem at boot.  The wrong field was read, so a root mounted   by an initramfs, or by lxc for a container, had their root remounted</li> <li>Fix SIGCHLD handler, <code>waitpd()</code> may be interrupted by a signal</li> <li>Reset <code>starting</code> flag of services being stopped.  When a service   is started and then stopped before it has created its pid file,   it could be left forever in the stopping state, unless we reset   the starting flag.</li> <li>Fix #170: detect loss of default route when interfaces go down.  This   emulates the missing kernel netlink message to remove the condition   net/default/route to allow stopping dependent services</li> <li>Fix #171: restore automatic mount of <code>/dev/shm</code>, <code>/dev/pts</code>, <code>/run</code>   and <code>/tmp</code>, unless mounted already by <code>/etc/fstab</code>.  This is what most   desktop systems expect PID 1 to do.  Here we also make sure to mount   <code>/run/lock</code> as a tmpfs as well, with write perms for regular users,   this prevents regular users from filling up <code>/run</code> and causing DoS.</li> <li>Fix #173: netlink plugin runs out of socket buffer space;<pre><code>finit[1]: nl_callback():recv(): No buffer space available\n</code></pre> </li> </ul> <p>Fixed by adding support for resync with kernel on <code>ENOBUFS</code>.  See   netlink(7) for details.  As a spin-off the plugin now supports any   number of interfaces and routes on a system.  On resync, the following   message is now logged, as a warning:</p> <pre><code>    finit[1]: nl_callback():busy system, resynchronizing with kernel.\n</code></pre> <ul> <li>Fix #174: loss of log messages using combo of prio and facility, e.g.,   <code>logit(LOG_CONSOLE | LOG_NOTICE, ...)</code>, by Jacques de Laval, Westermo</li> <li>Fix #175: ensure Finit does not acquire a controlling TTY when checking   if a device is a TTY before starting a getty.  This fixes an old bug   where Ctrl-C after logout from a shell could cause PID 1 to get SIGINT,   which in turn could lead to a system reboot</li> </ul>"},{"location":"ChangeLog/#40-2021-04-26","title":"4.0 - 2021-04-26","text":"<p>This release became v4.0, and not v3.2, because of incompatible changes to service conditions.  There are other significant changes as well, so make sure to read the whole change log when upgrading.</p>"},{"location":"ChangeLog/#changes_15","title":"Changes","text":"<ul> <li>The stand-alone <code>reboot</code> tool has been replaced with a symlink to   <code>initctl</code>, like its siblings: halt, shutdown, poweroff, and suspend.   Calling <code>reboot</code> &amp; C:o now defaults to the corresponding <code>initctl cmd</code>   with a fallback to sending signals as per traditional SysV init.  The   <code>-f</code> (force) flag remains, where <code>reboot(2)</code> is called directly</li> <li>Introducing Finit progress \ud835\udcdc\ud835\udcf8\ud835\udced\ud835\udcee\ud835\udcfb\ud835\udcf7</li> <li>The <code>inictl cond set|clear COND</code> have changed completely.  Constrained   to a flat <code>&lt;usr/...&gt;</code> namespace and automatically activated by a new   <code>usr.so</code> plugin that checks services for usr condition changes</li> <li>Removed built-in inetd super server.  If you need this functionality,   use an external inetd, like xinetd, instead.  A pull request for a   stand-alone inetd, like watchdogd and getty, is most welcome!</li> <li>Incompatible <code>configure</code> script changes, i.e., no guessing <code>--prefix</code>   and other paths.  Also, many options have been changed, renamed, or   flipped defaults, or even dropped altogether.  There are examples in   the documentation and the <code>contrib/</code> section</li> <li>Service conditions change from the non-obvious <code>&lt;svc/path/to/foo&gt;</code> to   <code>&lt;pid/foo:id&gt;</code>.  Not only does this give simpler internal semantics,   it hopefully also makes it clear that one service's <code>pid:!foo</code> pidfile   is another service's <code>&lt;pid/foo&gt;</code> condition, issue #143</li> <li>Initial support for cgroups v2:</li> <li>services runs in a cgroup named after their respective *.conf file</li> <li>top-level groups are; init, user, and system</li> <li>all top-level groups can be configured from finit *.conf files</li> <li>each service can tweak the cgroup settings</li> <li>Use <code>initctl [top|ps|cgroup]</code> commands to inspect runtime state</li> <li>https://twitter.com/b0rk/status/1214341831049252870?s=20</li> <li>Major refactor of Finit's <code>main()</code> function to be able to start the   event loop earlier.  This also facilitated factoring out functionality   previously hard-coded in Finit, e.g., starting the bundled watchdogd,   various distro packed udevd and other hotplugging tools</li> <li>A proper rescue mode has been added.  It is started extremely early   and is protected with a bundled <code>sulogin</code>.  Exiting rescue mode now   brings up the system as a normal boot, as one expects</li> <li>Support for <code>sysv</code> start/stop scripts as well as monitoring forking   services, stared using <code>sysv</code> or <code>service</code> stanza</li> <li>Support for custom <code>kill:DELAY</code>, default 3 sec.</li> <li>Support for custom <code>halt:SIGNAL</code>, default SIGTERM</li> <li>Support for <code>pre:script</code> and <code>post:script</code>, allows for setup and   teardown/cleanup before and after a service runs, issue #129</li> <li>Support for <code>env:file</code> in <code>/etc/default/foo</code> or <code>/etc/conf.d/foo</code>, see   the contrib section for examples that utilize this feature.  Variables   expanded from env files, and the env files themselves, are tracked for   changes to see if a service .conf file is \"dirty\" and needs restart on   <code>initctl reload</code></li> <li>Support for tracking custom PID files, using <code>pid:!/path/to/foo.pid</code>,   useful with new <code>sysv</code> or <code>service</code> which fork to background</li> <li>Support starting run/task/services without absolute path, trust <code>$PATH</code></li> <li>Add support for <code>--disable-doc</code> and <code>--disable-contrib</code> to speed up   builds and work around issue with massively parallel builds</li> <li>Support for <code>@console</code> also for external getty</li> <li>Support for <code>notty</code> option to built-in getty, for board bring-up</li> <li>Support for <code>rescue</code> option to built-in getty, for rescue shells</li> <li>Add <code>-b</code>, batch mode, for non-interactive use to <code>initctl</code></li> <li>Prefer udev to handle <code>/dev/</code> if mdev is also available</li> <li>Redirect dbus daemon output to syslog</li> <li>Set <code>$SHELL</code>, like <code>$PATH</code>, to a sane default value, needed by BusyBox</li> <li>Finit no longer automatically reloads its <code>*.conf</code> files after running   <code>/etc/rc.local</code> or run-parts.  Use <code>initctl reload</code> instead.</li> <li><code>initctl</code> without an argument or option now defaults to list services</li> <li>Convert built-in watchdog daemon to standalone mini watchdogd, issue #102</li> <li>Improved watchdog hand-over, now based on <code>svc_t</code> and not PID</li> <li>Extended bootstrap, runlevel S, timeout: 10 --&gt; 120 sec. before services   not allowed in the runtime runlevel are unconditionally stopped</li> <li>Removed <code>HOOK_SVC_START</code> and <code>HOOK_SVC_LOST</code>, caused more problems   than they were worth.  Users are encouraged to use accounting instead</li> <li>Skip displaying \"Restarting ...\" progress for bootstrap processes</li> <li>Added a simple work queue mechanism to queue up work at boot + runtime</li> <li>Postpone deletion of <code>svc_t</code> until any <code>SIGKILL</code> timer has elapsed</li> <li>As long as a stepped service changes state we queue another step all     event, because services may depend on each other</li> <li>Require new libuEv API: <code>uev_init1()</code> to reduce event cache so that   the kernel can invalidate deleted events before enqueuing to userspace</li> <li>Rename <code>hwclock.so</code> plugin to <code>rtc.so</code> since it now is stand-alone   from the <code>hwclock</code> tool.  Note: the kernel can also be set to load   and store RTC to/from system clock at boot/halt as well, issue #110</li> <li>New plugin to support cold plugging devices, auto-loading of modules   at boot.  Detects required modules by reading <code>/sys/devices/*</code></li> <li>New plugin for <code>/etc/modules-load.d/</code> by Robert Andersson, Atlas Copco</li> <li>New <code>name:foo</code> support for services, by Robert Andersson, Atlas Copco</li> <li>New <code>manual:yes</code> support for services, by Robert Andersson, Atlas Copco</li> <li>New <code>log:console</code> support for services, by Robert Andersson, Atlas Copco</li> <li>Support for <code>:ID</code> as a string, by Jonas Johansson, Westermo</li> <li>Support for auto-reload, instead of having to do <code>initctl reload</code>,   when a service configuration has changed.  Disabled by default, but   can be enabled with <code>./configure --enable-auto-reload</code></li> <li>Support for logging security related events, e.g., runlevel change,   star/stop or failure to start services, by Jonas Holmberg, Westermo</li> <li>Mount devtpts with recommended <code>ptxmode=0666</code></li> <li>Mount /run tmpfs with nosuid,nodev,noexec for added security</li> <li>Support for <code>console</code> as alias for <code>@console</code> in tty stanzas</li> <li>Drop <code>--enable-rw-roots</code> configure option, use <code>rw</code> for your <code>/</code>   partition in <code>/etc/fstab</code> instead to trigger remount at boot</li> <li>Drop default tty speed (38400) and use 0 (kernel default) instead</li> <li>Make <code>:ID</code> optional, use NULL/zero internally this allows ...</li> <li>Handle use-cases where multiple services share the same PID filem   and thus the same condition path, e.g. different instances for   different runlevels.  Allow custom condition path with <code>name:foo</code>   syntax, creates conditions w/o a path, and ...</li> <li>Always append <code>:ID</code> qualifier to conditions if set for a service</li> <li>The IPC socket has moved from <code>/run/finit.sock</code> to <code>/run/finit/socket</code>   officially only supported for use by the <code>initctl</code> tool</li> <li>The IPC socket now uses <code>SOCK_SEQPACKET</code> instead of <code>SOCK_STREAM</code>.   Recommend using watchdogd v3.4, or later, which support this</li> <li>Improved support for modern <code>/etc/network/interfaces</code>, which has   include statements.  No more native <code>ifup</code> of individual interfaces,   Finit now calls <code>ifup -a</code>, or <code>ifdown -a</code>, delegating all details to   the operating system.  Also, this is now done in the background, by   popular request</li> </ul>"},{"location":"ChangeLog/#fixes_15","title":"Fixes","text":"<ul> <li>Fix #96: Start udevd as a proper service</li> <li>Ensure we track run commands as well as task/service, once per runlevel</li> <li>Ensure run/tasks also go to stopping state on exit, like services,   otherwise it is unnecessarily hard to restart them</li> <li>Fix missing OS/Finit title bug, adds leading newline before banner</li> <li>Remove \"Failed connecting to watchdog ...\" error message on systems   that do not have a watchdog</li> <li>Fix #100: Early condition handling may not work if <code>/var/run</code> does   not yet exist (symlink to <code>/run</code>).  Added compat layer for access</li> <li>Fix #101: Built-in inetd removed</li> <li>Fix #102: Start built-in watchdogd as a regular service</li> <li>Fix #103: Register multiple getty if <code>@console</code> resolves to &gt;1 TTY,</li> <li>Fix #105: Only remove /etc/nologin when moving from runlevel 0, 1, 6   Fixed by Jonas Johansson, Westermo</li> <li>Fix #109: Support for PID files in sub-directories to <code>/var/run</code></li> <li>Handle rename of PID files, by Robert Andersson, Atlas Copco</li> <li>Fix #110: automatic modprobe of RTC devices, built-in hwclock</li> <li>Fix #120: Redirect <code>stdin</code> to <code>/dev/null</code> for services by default</li> <li>Fix #122: Switch to <code>nanosleep()</code> to achieve \"signal safe\" sleep,   fixed by Jacques de Laval, Westermo</li> <li>Fix #124: Lingering processes in process group when session leader   exits.  E.g., lingering <code>logit</code> processes when parent dies</li> <li>Fix #127: Show all runparts scripts as they start, like rc.local, fixed   by Jacques de Laval, Westermo</li> <li>Fix service name matching, e.g. for condition handling, may match with   wrong service, by Jonas Holmberg, Westermo</li> <li>Run all run-parts scripts using <code>/bin/sh -c foo</code> just like the standard   run-parts tool.  Found by Magnus Malm, Westermo</li> <li>Fix <code>initctl [start | restart]</code>, should behave the same for services   that have crashed.  Found by Mattias Walstr\u00f6m, Westermo</li> <li>Wait for bootstrap phase to complete before cleaning out any bootstrap   processes that have stopped, they may be restarted again</li> <li>Reassert condition when an unmodified run/task/service goes from   WAITING back to RUNNING again after a reconfiguration event.   Found and fixed by Jonas Johansson, Westermo</li> <li>Restore Ctrl-D and Ctrl-U support in built-in getty</li> <li>Remove service condition when service is deleted</li> <li>Fix C++ compilation issues, by Robert Andersson, Atlas Copco</li> <li>Build fixes for uClibc</li> <li>Provide service description for built-in watchdog daemon</li> <li>Fix #138: Handle <code>SIGPWR</code> like <code>SIGSUR2</code>, i.e., power off the system</li> <li>Drop the '%m' GNUism, for compat with older musl libc</li> <li>Fix #139: call <code>tzset()</code> on <code>initctl reload</code> to activate system   timezone changes (for logging)</li> </ul>"},{"location":"ChangeLog/#31-2018-01-23","title":"3.1 - 2018-01-23","text":"<p>Improvements to <code>netlink.so</code> plugin, per-service <code>rlimit</code> support, improved integration with <code>watchdogd</code>, auto-detect TTY console.  Much improved debug, rescue and logging support.  Also, many fixes to both big and small issues, most notably in the condition handling, which no longer is sensitive to time skips.</p> <p>This version requires at least libuEv v2.1.0 and libite v2.0.1</p>"},{"location":"ChangeLog/#changes_16","title":"Changes","text":"<ul> <li>Support for more kernel command line settings:</li> <li>splash, enable boot progress</li> <li>debug, like <code>--debug</code> but also enable kernel debug</li> <li>single, single user mode (no network)</li> <li>rescue, new rescue mode</li> <li>Support for <code>IFF_RUNNING</code> to netlink plugin =&gt; <code>net/IFNAME/running</code></li> <li>Support for restarting <code>initctl</code> API socket on <code>SIGHUP</code></li> <li>Greatly updated <code>initctl status &lt;JOB|NAME&gt;</code> command</li> <li>Support for <code>rlimit</code> per service/run/task/inetd/tty, issue #45</li> <li>Support for setting <code>hard</code> and <code>soft</code> rlimit for a resource at once</li> <li>Support for auto-detecting serial console using Linux SysFS, the new   <code>tty @console</code> eliminates the need to keep track of different console   devices across embedded platforms: <code>/dev/ttyS0</code>, <code>/dev/ttyAMA0</code>, etc.</li> <li>Add TTY <code>nologin</code> option.  Bypasses login and skips immediately to a   root shell.  Useful during board bringup, in developer builds, etc.</li> <li>Support for calling run/tasks on Finit internal HOOK points, issue #18</li> <li>Removed support for long-since deprecated <code>console DEV</code> setting</li> <li>Cosmetic change to login, pressing enter at the <code>Press enter to ...</code>   prompt will now replace that line with the login issue text</li> <li>Calling <code>initctl</code> without any arguments or options now defaults to   show status of all enabled services, and run/task/inetd jobs</li> <li>Cosmetic change to boot messages, removed <code>Loading plugins ...</code>, start   of inetd services, and <code>Loading configuration ...</code>.  No end user knows   what those plugins and configurations are, i.e. internal state+config</li> <li>Change kernel WDT timeout (3 --&gt; 30 sec) for built-in watchdog daemon</li> <li>Advise watchdog dawmon on shutdown and reboot using <code>SIGPWR</code> and then   <code>SIGTERM</code>.  It is recommended the daemon start a timer on the first   signal, in case the shutdown process somehow hangs.</li> <li>Handle <code>/etc/</code> OverlayFS, reload /etc/finit.d/*.conf after <code>mount -a</code></li> <li>initctl: Add support for printing previous runlevel</li> <li>initctl: Support short forms of all commands</li> <li>initctl: Support for <code>initctl touch &lt;CONF&gt;</code> to be used with <code>reload</code></li> <li>initctl: Improved output of <code>initctl show &lt;SVC&gt;</code></li> <li>Support reloading <code>/etc/finit.conf</code>.  The main finit.conf file   previously did not support reloading at runtime, as of v3.1 all   configuration directives supported in <code>/etc/finit.d/*.conf</code> are now   supported in <code>/etc/finit.conf</code></li> <li>Change <code>.conf</code> dependency + reload handling.  Finit no longer relies   on mtime of <code>.conf</code> files, instead an inotify handler tracks file   changes for time insensitive dependency tracking</li> <li>Change condition handling to not rely on mtime but a generation id.</li> <li>New configure script option <code>--enable-redirect</code> to automatically   redirect <code>stdout</code> and <code>stderr</code> of all applications to <code>/dev/null</code></li> <li>New <code>pid</code> sub-option to services when a service does not create a PID   file, or when the PID file has another name.  Issue #95</li> <li>Greatly improved <code>log</code> sub-option to service/run/tasks, selectively   redirect <code>stdout</code> and <code>stderr</code> using the new tool <code>logit</code> to either   syslog or a logfile.  Issue #44</li> <li>Support for automatic log rotation of logfiles created by <code>log</code>   option.  Use <code>configure --disable-logrotate</code> on systems with a   dedicated log rotation service.  Issue #44</li> <li>Support for disabling service/run/task progress with empty <code>--</code>   description.  Note: no description separator gives a default desc.</li> <li>Create <code>/etc/mtab</code> symlink if missing on system (bootmisc plugin)</li> <li>New hook: <code>hook/mount/post</code> runs after <code>mount -a</code> but before the   <code>hook/mount/all</code>, where <code>bootmisc.so</code> runs.  This provides the   possibility of running a second stage mount command before files in   <code>/run</code> and similar are created</li> <li>Skip <code>gdbserver</code> when unleashing the grim reaper at shutdown</li> <li>Distribute and install <code>doc/</code> and <code>contrib/</code> directories</li> </ul>"},{"location":"ChangeLog/#fixes_16","title":"Fixes","text":"<ul> <li>Reset TTY before restarting it.  A program may manipulate the TTY in   various ways before the user logs out, Finit needs to reset the TTY to   a sane state before restarting it.  Issue #84</li> <li>On .conf parse errors, do not default to set TTY speed 38400, reuse   current TTY speed instead</li> <li>Fix run/tasks, must be guaranteed to run once per declared runlevel.   All run/tasks on <code>[S]</code> with a condition <code>&lt;...&gt;</code> failed to run.  Finit   now tracks run/tasks more carefully, waiting for them to finish before   switching to the configured runlevel at boot.  Issue #86</li> <li>Allow inetd services to be registered with a unique ID, e.g. <code>:161</code>,   issue #87.  Found by Westermo</li> <li>inetd: drop UDP packets from blocked interfaces, issue #88</li> <li>Handle obscure inter-plugin dependency issue by calling the netlink   plugin before the pidfile plugin on <code>HOOK_SVC_RECONF</code> events</li> <li>Handle event loop failure modes, issue found by Westermo</li> <li>Handle API socket errors more gracefully, restart socket</li> <li>Do not attempt to load kernel modules more than once at bootstrap</li> <li>Remove reboot symlinks properly on uninstall</li> <li>Fix regression in condition handling, reconf condition must be kept   as a reference point to previous reconfiguration, or bootstrap.</li> <li>Fix nasty race condition with internal service stop, abort kill if the   service has already terminated, otherwise we may do <code>kill(0, SIGKILL)</code></li> <li>Fix reconfiguration issue with (very quick) systems that don't have   highres timers</li> <li>Fix formatting of runlevel string in <code>initctl show</code></li> <li>Allow running <code>initctl</code> with <code>STDOUT</code> redirected</li> <li>Fix regression in <code>initctl start/stop &lt;ID&gt;</code>, using name worked not id</li> <li>Fix error handling in <code>initctl start/stop</code> without any argument</li> <li>Fix issue #81 properly, remove use of SYSV shm IPC completely.  Finit   now use the API socket for all communication between PID 1 and initctl</li> <li>Fix segfault on x86_64 when started with kernel cmdline <code>--debug</code></li> <li>Normalize condition paths on systems with <code>/run</code> instead of <code>/var/run</code></li> </ul>"},{"location":"ChangeLog/#30-2017-10-19","title":"3.0 - 2017-10-19","text":"<p>Major release, support for conditions/dependencies between services, optional built-in watchdog daemon, optional built-in getty, optional built-in standard inetd services like echo server, rdate, etc.</p> <p>Also, native support for Debian/BusyBox <code>/etc/network/interfaces</code>, overhauled new configure based build system, logging to <code>/dev/kmsg</code> before syslogd has started, massively improved support for Linux distributions.</p>"},{"location":"ChangeLog/#changes_17","title":"Changes","text":"<ul> <li>Added basic code of conduct covenant to project</li> <li>Added contribution guidelines document</li> <li>Removed <code>finit.conf</code> option <code>check DEV</code>, replaced entirely by automated   call to <code>fsck</code> for each device listed in <code>/etc/fstab</code></li> <li>Removed deprecated and confusing <code>startx</code> and <code>user</code> settings.  It is   strongly recommended to instead use xdm/gdb/lightdm etc.</li> <li>Add support for <code>initctl log &lt;SVC&gt;</code>, shows last 10 lines from syslog</li> <li>Add <code>initctl cond dump</code> for debugging conditions</li> <li>Ensure plugins always have a default name, file name</li> <li>Reorganization, move all source files to a <code>src/</code> sub-directory</li> <li>Add support for <code>initctl &lt;list|enable|disable&gt; &lt;SVC&gt;</code>, much needed by   distributions.  See doc/distro.md for details</li> <li>Remove <code>UNUSED()</code> macro, mentioned here because it may have been used   by external plugin developers.  Set <code>-Wno-unused-parameter</code> instead</li> <li>New table headings in <code>initctl</code>, using <code>top</code> style inverted text</li> <li>Allow <code>initctl show</code> to use full screen width for service descriptions</li> <li>New <code>HOOK_BANNER</code> for plugins to override the default <code>banner()</code></li> <li>Allow loading TTYs from <code>/etc/finit.d</code></li> <li>Improvements to built-in getty, ignore signals like <code>SIGINT</code>,   <code>SIGHUP</code>, support Ctrl-U to erase to beginning of line</li> <li>Add TTY <code>nowait</code> and <code>noclear</code> options</li> <li> <p>Allow using both built-in getty and external getty:  </p> <pre><code>tty [12345] /dev/ttyAMA0    115200              noclear vt220\ntty [12345] /sbin/getty  -L 115200 /dev/ttyAMA0 vt100\ntty [12345] /sbin/agetty -L ttyAMA0 115200      vt100 nowait\n</code></pre> </li> <li> <p>Silent boot is now the default, use <code>--enable-progress</code> to get the old   Finit style process progress.  I.e., <code>--enable-silent</code> is no more</p> </li> <li>Support for <code>configure --enable-emergency-shell</code>, debug-only mode</li> <li>Support for a fallback shell on console if none of the configured TTYs   can be started, <code>configure --enable-fallback-shell</code></li> <li>All debug messages to console when Finit <code>--debug</code> is enabled</li> <li>Prevent login, by touching <code>/etc/nologin</code>, during runlevel changes</li> <li>A more orderly shutdown.  On reboot/halt/poweroff Finit now properly   goes to runlevel 0/6 to first stop all processes.</li> <li>Perform sync before remounting as read-only, at shutdown</li> <li>Clean up <code>/tmp</code>, <code>/var/run</code>, and <code>/var/lock</code> at boot on systems which   have these directories on persistent storage</li> <li>Call udev triggers at boot, on systems with udev</li> <li>Add missing <code>/var/lock/subsys</code> directory for dbus</li> <li>Add support for <code>poweroff</code></li> <li>Add support for a built-in miniature watchdog daemon</li> <li>Remove GLIBC:isms like <code>__progname</code></li> <li>Manage service states based on user defined conditions</li> <li>Manage dependencies between services, w/ conditions (pidfile plugin)</li> <li>Manage service dependencies on network events (netlink plugin)</li> <li>Support for dynamically reloading Finit configuration at runtime</li> <li>Refactor to use GNU configure and build system</li> <li>New hooks for for detecting lost and started services (lost plugin)</li> <li>External libraries, libuEv and libite, now build requirements</li> <li>Early logging support to <code>/dev/kmsg</code> instead of console</li> <li>Support for redirecting stdout/stderr of services to syslog</li> <li>Support for managing resource limits for Finit and its processes</li> <li>Add optional built-in inetd services: echo server, chargen, etc.</li> <li>Add simple built-in getty</li> <li>Greatly improved accounting support, both UTMP and WTMP fixes+features</li> <li>Improved udev support, on non-embedded systems</li> <li>Improved shutdown and file-system unmount support (Debian)</li> <li>Support SysV init <code>/etc/rc.local</code></li> <li>Inetd protection against UDP looping attacks</li> <li>Support systems with <code>/run</code> instead of <code>/var/run</code> (bootmisc plugin)</li> <li>Adopted BusyBox init signals for halt/reboot/poweroff</li> <li>SysV init compat support for reboot (setenv)</li> <li>Compat support for musl libc</li> <li>Add OpenRC-like support for sysctl.d/*.conf</li> <li>Add support for Debian/BusyBox <code>/etc/network/interfaces</code></li> <li>Add support for running fsck on file systems in <code>/etc/fstab</code></li> <li>Added example configs + HowTos for Debian and Alpine Linux   to support latest releases of both distributions</li> <li>Lots of documentation updates</li> </ul>"},{"location":"ChangeLog/#fixes_17","title":"Fixes","text":"<ul> <li>Fix race-condition at configuration reload due to too low resolution.   Thanks to Mattias Walstr\u00f6m, Westermo</li> <li>Fix to handle long process (PID) dependency chains, re-run reconf   callback until no more applications are in flux.   Thanks to Mattias Walstr\u00f6m, Westermo</li> <li>Clear <code>reconf</code> condition when <code>initctl reload</code> has finished</li> <li>Skip automatic reload of <code>/etc/finit.d/*.conf</code> files when changing   runlevel to halt or reboot</li> <li>Fix issue #54: Allow halt and poweroff commands even if watchdog is enabled</li> <li>Fix issue #56: Check existence of device before trying to start getty</li> <li>Fix issue #60: <code>initctl</code> should display error and return error code   for non-existing services should the operator try to start/stop them.</li> <li>Fix issue #61: Reassert <code>net/*</code> conditions after <code>initctl reload</code></li> <li>Fix issue #64: Skip <code>fsck</code> on already mounted devices</li> <li>Fix issue #66: Log rotate and gzip <code>/var/log/wtmp</code>, created by Finit</li> <li>Fix issue #72: Check <code>ifup</code> exists before trying to bring up networking,   also set <code>$PATH</code> earlier to simplify <code>run()</code> et al -- no longer any need   to use absolute paths for system tools called from Finit.  Thanks to crazy</li> <li>Fix issue #73: Remove double <code>ntohl()</code> in inetd handling, prevents matches.   Thanks to Petrus Hellgren, Westermo</li> <li>Fix issue #76: Reap zombie processes in emergency shell mode</li> <li>Fix issue #80: FTBFS on Arch Linux, missing <code>stdarg.h</code> in <code>helpers.h</code>,   thanks to J\u00f6rg Krause</li> <li>Fix issue #81: Workaround for systems w/o SYSV shm IPC support in kernel</li> <li>Always collect bootstrap-only tasks when done, we will never re-run them.   Also, make sure to never reload bootstrap-only tasks at runtime</li> <li>Remove two second block (!) of Finit when stopping TTYs</li> </ul>"},{"location":"ChangeLog/#24-2015-12-04","title":"2.4 - 2015-12-04","text":"<p>Bug fix release.</p>"},{"location":"ChangeLog/#changes_18","title":"Changes","text":"<ul> <li>Add support for status/show service by <code>name:id</code></li> <li>Enforce terse mode after boot, if verbose mode is disabled</li> <li>Re-enable verbose mode at reboot, if disabled at boot</li> <li>Update section mentioning BusyBox getty</li> <li>Update debugging documentation</li> <li>Allow debug to override terse mode</li> <li>Revert confusing change in service state introduced in v2.3.   As of v2.4 services are listed as \"halted\" and \"stopped\", when   they have been halted due to a runlevel changed or stopped by the   user, respectively.</li> </ul>"},{"location":"ChangeLog/#fixes_18","title":"Fixes","text":"<ul> <li>Fix system freeze at reconfiguration.  Changed services that   all support <code>SIGHUP</code> caused a freeze due to Finit waiting for   them to stop.</li> <li>Make sure to start and/or <code>SIGHUP</code> services after reconfiguration   when there was no services to stop.</li> </ul>"},{"location":"ChangeLog/#23-2015-11-28","title":"2.3 - 2015-11-28","text":"<p>Bug fix release.</p>"},{"location":"ChangeLog/#changes_19","title":"Changes","text":"<ul> <li>Add support for stop/start/restart/reload service by <code>name:id</code></li> <li>Refactor service status listed in <code>initctl show</code>, show actual status</li> </ul>"},{"location":"ChangeLog/#fixes_19","title":"Fixes","text":"<ul> <li>Remove bootstrap-only tasks/services when leaving runlevel 'S'</li> <li>Fix reference counting issue with already stopped and removed services   when the user performs <code>initctl reload</code> to change system configuration</li> <li>Revert semantic change in behavior of <code>initctl restart</code>: users expect   service to be stopped/started, not reloaded with <code>SIGHUP</code> even if the   service supports it</li> <li>Fix <code>NULL</code> pointer dereference causing kernel panic when user calls   <code>initctl reload</code> after change of system configuration</li> <li>Fix column alignment in output of <code>initctl show</code> for services not in   current runlevel</li> </ul>"},{"location":"ChangeLog/#22-2015-11-23","title":"2.2 - 2015-11-23","text":"<p>Lots of fixes to handle static builds, but also fixes for dynamic event handling and reconfiguration at runtime.</p>"},{"location":"ChangeLog/#changes_20","title":"Changes","text":"<ul> <li>Upgrade to libuEv v1.2.4, to handle static builds</li> <li>Upgrade to libite (LITE) v1.2.0, to handle static builds</li> <li>Clarify how to select different plugins with the configure script</li> <li>Improve urandom plugin for embedded systems w/o random seed</li> <li>Add <code>--debug</code> flag to <code>initctl</code></li> <li>The runlevels listed for services in <code>initctl show</code> now highlight the   active runlevel.</li> <li>Clarify in the README and in <code>initctl help</code> that the GW event to   listen for in service declarations is <code>GW:UP</code></li> </ul>"},{"location":"ChangeLog/#fixes_20","title":"Fixes","text":"<ul> <li>Build fixes for <code>configure --disable-inetd</code></li> <li>Fixed issue #14: Improved support for static Finit builds</li> <li>Misc. fixes to silence warnings when building a static Finit</li> <li>Default to register services as <code>SIGHUP</code>'able, regression in v2.0</li> <li>Call <code>HOOK_SVC_RECONF</code> only when all processes have been stopped</li> <li>On reload/reconf we must wait for all services to stop first</li> <li>Only trigger on events that matches the service's specification,   fix by Tobias Waldekranz</li> </ul>"},{"location":"ChangeLog/#21-2015-10-16","title":"2.1 - 2015-10-16","text":""},{"location":"ChangeLog/#changes_21","title":"Changes","text":"<ul> <li>Add hook point for fstab mount failure</li> <li>Set hostname on dynamic reload</li> <li>Upgrade to libite v1.1.1</li> </ul>"},{"location":"ChangeLog/#fixes_21","title":"Fixes","text":"<ul> <li>Fix service callback coredump checks and simplify callback exit</li> <li>Do not use <code>-Os</code> use <code>-O2</code> as default optimization level.  Many cross   compiler toolchains are known to have problems with <code>-Os</code></li> <li>Do not allow build VERSION to be overloaded by an environment variable</li> <li>Fix too small MAX arguments and too few arguments in <code>svc_t</code> for   reading currently running services with <code>initctl show</code></li> <li>Unblock blocked signals after forking off a child</li> </ul>"},{"location":"ChangeLog/#20-2015-09-20","title":"2.0 - 2015-09-20","text":"<p>Support for multiple instances and event based services, as well as the introduction of an <code>initctl</code> tool.</p> <p>Note: Incompatible change to syntax for custom <code>inetd</code> services,   c.f. Finit v1.12.</p>"},{"location":"ChangeLog/#changes_22","title":"Changes","text":"<ul> <li> <p>The most notable change is the support for multiple instances.  A must   have when running multiple DHCP clients, OpenVPN tunnels, or anything   that means using the same command only with different arguments.  Now   simply add a <code>:ID</code> after the <code>service</code> keyword, where <code>ID</code> is a unique   instance number for that service.</p> <pre><code>service :1 [2345] /sbin/httpd -f -h /http -p 80   -- Web server\nservice :2 [2345] /sbin/httpd -f -h /http -p 8080 -- Old web server\n</code></pre> </li> <li> <p>Another noteworthy new feature is support for starting/stopping   services on Netlink events:</p> <pre><code>service :1 [2345] &lt;!IFUP:eth0,GW&gt; /sbin/dropbear -R -F -p 22 -- SSH daemon\n</code></pre> </li> </ul> <p>Here the first instance <code>:1</code> of the SSH daemon is declared to run in   runlevels 2-5, but only if eth0 <code>IFUP:eth0</code> is up and a gateway <code>GW</code>   is set.  When the configuration changes, a new gateway is set, or if   somehow a new <code>IFUP</code> event for eth0 is received, then dropbear is not   SIGHUP'ed, but instead stop-started <code>&lt;!&gt;</code>.  The latter trick applies   to all services, even those that do not define any events. * Support for reloading <code>*.conf</code> files in <code>/etc/finit.d/</code> on SIGHUP.   All <code>task</code>, <code>service</code> and <code>run</code> statements can be used in these .conf   files.  Use the <code>telinit q</code> command, <code>initctl reload</code> or simply send   <code>SIGHUP</code> to PID 1 to reload them.  Finit automatically does reload of   these <code>*.conf</code> files when changing runlevel. * Support for a modern <code>initctl</code> tool which can stop/start/reload and   list status of all system services.  Also, the old client tool used   to change runlevel is now also available as a symlink: <code>telinit</code>.</p> <pre><code>    initctl [-v] &lt;status|stop|start|reload|restart&gt; [JOB]\n</code></pre> <ul> <li> <p>Add concept of \"jobs\".  This is a unique identifier, composed of a   service and instance number, <code>SVC:ID</code></p> <pre><code>initctl &lt;stop|start|reload|restart&gt; JOB\n</code></pre> </li> <li> <p>Support for deny filters in <code>inetd</code> services.</p> <pre><code>inetd service/proto[@iface,!iface,...] &lt;/path/to/cmd | internal[.service]&gt;\n</code></pre> </li> </ul> <p>Internal services on a custom port must use the <code>internal.service</code>   syntax so Finit can properly bind the inetd service to the correct   plugin.  Here follows a few examples:</p> <pre><code>    inetd time/udp                    wait [2345] internal                -- UNIX rdate service\n    inetd time/tcp                  nowait [2345] internal                -- UNIX rdate service\n    inetd 3737/tcp                  nowait [2345] internal.time           -- UNIX rdate service\n    inetd telnet/tcp@*,!eth1,!eth0, nowait [2345] /sbin/telnetd -i -F     -- Telnet service\n    inetd 2323/tcp@eth1,eth2,eth0   nowait [2345] /sbin/telnetd -i -F     -- Telnet service\n    inetd 222/tcp@eth0              nowait [2345] /sbin/dropbear -i -R -F -- SSH service\n    inetd ssh/tcp@*,!eth0           nowait [2345] /sbin/dropbear -i -R -F -- SSH service\n</code></pre> <p>Access to telnet on port <code>2323</code> is only possible from interfaces   <code>eth0</code>, <code>eth1</code> and <code>eth2</code>.  The standard telnet port (<code>23</code>) is   available from all other interfaces, but also <code>eth2</code>.  The <code>*</code>   notation used in the ssh stanza means any interface, however, here   <code>eth0</code> is not allowed.</p> <p>NOTE: This change breaks syntax compatibility with Finit v1.12. * Support for a more user-friendly configure script rather than editing   the top Makefile, or setting environment variables at build time. * Support for building Finit statically, no external libraries.  This   unfortunately means that some plugins cannot be built, at all.   Big thanks goes to James Mills for all help testing this out! * Support for disabling the built-in inetd server with <code>configure</code>. * Support for two new hook points: <code>HOOK_SVC_RECONF</code> and   <code>HOOK_RUNLEVEL_CHANGE</code>.  See the source for the exact location. * The <code>include &lt;FILE&gt;</code> option now needs an absolute path to <code>FILE</code>.</p>"},{"location":"ChangeLog/#fixes_22","title":"Fixes","text":"<ul> <li>Rename <code>patches/</code> to <code>contrib/</code> to simplify integration in 3rd party   build systems.</li> <li>Fix for unwanted zombies ... when receiving SIGCHLD we must reap all   children.  We only receive one signal, but multiple processes may have   exited and need to be collected.</li> </ul>"},{"location":"ChangeLog/#112-2015-03-04","title":"1.12 - 2015-03-04","text":"<p>The inetd release.</p>"},{"location":"ChangeLog/#changes_23","title":"Changes","text":"<ul> <li>Add support for built-in inetd super server -- launch services on   demand.  Supports filtering per interface and custom Inet ports.</li> <li>Upgrade to libuEv v1.1.0 to better handle error conditions.</li> <li>Allow mixed case config directives in <code>finit.conf</code></li> <li>Add support for RFC 868 (rdate) time plugin, start as inetd service.</li> <li>Load plugins before parsing <code>finit.conf</code>, this makes it possible to   extend finit even with configuration commands.  E.g., the <code>time.so</code>   plugin must be loaded for the <code>inetd time/tcp internal</code> service to be   accepted when parsing <code>finit.conf</code>.</li> <li>Slight change in TTY fallback behavior, if no TTY is listed in the   system <code>finit.conf</code> first inspect the <code>console</code> setting and only if   that too is unset fall back to <code>/bin/sh</code></li> <li>When falling back to the <code>console</code> TTY or <code>/bin/sh</code>, finit now marks   this fallback as console.  Should improve usability in some use cases.</li> </ul>"},{"location":"ChangeLog/#fixes_23","title":"Fixes","text":"<ul> <li>Revert \"Use vfork() instead of fork() before exec()\" from v1.11.  It   turned out to not work so well after all.  For instance, launching   TTYs in a background process completely blocked inetd services from   even starting up listening sockets ... proper fork seems to work fine   though.  This is the cause for yanking the 1.11 release, below.</li> <li>Trap segfaults caused by external plugins/callbacks in a sub-process.   This prevents a single programming mistake in by a 3rd party developer   from taking down the entire system.</li> <li>Fix Coverity CID 56281: dlopen() resource leak by storing the pointer.   For the time being we do not support unloading plugins.</li> <li>Set hostname early, so bootstrap processes like syslog can use it.</li> <li>Only restart lost daemons when recovering from a SIGSTOP/norespawn.</li> </ul>"},{"location":"ChangeLog/#111-2015-01-24-yanked","title":"1.11 - 2015-01-24 [YANKED]","text":"<p>The libuEv release.</p> <p>Note: This release has been yanked from distribution due to a   regression in launching background processes and TTY's.  Fixed in   Finit v1.12.</p>"},{"location":"ChangeLog/#changes_24","title":"Changes","text":"<ul> <li>Now using the asynchronous libuEv library for handling all events:   signals, timers and listening to sockets or file descriptors.</li> <li>Rename NEWS.md --&gt; CHANGELOG.md, with symlinks for <code>make install</code></li> <li>Attempt to align with http://keepachangelog.com/ for this file.</li> <li>Travis CI now only invokes Coverity Scan from the 'dev' branch.  This   means that all development, except documentation updates, must go into   that branch.</li> </ul>"},{"location":"ChangeLog/#fixes_24","title":"Fixes","text":"<ul> <li>Fix bug with finit dying when no <code>tty</code> is defined in <code>finit.conf</code>, now   even the fallback shell has control over its TTY, see fix in GIT   commit dea3ae8 for this.</li> </ul>"},{"location":"ChangeLog/#110-2014-11-27","title":"1.10 - 2014-11-27","text":"<p>Major bug fix release.</p>"},{"location":"ChangeLog/#changes_25","title":"Changes","text":"<ul> <li>Project now relies on static code analysis from Coverity, so this   release contains many serious bug fixes.</li> <li>Convert to use Markdown for README, NEWS and TODO.</li> <li>Serious update to README and slight pruning of finished TODO items.</li> </ul>"},{"location":"ChangeLog/#fixes_25","title":"Fixes","text":"<ul> <li>Fix serious file descriptor and memory leaks in the following   functions.  In particular the leaks in <code>run_interactive()</code> are very   serious since that function is called every time a service is started   and/or restarted!  For details, see the GIT log:</li> <li><code>helpers.c:run()</code></li> <li><code>helpers.c:run_interactive()</code></li> <li><code>helpers.c:set_hostname()</code></li> <li><code>helpers.c:procname_kill()</code></li> <li><code>svc.c:svc_start()</code>: Fix swapped arguments to dup2() and add close(fd)   to prevent descriptor leak.</li> <li><code>svc.c:svc_start()</code>: Fix out of bounds write to local stack variable,   wrote off-by-one outside array.</li> <li>Several added checks for return values to <code>mknod()</code>, <code>mkdir()</code>,   <code>remove()</code>, etc.</li> </ul>"},{"location":"ChangeLog/#19-2014-04-21","title":"1.9 - 2014-04-21","text":""},{"location":"ChangeLog/#changes_26","title":"Changes","text":"<ul> <li>Add support for an include directive to <code>.conf</code> files</li> <li>Fallback to <code>/bin/sh</code> if user forgets tty setting</li> <li>Initial support for restarting lost services during <code>norespwan</code></li> </ul>"},{"location":"ChangeLog/#fixes_26","title":"Fixes","text":"<ul> <li>Bug fixes, code cleanup</li> <li>Handle <code>SIGHUP</code> from service callback properly when switching runlevel</li> <li>Misc. major (memleak) and minor fixes and additions to <code>libite/lite.h</code></li> </ul>"},{"location":"ChangeLog/#18-2013-06-07","title":"1.8 - 2013-06-07","text":""},{"location":"ChangeLog/#changes_27","title":"Changes","text":"<ul> <li>Support for runlevels, with a bootstrap runlevel 'S'</li> <li>Support for saving previous and current runlevel to UTMP</li> <li>Support for new <code>finit.conf</code> commands: run, task, and runlevel</li> <li>Support for tty and console commands in <code>finit.conf</code>, like services   but for launching multiple getty logins</li> <li>New tty plugin to monitor TTYs coming and going, like USB TTYs</li> </ul>"},{"location":"ChangeLog/#fixes_27","title":"Fixes","text":"<ul> <li>Bugfixes to libite</li> </ul>"},{"location":"ChangeLog/#17-2012-10-08","title":"1.7 - 2012-10-08","text":""},{"location":"ChangeLog/#changes_28","title":"Changes","text":"<ul> <li>Show <code>__FILE__</code> in <code>_d()</code> debug messages, useful for plugins with   similarly named callbacks. Also, only in debug mode anyway</li> <li>Make sure to cleanup recorded PID when a service is lost.  Required by   service plugins for their callbacks to work.</li> <li>Only clear screen when in verbose mode. Maybe this should be removed   altogether?</li> </ul>"},{"location":"ChangeLog/#fixes_28","title":"Fixes","text":"<ul> <li>Bugfix: Do not <code>free()</code> static string in <code>finit.conf</code> parser</li> </ul>"},{"location":"ChangeLog/#16-2012-10-06","title":"1.6 - 2012-10-06","text":""},{"location":"ChangeLog/#changes_29","title":"Changes","text":"<ul> <li>Skip <code>.</code> and <code>..</code> in plugin loader and display error when failing to   load plugins</li> <li>Support for overriding <code>/etc/finit.d</code> with <code>runparts DIR</code> in   <code>finit.conf</code></li> <li>Revoke support for starting services not starting with a slash.</li> <li>Prevent endless restart of non-existing services in <code>finit.conf</code></li> <li>Support for sysvinit style startstop scripts in <code>/etc/finit.d</code></li> </ul>"},{"location":"ChangeLog/#fixes_29","title":"Fixes","text":"<ul> <li>Minor fix to alsa-utils plugin to silence on non-existing cards</li> </ul>"},{"location":"ChangeLog/#15-2012-10-03","title":"1.5 - 2012-10-03","text":""},{"location":"ChangeLog/#changes_30","title":"Changes","text":"<ul> <li>Use bootmisc plugin to setup standard FHS 2.3 structure in <code>/var</code></li> <li>Added <code>FLOG_WARN()</code> syslog macro, for plugins</li> <li>Add plugin dependency resolver. Checks <code>plugin_t</code> for <code>.depends</code></li> </ul>"},{"location":"ChangeLog/#14-2012-10-02","title":"1.4 - 2012-10-02","text":""},{"location":"ChangeLog/#changes_31","title":"Changes","text":"<ul> <li>Start refactoring helpers.c into a libite.so (-lite).  This means   other user space applications/daemons can make use of the neat toolbox   available in finit</li> <li>Use short-form -s/-w -u to work with BusyBox hwclock as well</li> <li>Use RTLD_GLOBAL flag to tell dynamic loader to load dependent .so   files as well.  Lets other plugins use global symbols.</li> <li>Greatly simplify svc hook for external plugins and cleanup plugin API.</li> <li>And more ... see the GIT log for more details.</li> </ul>"},{"location":"ChangeLog/#fixes_30","title":"Fixes","text":"<ul> <li>Fix I/O plugin watcher and load plugins earlier for a new hook</li> </ul>"},{"location":"ChangeLog/#13-2012-09-28","title":"1.3 - 2012-09-28","text":""},{"location":"ChangeLog/#changes_32","title":"Changes","text":"<ul> <li>Cleanup public plugin API a bit and add new pid/pidfile funcs</li> <li>Add plugin hook to end of service startup</li> <li>Remove finit.h from svc.h, plugins should not need this.</li> <li>Move utility macros etc. to helpers.h</li> <li>Make <code>finit.h</code> daemon internal, only</li> <li>Move defines of FIFO, conf and rcS.d to Makefile =&gt; correct paths</li> <li>Add support for installing required headers in system include dir</li> <li>Better support for distributions and packagers with install-exec,   install-data, and install-dev targets in Makefile.  Useful if you want   to call targets with different <code>$DESTDIR</code>!</li> <li>Makefile fixes for installation, paths encoded wrong</li> <li>Strip binaries + .so files, support for <code>$(CROSS)</code> toolchain strip</li> <li>Default install is now to <code>/sbin/finit</code> and <code>/usr/</code></li> <li>Note change in <code>$PLUGIN_DIR</code> environment variable to <code>$plugindir</code></li> </ul>"},{"location":"ChangeLog/#12-2012-09-27","title":"1.2 - 2012-09-27","text":""},{"location":"ChangeLog/#changes_33","title":"Changes","text":"<ul> <li>Update README with section on building and environment variables</li> </ul>"},{"location":"ChangeLog/#fixes_31","title":"Fixes","text":"<ul> <li>Fix installation paths encoded in finit binary</li> </ul>"},{"location":"ChangeLog/#11-2012-09-27","title":"1.1 - 2012-09-27","text":""},{"location":"ChangeLog/#changes_34","title":"Changes","text":"<ul> <li>Rename signal.[ch]--&gt;sig.[ch] to avoid name clash w/ system headers</li> </ul>"},{"location":"ChangeLog/#fixes_32","title":"Fixes","text":"<ul> <li>Build fixes for ARM eabi/uClibc</li> </ul>"},{"location":"ChangeLog/#10-2012-09-26","title":"1.0 - 2012-09-26","text":""},{"location":"ChangeLog/#changes_35","title":"Changes","text":"<ul> <li>New plugin based system for all odd extensions</li> <li>New service monitor that restarts services if they die</li> <li>New maintainer at GitHub http://github.com/troglobit/finit</li> <li>Add standard LICENSE and AUTHORS files</li> <li>New focus: embedded systems and small headless servers</li> </ul>"},{"location":"ChangeLog/#06-2010-06-14","title":"0.6 - 2010-06-14","text":"<ul> <li>Don't start consolekit manually, dbus starts it (rtp)</li> <li>Unmount all filesystems before rebooting</li> <li>Disable <code>USE_VAR_RUN_RESOLVCONF</code> for Mandriva</li> <li>Unset terminal type in Mandriva before running X</li> <li>Remove extra sleep in finit-alt before calling services.sh (caio)</li> </ul>"},{"location":"ChangeLog/#05-2008-08-21","title":"0.5 - 2008-08-21","text":"<ul> <li>Add option to start dbus and consolekit before the X server</li> <li>finit-alt listens to <code>/dev/initctl</code> to work with <code>reboot(8)</code> (smurfy)</li> <li>Write runlevel to utmp, needed by Printerdrake (Pascal Terjan)</li> <li>Fix ownership of <code>/var/run/utmp</code> (reported by Pascal Terjan)</li> <li>Remove obsolete code to load AGP drivers</li> <li>Conditional build of <code>/etc/resolveconf/run</code> support</li> <li>Add support to <code>/var/run/resolvconf</code> in Mandriva (blino)</li> </ul>"},{"location":"ChangeLog/#04-2008-05-16","title":"0.4 - 2008-05-16","text":"<ul> <li>Default username for finit-alt configurable in Makefile</li> <li>Create loopback device node in finit-alt (for squashfs)</li> <li>Add option to use built-in run-parts instead of <code>/bin/run-parts</code></li> <li>Ignore signal instead of setting to an empty handler (Metalshark)</li> <li>Handle pam_console permissions in finit-alt for Mandriva</li> <li>Add services.sh example and nash-hotplug patch for Mandriva</li> <li>Mount <code>/proc/bus/usb</code> in Mandriva</li> <li>Add runtime debug to finit-alt if finit_debug parameter is specified</li> <li>Read configuration from <code>/etc/finit.conf</code></li> <li>Run getty with openvt on the virtual terminal</li> </ul>"},{"location":"ChangeLog/#03-2008-02-23","title":"0.3 - 2008-02-23","text":"<ul> <li>Change poweroff method to <code>reboot(RB_POWER_OFF)</code> (Metalshark)</li> <li>Remove duplicate <code>unionctl()</code> reimplementation error</li> <li>Fix string termination in path creation</li> <li>Mount <code>/var/lock</code> and <code>/var/run</code> as tmpfs</li> </ul>"},{"location":"ChangeLog/#02-2008-02-19","title":"0.2 - 2008-02-19","text":"<ul> <li>Replace <code>system(\"touch\")</code> with <code>touch()</code> in finit-mod (Metalshark)</li> <li>Disable <code>NO_HCTOSYS</code> by default to match stock Eeepc kernel</li> <li>Drop <code>system(\"rm -f\")</code> to clean <code>/tmp</code>, its a fresh mounted tmpfs</li> <li>Write ACPI sleep state to <code>/sys/power/state</code> instead of   <code>/proc/acpi/sleep</code> (Metalshark)</li> <li>Use direct calls to set loopback instead of <code>system(\"ifconfig\")</code></li> <li>Replace <code>system(\"cat\")</code> and <code>system(\"dd\")</code> with C implementation</li> <li>Moved finit-mod and finit-alt helpers to <code>helpers.c</code></li> <li>Replace <code>system(\"echo;cat\")</code> to draw shutdown splash with C calls</li> </ul>"},{"location":"ChangeLog/#01-2008-02-14","title":"0.1 - 2008-02-14","text":"<ul> <li>Initial release</li> </ul>"},{"location":"build/","title":"Building Finit","text":"<p>Finit comes with a traditional configure script to control features and optional plugins to enable.  It depends on two external libraries:</p> <ul> <li>libuEv, the event loop</li> <li>libite (-lite), much needed frog DNA</li> </ul> <p>Important</p> <p>Most free/open source software packages that use <code>configure</code> default to install to <code>/usr/local</code>.  However, some Linux distributions do no longer search that path for installed software, e.g. Fedora and Alpine Linux.  To get finit's configure script to find its dependencies you have to help the <code>pkg-config</code> tool a bit if you do not change the default prefix path:</p> <pre><code>PKG_CONFIG_LIBDIR=/usr/local/lib/pkgconfig ./configure\n</code></pre> <p>The configure script checks for all dependencies, including the correct version of the above mentioned libraries.  Currently required versions:</p> <ul> <li>libite v2.2.0, or later</li> <li>libuEv v2.2.0, or later</li> </ul>"},{"location":"build/#configure","title":"Configure","text":"<p>Below are a few of the main switches to configure:</p> <ul> <li> <p><code>--prefix=..</code>: Usually you want to set this to <code>/usr</code>, default is the GNU   default: <code>/usr/local</code></p> </li> <li> <p><code>--exec-prefix=..</code>: This you want to set to the empty string, or <code>/</code>, to   ensure the programs <code>finit</code> and <code>initctl</code> are installed to the proper   locations.  Linux expects an \"init\" in <code>/sbin</code>, default: <code>--prefix</code></p> </li> <li> <p><code>--sysconfdir=..</code>: follows <code>--prefix</code>, you likely want it to be <code>/etc</code></p> </li> <li> <p><code>--localstatedir=..</code>: follows <code>--prefix</code>, you likely want <code>/var</code></p> </li> <li> <p><code>--enable-static</code>: Build Finit statically.  The plugins will be   built-ins (.o files) and all external libraries, except the C library   will be linked statically.</p> </li> <li> <p><code>--enable-kernel-cmdline</code>: Enable Finit pre-4.1 parsing of init args from   <code>/proc/cmdline</code>, this is not recommended since Finit may be running as the   init for container apps that can see the host's <code>/proc</code> filesystem</p> </li> <li> <p><code>--enable-alsa-utils-plugin</code>: Enable the optional <code>alsa-utils.so</code> sound plugin.</p> </li> <li> <p><code>--enable-dbus-plugin</code>: Enable the optional D-Bus <code>dbus.so</code> plugin.</p> </li> <li> <p><code>--enable-resolvconf-plugin</code>: Enable the <code>resolvconf.so</code> optional plugin.</p> </li> <li> <p><code>--enable-x11-common-plugin</code>: Enable the optional X Window <code>x11-common.so</code> plugin.</p> </li> <li> <p><code>--with-sulogin</code>: Enable bundled <code>sulogin</code> program.  Default is to use the   system <code>sulogin(8)</code>.  The sulogin shipped with Finit allows password-less   login if the <code>root</code> user is disabled or has no password at all.</p> </li> </ul> <p>For more configure flags, see ./configure --help</p> <p>Note</p> <p>The configure script is not available in the GIT sources.  It is however included in (officially supported) released tarballs.  The idea is that you should not need GNU autotools to build, only the above mentioned dependencies, a POSIX shell, a C compiler and make. Any contributing to Finit can generate it from <code>configure.ac</code> using the <code>autogen.sh</code> script.</p>"},{"location":"build/#example","title":"Example","text":"<p>First, unpack the archive:</p> <pre><code>$ tar xf finit-4.3.tar.gz\n$ cd finit-4.3/\n</code></pre> <p>Then configure, build and install:</p> <pre><code>$ ./configure --prefix=/usr                 --exec-prefix=         \\\n              --sysconfdir=/etc             --localstatedir=/var   \\\n              --with-keventd                --with-watchdog\n$ make\n.\n.\n.\n$ DESTDIR=/tmp/finit make install\n</code></pre> <p>In this example the finit-4.3.tar.gz archive is unpacked to the user's home directory, configured, built and installed to a temporary staging directory.  The environment variable <code>DESTDIR</code> controls the destination directory when installing, very useful for building binary standalone packages.</p> <p>Finit 4.1 and later can detect if it runs on an embedded system, or a system that use BusyBox tools instead of udev &amp; C:o.  On such systems <code>mdev</code> instead of <code>udev</code> is used.  However, remember to also change the Linux config to:</p> <pre><code>CONFIG_UEVENT_HELPER_PATH=\"/sbin/mdev\"\n</code></pre> <p>Tip</p> <p>If you run into problems starting Finit, take a look at <code>finit.c</code>. One of the most common problems is a custom Linux kernel build that lack <code>CONFIG_DEVTMPFS</code>.  Another is too much cruft in the system <code>/etc/fstab</code>.</p>"},{"location":"build/#running","title":"Running","text":"<p>Having successfully built Finit it is now be time to take it for a test drive.  The <code>make install</code> attempts to set up finit as the system system init, <code>/sbin/init</code>, but this is usually a symlink pointing to the current init.</p> <p>So either change the symlink, or change your boot loader (GRUB, LOADLIN, LILO, U-Boot/Barebox or RedBoot) configuration to append the following to the kernel command line:</p> <pre><code>append=\"init=/sbin/finit\"\n</code></pre> <p>Remember to also set up an initial <code>/etc/finit.conf</code> before rebooting!</p>"},{"location":"build/#recovery","title":"Recovery","text":"<p>To rescue a system with Finit, append the following to the kernel command line:</p> <pre><code>append=\"init=/sbin/finit rescue\"\n</code></pre> <p>This tells Finit to start in a very limited recovery mode, no services are loaded, no filesystems are mounted or checked, and no networking is enabled.  The default Finit rescue mode configuration is installed into <code>/lib/finit/rescue.conf</code>, which can be safely removed or changed.</p> <p>By default the a root shell, without login, is started.</p> <p>Important</p> <p>In rescue mode <code>initctl</code> will not work, the same goes for <code>reboot</code>, <code>shutdown</code>, and <code>poweroff</code> commands, provided they are the Finit versions of these commands.  Use the <code>-f</code> flag to force the action.</p>"},{"location":"build/#debugging","title":"Debugging","text":"<p>Edit, or append to, the kernel command line: remove <code>quiet</code> to enable kernel messages and add <code>finit.debug</code> to enable Finit debug messages.</p> <pre><code>append=\"init=/sbin/finit -- finit.debug\"\n</code></pre> <p>Notice the <code>--</code> separator.</p> <p>To debug startup issues, in particular issues with getty/login, add the following to your Finit .conf file:</p> <pre><code>tty [12345789] notty noclear\n</code></pre> <p>The <code>notty</code> option ensures reusing the stdin/stdout set up by the kernel.  Remember, this is only for debugging and would leave your production system potentially wide open.</p> <p>There is also a rescue shell available, in case Finit crashes and the kernel usually reboots: <code>configure --enable-emergency-shell</code>.  However, the behavior of Finit is severely limited when this is enabled, so use it only for debugging start up issues when Finit crashes.</p> <p>Caution</p> <p>None of these options should be enabled on production systems since they can potentially give a user root access.</p>"},{"location":"cmdline/","title":"Tips &amp; Tricks with the kernel cmdline","text":"<p>This document summarizes the different boot parameters that can be passed on the Linux kernel command line.  Not limited to Finit.</p> <p>Important</p> <p>Remember to use <code>--</code> to separate kernel parameters from parameters to init.  E.g., <code>init=/sbin/finit -- finit.debug rescue</code></p> <p>The <code>bool</code> setting is one of <code>on, off, true false, 1, 0</code>.</p> <ul> <li> <p><code>debug</code>: Enable kernel debug.  Debug messages are printed to the    console until Finit starts up, unless <code>loglevel=7</code> (below) is used.</p> </li> <li> <p><code>fsck.mode=&lt;auto,force,skip&gt;</code>, default: <code>auto</code>, unless built with   <code>configure --enable-fastboot</code>, in which case the default is <code>skip</code></p> </li> <li> <p><code>fsck.repair=&lt;preen,yes,no&gt;</code>, default: <code>preen</code>, unless built with   <code>configure --enable-fsckfix</code>, in which case the default is <code>yes</code>.   This configure option also sets <code>fsck.mode=force</code>, unless fastboot   is selected at the same time.  I.e., the <code>--enable-fastboot</code> build   option overrides the <code>fsck.mode</code> default value.</p> </li> <li> <p><code>finit.cond=foo[,bar[,baz]]</code>: set <code>&lt;boot/foo&gt;</code> condition, optionally   multiple conditions can be set using the same option, separated with a   comma.  Alternatively, multiple <code>foo.cond=arg</code> can be given.  Each will   result in a <code>&lt;boot/arg&gt;</code> condition being set to control the rest of the   system bootstrap.</p> </li> </ul> <p>Very useful for selecting different boot modes, e.g. manufacturing test,   firmware upgrade, or rescue mode.</p> <p>Note</p> <p><code>&lt;boot/...&gt;</code> conditions cannot be cleared with <code>initctl</code>!</p> <ul> <li><code>finit.config=/path/to/alternative/finit.conf</code>: override the   compile-time bootstrap config file, default:<pre><code>./configure --with-config=/etc/finit.conf\n</code></pre> </li> </ul> <p>Useful when starting up in various rescue mode, factory, or    production test setups.  Use the top-level configuration file    directive <code>rcsd /path/to/finit.d</code> to override the default rcS.d    directory.</p> <ul> <li> <p><code>finit.debug[=bool]</code>: Enable finit debug.  This is operated     independently of the kernel <code>debug</code> setting.  New as of Finit v4.</p> </li> <li> <p><code>finit.fstab=&lt;/path/to/etc/fstab.alternative&gt;</code>: Tell Finit to use an   alternate <code>fstab</code> to mount the file system from.  Remember, this file   must be on the <code>root=...</code> file system provided to Finit from the   kernel.  By default the built-in fstab is used, which itself defaults   to <code>/etc/fstab</code>, but can be changed at build time with:</p> <pre><code>./configure --with-fstab=/path/to/fstab\n</code></pre> </li> </ul> <p>It is even possible to disable a built-in default using:</p> <pre><code>    ./configure --without-fstab\n</code></pre> <p>Making <code>finit.fstab=/path/to/fstab</code> a mandatory command line option.   Note, if the command line fstab is missing, Finit falls back to the   built-in fstab, and if both are missing, the system treats this as a   bad <code>fsck</code> and thus calls <code>sulogin</code>.  If, in turn, <code>sulogin</code> is not   available on the system, Finit calls reboot, which is also what will   happen when a user exits from <code>sulogin</code>.</p> <ul> <li> <p><code>finit.status[=bool]</code>: Control finit boot progress, including banner.   (Used to be <code>finit.show_status</code>, which works but is deprecated.)</p> </li> <li> <p><code>finit.status_style=&lt;classic,modern&gt;</code>: Set Finit boot progress style,   when enabled.</p> </li> <li> <p><code>init=/bin/sh</code>: Bypass system default init and tell kernel to start a     shell.  Note, this shell is very limited and does not support     signals and has no job control.  Recommend using, and modifying,     <code>rescue</code> mode instead.</p> </li> <li> <p><code>loglevel=&lt;0-7&gt;</code>, sets the kernel's log level, which is more granular   than <code>debug</code>.  Also, when <code>loglevel=7</code>, Finit will not disable   kernel logs to the console.  This is very useful when debugging the   kernel at system bring-up.  Since <code>loglevel=7</code> is the same as <code>debug</code>   this means you have to use <code>quiet</code> for a quiet boot, until sysklogd   takes over logging of kernel events.</p> </li> <li> <p><code>panic=SEC</code>: By default the kernel does not reboot after a kernel     panic.  This setting will cause a kernel reboot after SEC seconds.</p> </li> <li> <p><code>quiet</code>: Suppress kernel logging to console, except for warnings and   errors.  Also, see <code>loglevel</code> and <code>quiet</code> above.</p> </li> <li> <p><code>rescue</code>: Start rescue/maintenance mode.  If your system     comes with the bundled <code>sulogin</code> program (Finit, or from util-linux,     or Busybox), you will be given a root login to a maintenance shell.     However, if <code>sulogin</code> is missing, the file <code>/lib/finit/rescue.conf</code>     is read and the system booted in a limited fallback mode.</p> <p>This option can be disabled with <code>configure --without-rescue</code></p> <p>Note: in this mode <code>initctl</code> will not work.  Correct the problem and use <code>reboot -f</code> to force reboot.</p> </li> <li> <p><code>single</code>, or <code>S</code>: Overrides the configured runlevel (default: 2) to go     to after bootstrap by forcing it to runlevel 1, this is also known     as single user mode.  Useful to debug startup problems.  All services     and TTYs in <code>[1]</code> will be started, so a <code>tty [1] @console nologin</code>     configuration presents you with a root console without login.</p> </li> <li> <p><code>1-9</code>, except <code>6</code>: override the configured <code>runlevel</code>.  Like the <code>S</code>    and <code>rescue</code>, giving a single number on the kernel command line tells    Finit to ignore any <code>runlevel</code> in <code>/etc/finit.conf</code> as well as the    configure fallback <code>--with-runlevel=N</code> setting.  Remember, <code>6</code> is the    reboot runlevel and is not permitted.  Any other values are ignored.</p> </li> </ul> <p>For more on kernel boot parameters, see the man page bootparam(7).</p>"},{"location":"commands/","title":"Rebooting &amp; Halting","text":"<p>Traditionally, rebooting and halting a UNIX system is done by switching to the corresponding runlevel (0 or 6).  Over time this has changed and Finit comes with its own tooling providing: <code>shutdown</code>, <code>reboot</code>, <code>poweroff</code>, and <code>suspend</code>.  These commands are also available from the <code>initctl</code> tool.</p> <p>For compatibility reasons Finit listens to the same set of signals as BusyBox init.  This is not 100% compatible with SysV init, but clearly the more common combination for Finit.  For more details, see the Signal section.</p>"},{"location":"conditions/","title":"Conditions","text":"<p>Conditions were added to Finit in v3 with the intention of providing a mechanism for common synchronization problems.  For example:</p> <ul> <li>\"wait for service A to start before starting service B\", or</li> <li>\"wait for basic network access to be available\"</li> </ul> <p>Conditions are similar in syntax to declaring runlevels per service. They are specified within angle brackets <code>&lt;&gt;</code> and can be applied to any of the <code>service</code>, <code>task</code>, or <code>run</code> stanza.  Multiple conditions may be specified separated by comma.  Multiple conditions are logically AND'ed during evaluation, i.e. all conditions must be satisfied in order for a service to run.</p> <p>A special syntax, using a leading <code>!</code> in run/task/service conditions, denote if a:</p> <ul> <li>service does not support <code>SIGHUP</code></li> <li>run/task should not block runlevel changes (i.e., bootstrap)</li> </ul> <p>Finit guarantees by default that all run/tasks run (at least) once per runlevel.  For most tasks this is a good default, for example checking SSH host keys or loading keymap.  However, for conditions that are unlikely to happen it is not. (See example below.)</p>"},{"location":"conditions/#example","title":"Example","text":"<pre><code>service [2345] &lt;pid/setupd,pid/zebra&gt; /sbin/netd -- Network monitor\n</code></pre> <p>In this example the Network monitor daemon <code>netd</code> is not started until both the <code>pid/setupd</code> and <code>pid/zebra</code> conditions are satisfied.  A <code>pid/</code> condition is satisfied by the corresponding service's PID file being created, i.e., the service's default readiness notification.</p> <p>Important</p> <p>Conditions also stop services when a condition is no longer asserted. I.e., if the <code>zebra</code> process above stops or restarts, <code>netd</code> will also stop or restart.</p> <p>Another example is <code>dropbear</code>, it does not support <code>SIGHUP</code>, but we can also see optional sourcing of arguments from an environment file:</p> <pre><code>service [2345789] &lt;!&gt; env:-/etc/default/dropbear dropbear -F -R $DROPBEAR_ARGS -- Dropbear SSH daemon\n</code></pre> <p>Finally, the weird \"block runlevel changes\" example.  Here we see what happens when Finit receives <code>SIGPWR</code>, sent from a power daemon like powstatd(8).  A condition is asserted and a user can set up their own task to act on it.  We do not want this task to block Finit from moving to the next runlevel after bootstrap, so we set <code>&lt;!&gt;</code>:</p> <pre><code>task [S0123456789] &lt;!sys/pwr/fail&gt; name:pwrfail initctl poweroff -- Power failure, shutting down\n</code></pre>"},{"location":"conditions/#triggering","title":"Triggering","text":"<p>Conditions are mainly triggered (asserted) by built-in plugins, e.g.,</p> <ul> <li><code>netlink.so</code>: provides <code>&lt;net/...&gt;</code></li> <li><code>pidfile.so</code>: provides <code>&lt;pid/...&gt;</code></li> <li>Cmdline <code>finit.cond=arg</code>: provides <code>&lt;boot/arg&gt;</code></li> </ul> <p>See below for built-in conditions.  Finit also supports user-defined conditions, sometimes referred to as static or one-shot conditions. They live in the <code>&lt;usr/...&gt;</code> namespace and are constrained to a flat hierarchy without any sub-directories, unlike the pidfile plugin, for instance.</p> <p>User-defined conditions are controlled using the <code>initctl cond set</code> and <code>initctl cond clear</code> commands:</p> <pre><code>initctl cond set foo\ninitctl cond clear foo\n</code></pre> <p>The purpose of user-defined conditions is to be able to start or stop services, or run/task jobs, on external site-dependent stimuli.</p> <p>Example:</p> <pre><code>service [2345] &lt;usr/foo&gt; alarm --arg foo -- Foo alarm\n</code></pre> <p>For convenience, prefixing with <code>usr/</code> is allowed, but any other slashes or period characters are disallowed.  E.g., to trigger the <code>Foo alarm</code>, the same as above, can also be achieved like this:</p> <pre><code>initctl cond set usr/foo\ninitctl cond clear usr/foo\n</code></pre> <p>Conditions retain their current state until the next reconfiguration or runlevel change.  At that point all set conditions transition into the <code>flux</code> state, meaning the condition's state is unknown.  (For more info on this, see Internals.)  Thus, after a reconfiguration it is up to the \"owner\" of the condition to convey the new (or possibly unchanged) state of it.</p> <p>Static (one-shot) conditions, like <code>usr/</code>, never enter the <code>flux</code> state.</p> <p>Important</p> <p>For <code>pid/</code> conditions it is expected that the service reassert, i.e., \"touch\" or recreate, their PID file on <code>SIGHUP</code>.  This can be done by calling <code>utimensat()</code> on the PID file.  Provided, of course, that the service supports reloading on <code>SIGHUP</code>, otherwise it will be restarted by Finit when they instead exit on the signal.  For such services, use <code>&lt;!&gt;</code> to tell Finit the service does not support <code>SIGHUP</code>.</p>"},{"location":"conditions/#built-in-conditions","title":"Built-in Conditions","text":"<p>Finit comes with a set of plugins for conditions:</p> <ul> <li><code>devmon</code> (built-in)</li> <li><code>netlink</code></li> <li><code>pidfile</code></li> <li><code>sys</code></li> <li><code>usr</code></li> </ul> <p>The <code>devmon</code> (built-in) plugin monitors <code>/dev</code> and <code>/dev/dir</code> for device nodes being created and removed.  It is active only when a run, task, or service has declared a <code>&lt;dev/foo&gt;</code> or <code>&lt;dev/dir/bar&gt;</code> condition.</p> <p>The <code>pidfile</code> plugin (recursively) watches <code>/run/</code> (recursively) for PID files created by the monitored services, and sets a corresponding condition in the <code>pid/</code> namespace.</p> <p>Similarly, the <code>netlink</code> plugin provides basic conditions for when an interface is brought up/down and when a default route (gateway) is set, in the <code>net/</code> namespace.</p> <p>The <code>sys</code> and <code>usr</code> plugins monitor are passive condition monitors where the action is provided by <code>keventd</code>, signal handlers, and in the case of <code>usr</code>, the end-user via the <code>initctl</code> tool.</p> <p>Additionally, the various states of a run/task/sysv/service can also be used as conditions, the image above shows the state names.  The syntax for a <code>service</code> type process: <code>&lt;service/foo/STATE&gt;</code>.  The other types, in particular run/task/sysv, there are the additional states <code>success</code> and <code>failure</code>.</p> <p>With the example listed above, finit does not start the <code>/sbin/netd</code> daemon until <code>setupd</code> and <code>zebra</code> has started and created their PID files.  Which they do when they have completed their initial set up and are ready to receive signals.</p> <p>Finit expects monitored services to touch their PID files, i.e. update the mtime, when they reload their configuration files after a <code>SIGHUP</code>. Some services do not support <code>SIGHUP</code> and are instead restarted, which is a crude but effective way to have the PID file touched (re-created).</p> <p>Built-in conditions:</p> <ul> <li><code>pid/&lt;SERVICE&gt;</code></li> <li><code>net/route/default</code></li> <li><code>net/&lt;IFNAME&gt;/exist</code></li> <li><code>net/&lt;IFNAME&gt;/up</code></li> <li><code>net/&lt;IFNAME&gt;/running</code></li> <li><code>service/&lt;NAME[:ID]&gt;/&lt;STATE&gt;</code></li> <li><code>{run, task, sysv}/&lt;NAME[:ID]&gt;/{&lt;STATE&gt;, success, failure}</code></li> <li><code>sys/pwr/ac</code></li> <li><code>sys/pwr/fail</code></li> <li><code>sys/key/ctrlaltdel</code></li> <li><code>usr/foo</code></li> <li><code>boot/arg</code></li> <li><code>dev/node</code> and <code>dev/dir/node</code></li> </ul> <p>Note</p> <p>Here, <code>up</code> means administratively up, the interface flag <code>IFF_UP</code>. <code>running</code> is the <code>IFF_RUNNING</code> flag, meaning operatively up.  The difference is that <code>running</code> tells if the NIC has link.</p>"},{"location":"conditions/#composition","title":"Composition","text":"<p>The <code>pid/</code> conditions are generated by the Finit <code>pidfile.so</code> plugin and composed from a service's <code>name:</code> and <code>:id</code>.  By default the basename of the daemon and the empty string.</p> service condition /sbin/foo pid/foo /sbin/bar -p /run/baz.pid pid/bar name:lxc :foo lxc-start -n foo -p /run/lxc/foo.pid pid/lxc:foo /usr/bin/dbus-daemon pid/dbus-daemon :222 dropbear -p 222 pid/dropbear:222 <p>The condition is asserted when <code>pidfile.so</code> receives an inotify event for a file matching <code>/run/*.pid</code>, <code>/run/**/*.pid</code>, or <code>/run/**/pid</code>, which contains the PID of the service Finit has started.</p> <p>When Finit configuration files are changed and the <code>initctl reload</code> command is called, it is expected of services to touch their PID files for Finit to reassert their conditions.</p> <p>Daemons that don't create PID files, or fail to touch them on reload, can be worked around by using the <code>pid:/path/to/file.pid</code> syntax in the service stanza for the daemon.  It is far from optimal since any synchronization of depending services may fail due to the daemon not having reinitialized/created their IPC sockets, or similar.</p> <p>Note</p> <p>In versions of Finit prior to v4, the PID conditions were called 'svc' conditions, and they were far more complex.</p>"},{"location":"conditions/#debugging","title":"Debugging","text":"<p>If a service is not being started as it should, the problem might be that one of its conditions is not in the expected state.  Use the command <code>initctl status</code> to inspect service status.  Services in the <code>waiting</code> state are pending a condition.</p> <p>In that situation, running <code>initctl cond show</code> reveals which of the conditions that are not satisfied.  Listed as <code>off</code> below.</p> <p>Example:</p> <pre><code>~ # initctl cond show\nPID     IDENT         STATUS  CONDITION (+ ON, ~ FLUX, - OFF)\n=======================================================================\n1419    /sbin/netd    on      &lt;+pid/setupd,+pid/zebra&gt;\n0       /sbin/udhcpc  off     &lt;-net/vlan1/exist&gt;\n</code></pre> <p>Here we can see that <code>netd</code> is allowed to run since both its conditions are in the <code>on</code> state, as indicated by the <code>+</code>-prefix.  <code>udhcpc</code> however is not allowed to run since <code>net/vlan1/exist</code> condition is not satisfied. As indicated by the <code>-</code>-prefix.</p> <p>To fake interface <code>vlan1</code> suddenly appearing, and test what happens to <code>udhcpc</code> we can enable debug mode and assert the condition, like this:</p> <pre><code>~ # initctl debug\n~ # mkdir -p /var/run/finit/cond/net/vlan1\n~ # cp /var/run/finit/cond /var/run/finit/cond/net/vlan1/exist\n</code></pre> <p>Then watch the console for the debug messages and then check the output from <code>initctl cond show</code> again.  The client will likely have failed to start, but at least the condition is now satisfied.</p> <p>There is also the <code>initctl cond dump</code> command, which dumps all known conditions, their current status, and their origin.</p>"},{"location":"conditions/#internals","title":"Internals","text":"<p>As shown previously, conditions are implemented as simple files in the file system, in the <code>/var/run/finit/cond/</code> sub-directory.  The files are created, updated, and removed by condition plugins.  To debug them, see the previous section.</p> <p>A condition is always in one of three states:</p> <ul> <li><code>on</code> (+): The condition is asserted.</li> <li><code>off</code> (-): The condition is deasserted.</li> <li><code>flux</code> (~): The conditions state is unknown.</li> </ul> <p>All conditions that have not explicitly been set are interpreted as being in the <code>off</code> state.</p> <p></p> <p>When a reconfiguration is requested, Finit transitions all conditions to the <code>flux</code> state.  As a result, services that depend on a condition are sent <code>SIGSTOP</code>.  Once the new state of the condition is asserted, the service receives <code>SIGCONT</code>.  If the condition is no longer satisfied the service will then be stopped, otherwise no further action is taken.</p> <p>This STOP/CONT handling minimizes the number of unnecessary service restarts that would otherwise occur because a depending service was sent <code>SIGHUP</code> for example.</p> <p>Therefore, any plugin that supplies Finit with conditions must ensure that their state is updated after each reconfiguration.  This can be done by binding to the <code>HOOK_SVC_RECONF</code> hook.  For an example of how to do this, see <code>plugins/pidfile.c</code>.</p>"},{"location":"distro/","title":"Distro Recommendations","text":"<p>By default Finit uses the following directories for configuration files:</p> <pre><code>    /etc/\n      |-- finit.d/              -- Regular (enabled) services\n      |    |-- lighttpd.conf\n      |     `- *.conf\n      |-- finit.conf            -- Bootstrap tasks and services\n      :\n</code></pre> <p>To enable a service one simply drops a small configuration file in the <code>/etc/finit.d/</code> directory.  This practice works with systems that keep disabled services elsewhere, or generates them as needed from some other tool.</p> <p>Distributions, however, may want a clearer separation of enabled and available (installed but not enabled) services.  They may even want to customize the directories used, for brand labeling or uniformity.</p> <p>To that end Finit allows for a sub-directory <code>/etc/finit.d/available/</code> where installed but disabled services can reside.  Adding a symlink to a configuration in this sub-directory enables the service, but it will not be started.</p> <p>To change the default configuration directory and configuration file names the Finit <code>configure</code> script offers the following two options at build time:</p> <pre><code>./configure --with-rcsd=/etc/init.d --with-config=/etc/init.d/init.conf\n</code></pre> <p>Important</p> <p>Remember <code>--prefix</code> et al as well, the default is likely not what you want.  See the build docs for details.</p> <p>The resulting directory structure is depicted below.  Please notice how <code>/etc/finit.conf</code> now resides in the same sub-directory as a non-symlink <code>/etc/init.d/init.conf</code>:</p> <pre><code>    /etc/\n      |-- init.d/\n      |    |-- available/      -- Regular (disabled) services\n      |    |    |-- httpd.conf\n      |    |    |-- ntpd.conf\n      |    |    `-- sshd.conf\n      |    |-- sshd.conf       -- Symlink to available/sshd.conf\n      |     `- init.conf       -- Bootstrap tasks and services\n      :\n</code></pre> <p>To facilitate the task of managing configurations, be it a service, task, run, or other stanza, the <code>initctl</code> tool has a a few built-in commands:</p> <pre><code>   list              List all .conf in /etc/finit.d/\n   enable   &lt;CONF&gt;   Enable   .conf in /etc/finit.d/available/\n   disable  &lt;CONF&gt;   Disable  .conf in /etc/finit.d/[enabled/]\n   reload            Reload  *.conf in /etc/finit.d/ (activates changes)\n</code></pre> <p>To enable a service like <code>sshd.conf</code>, above, use</p> <pre><code>initctl enable sshd\n</code></pre> <p>The <code>.conf</code> suffix is not needed, <code>initctl</code> adds it implicitly if it is missing.  The <code>disable</code> command works in a similar fashion.</p> <p>Note, however, that <code>initctl</code> only operates on symlinks and it always requires the <code>available/</code> sub-directory.  Any non-symlink in the parent directory, here <code>/etc/init.d/</code>, will be considered a system override by <code>initctl</code>.</p>"},{"location":"example/","title":"Configuration Example","text":"<p>This example <code>/etc/finit.conf</code> can also be split up in multiple <code>.conf</code> files in <code>/etc/finit.d</code>.  Available, but not yet enabled, services can be placed in <code>/etc/finit.d/available</code> and enabled by an operator using the initctl tool.</p> <p>See the contrib/ directory on GitHub for examples, or take a peek at systems using Finit, like Infix OS and myLinux.</p> <p>Tip</p> <p>As of Finit v4.4, <code>.conf</code> lines can be broken up using the standard UNIX continuation character (<code>\\</code>), trailing comments are also supported.  The latter means you must escape any hashes used in directives and descriptions (<code>\\#</code>).  For more on this and examples, see the finit.conf(5) manual or the Configuration section.</p> <pre><code># Fallback if /etc/hostname is missing\nhost default\n\n# Runlevel to start after bootstrap, 'S', default: 2\n#runlevel 2\n\n# Support for setting global environment variables, using foo=bar syntax\n# be careful though with variables like PATH, SHELL, LOGNAME, etc.\n#PATH=/usr/bin:/bin:/usr/sbin:/sbin\n\n# Max file size for each log file: 100 kiB, rotate max 4 copies:\n# log =&gt; log.1 =&gt; log.2.gz =&gt; log.3.gz =&gt; log.4.gz\nlog size=100k count=4\n\n# Services to be monitored and respawned as needed\nservice [S12345] env:-/etc/conf.d/watchdog watchdog $WATCHDOG_OPTS $WATCHDOG_DEV -- System watchdog daemon\nservice [S12345] env:-/etc/conf.d/syslog syslogd -n $SYSLOGD_OPTS          -- System log daemon\nservice [S12345] &lt;pid/syslogd&gt; env:-/etc/conf.d/klogd klogd -n $KLOGD_OPTS -- Kernel log daemon\nservice   [2345] env:-/etc/conf.d/lldpd lldpd -d $LLDPD_OPTS               -- LLDP daemon (IEEE 802.1ab)\n\n# The BusyBox ntpd does not use syslog when running in the foreground\n# So we use this trick to redirect stdout/stderr to a log file.  The\n# log file is rotated with the above settings.  The condition declares\n# a dependency on a system default route (gateway) to be set.  A single\n# &lt;!&gt; at the beginning means ntpd does not respect SIGHUP for restart.\nservice [2345] log:/var/log/ntpd.log &lt;!net/route/default&gt; ntpd -n -l -I eth0 -- NTP daemon\n\n# For multiple instances of the same service, add :ID somewhere between\n# the service/run/task keyword and the command.\nservice :80   [2345] merecat -n -p 80   /var/www -- Web server\nservice :8080 [2345] merecat -n -p 8080 /var/www -- Old web server\n\n# Alternative method instead of below runparts, can also use /etc/rc.local\n#sysv [S] /etc/init.d/keyboard-setup       -- Setting up preliminary keymap\n#sysv [S] /etc/init.d/acpid                -- Starting ACPI Daemon\n#task [S] /etc/init.d/kbd                  -- Preparing console\n\n# Hidden from boot progress, using empty `--` description\n#sysv [S] /etc/init.d/keyboard-setup       --\n#sysv [S] /etc/init.d/acpid                --\n#task [S] /etc/init.d/kbd                  --\n\n# Run start scripts from this directory\n# runparts /etc/start.d\n\n# Virtual consoles run BusyBox getty, keep kernel default speed\ntty [12345] /sbin/getty -L 0 /dev/tty1  linux nowait noclear\ntty [2345]  /sbin/getty -L 0 /dev/tty2  linux nowait noclear\ntty [2345]  /sbin/getty -L 0 /dev/tty3  linux nowait noclear\n\n# Use built-in getty for serial port and USB serial\n#tty [12345] /dev/ttyAMA0 noclear nowait\n#tty [12345] /dev/ttyUSB0 noclear\n\n# Just give me a shell, I need to debug this embedded system!\n#tty [12345] console noclear nologin\n</code></pre> <p>The <code>service</code> stanza, as well as <code>task</code>, <code>run</code> and others are described in full in the Services Syntax section.</p> <p>Here's a quick overview of some of the most common components needed to start a UNIX daemon:</p> <pre><code>service [LVLS] &lt;COND&gt; log env:[-]/etc/default/daemon daemon ARGS -- Example daemon\n^       ^      ^      ^   ^                          ^      ^       ^\n|       |      |      |   |                          |      |        `---------- Optional description\n|       |      |      |   |                          |       `------------------ Daemon arguments\n|       |      |      |   |                           `------------------------- Path to daemon\n|       |      |      |    `---------------------------------------------------- Optional env. file\n|       |      |       `-------------------------------------------------------- Redirect output to log\n|       |       `--------------------------------------------------------------- Optional conditions\n|        `---------------------------------------------------------------------- Optional Runlevels\n `------------------------------------------------------------------------------ Supervised program (daemon)\n</code></pre> <p>Some components are optional: runlevel(s), condition(s) and description, making it easy to create simple start scripts and still possible for more advanced uses as well:</p> <pre><code>service /usr/sbin/sshd -D\n</code></pre> <p>Dependencies are handled using conditions.  One of the most common conditions is to wait for basic networking to become available:</p> <pre><code>service &lt;net/route/default&gt; nginx -- High performance HTTP server\n</code></pre> <p>Here is another example where we instruct Finit to not start BusyBox <code>ntpd</code> until <code>syslogd</code> has started properly.  Finit waits for <code>syslogd</code> to create its PID file, by default <code>/var/run/syslogd.pid</code>.</p> <pre><code>service [2345] log &lt;!pid/syslogd&gt; ntpd -n -N -p pool.ntp.org\nservice [S12345] syslogd -n -- Syslog daemon\n</code></pre> <p>Notice the <code>log</code> keyword, BusyBox <code>ntpd</code> uses <code>stderr</code> for logging when run in the foreground.  With <code>log</code> Finit redirects <code>stdout</code> + <code>stderr</code> to the system log daemon using the command line <code>logger(1)</code> tool.</p> <p>A service, or task, can have multiple dependencies listed.  Here we wait for both <code>syslogd</code> to have started and basic networking to be up:</p> <pre><code>service [2345] log &lt;pid/syslogd,net/route/default&gt; ntpd -n -N -p pool.ntp.org\n</code></pre> <p>If either condition fails, e.g. loss of networking, <code>ntpd</code> is stopped and as soon as it comes back up again <code>ntpd</code> is restarted automatically.</p> <p>Note</p> <p>Make sure daemons do not fork and detach themselves from the controlling TTY, usually an <code>-n</code> or <code>-f</code> flag, or <code>-D</code> as in the case of OpenSSH above. If it detaches itself, Finit cannot monitor it and will instead try to restart it.</p>"},{"location":"features/","title":"Finit Features","text":"<p>Process Supervision</p> <p>Start, monitor and restart services should they fail.</p> <p>Getty</p> <p>Finit supports external getty but also comes with a limited built-in Getty, useful for really small systems.  A getty sets up the TTY and waits for user input before handing over to <code>/bin/login</code>, which is responsible for handling the actual authentication.</p> <pre><code>tty [12345] /dev/tty1    nowait  linux\ntty [12345] /dev/ttyAMA0 noclear vt100\ntty [12345] /sbin/getty  -L /dev/ttyAMA0 vt100\n</code></pre> <p>Users of embedded systems may want to enable automatic serial console with the special <code>@console</code> device.  This works regardless whether the system uses <code>ttyS0</code>, <code>ttyAMA0</code>, <code>ttyMXC0</code>, or anything else.  Finit figures it out by querying sysfs: <code>/sys/class/tty/console/active</code>.</p> <pre><code>tty [12345] @console linux noclear\n</code></pre> <p>Notice the optional <code>noclear</code>, <code>nowait</code>, and <code>nologin</code> flags.  The latter is for skipping the login process entirely. For more information, see the TTY and Consoles section.</p> <p>Runlevels</p> <p>Support for SysV init-style runlevels is available, in the same minimal style as everything else in Finit.  The <code>[2345]</code> syntax can be applied to service, task, run, and TTY stanzas.</p> <p>Reserved runlevels are 0 and 6, halt and reboot, respectively just like SysV init.  Runlevel 1 can be configured freely, but is recommended to be kept as the system single-user runlevel since Finit will not start networking here.  The configured <code>runlevel NUM</code> from <code>/etc/finit.conf</code> is what Finit changes to after bootstrap, unless 'single' (or 'S') is given on the kernel cmdline, in which case runlevel 1 is started.</p> <p>All services in runlevel S) are started first, followed by the desired run-time runlevel.  Run tasks in runlevel S can be started in sequence by using <code>run [S] cmd</code>.  Changing runlevels at runtime is done like any other init, e.g. init 4, but also using the more advanced <code>initctl</code> tool.</p> <p>Conditions</p> <p>As mentioned previously, Finit has an advanced dependency system to handle synchronization, called conditions.  It can be used in many ways; depend on another service, network availability, etc.</p> <p>One really cool example useful for embedded systems is to run certain scripts if a board has a certain feature encoded in its device tree.  At bootstrap we run the following <code>ident</code> script:</p> <pre><code>#!/bin/sh\nconddir=/var/run/finit/cond/hw/model\ndtmodel=/sys/firmware/devicetree/base/model\n\nif ! test -e $dtmodel; then\n    exit 0\nfi\n\nmodel=$(cat $dtmodel | tr \"[A-Z] \" \"[a-z]-\")\nmkdir -p $conddir &amp;&amp; ln -s ../../reconf $conddir/$model\n</code></pre> <p>Provided the device tree node exists, and is a string, we can then use the condition <code>&lt;hw/model/foo&gt;</code> when starting other scripts.  Here is an example:</p> <pre><code>run  [S]                /path/to/ident    --\ntask [2] &lt;hw/model/foo&gt; /path/to/foo-init -- Initializing Foo board\n</code></pre> <p>Tip</p> <p>Notice the trick with an empty description to hide the call to <code>ident</code> in the Finit progress output.</p> <p>Plugins</p> <p>Plugins can extend the functionality of Finit and hook into the different stages of the boot process and at runtime.  Plugins are written in C and compiled into a dynamic library loaded automatically by finit at boot.  A basic set of plugins are bundled in the <code>plugins/</code> directory.</p> <p>Capabilities:</p> <ul> <li>Hooks   Hook into the boot at predefined points to extend Finit</li> <li>I/O   Listen to external events and control Finit behavior/services</li> </ul> <p>Extensions and functionality not purely related to what an <code>/sbin/init</code> needs to start a system are available as a set of plugins that either hook into the boot process or respond to various I/O.</p> <p>For more information, see the Plugins section.</p> <p>Automatic Reload</p> <p>By default, Finit monitors <code>/etc/finit.d/</code> and <code>/etc/finit.d/enabled/</code> registering any changes to <code>.conf</code> files.  To activate a change the user must call <code>initctl reload</code>, which reloads all modified files, stops any removed services, starts new ones, and restarts any modified ones.  If the command line arguments of a service have changed, the process will be terminated and then started again with the updated arguments. If the arguments have not been modified and the process supports SIGHUP, the process will receive a SIGHUP rather than being terminated and started.</p> <p>For some use-cases the extra step of calling <code>initctl reload</code> creates an unnecessary overhead, which can be removed at build-time using:</p> <pre><code>configure --enable-auto-reload\n</code></pre> <p>Linux Capabilities</p> <p>Finit supports Linux capabilities, allowing services to run with minimal required privileges instead of running as root. This improves security by following the principle of least privilege.</p> <pre><code>service [2345] name:nginx \\\n        www-data:www-data \\\n        caps:^cap_net_bind_service \\\n        /usr/sbin/nginx -g 'daemon off;'\n</code></pre> <p>In this example, nginx runs as the unprivileged <code>www-data</code> user but retains the ability to bind to privileged ports (80, 443) through the <code>cap_net_bind_service</code> capability.</p> <p>The <code>caps:</code> directive uses the IAB (Inheritable, Ambient, Bounding) format: - <code>^</code> = Ambient (recommended) - capabilities survive exec() - <code>%</code> = Inheritable only - requires file capabilities - <code>!</code> = Bounding - block from acquiring capability</p> <p>Multiple capabilities can be specified as comma-separated:</p> <pre><code>caps:^cap_net_raw,^cap_net_admin,!cap_sys_admin\n</code></pre> <p>See the Linux Capabilities section for detailed information, examples, and security best practices.</p> <p>Cgroups</p> <p>Finit supports cgroups v2 and comes with the following default groups in which services and user sessions are placed in:</p> <pre><code> /sys/fs/cgroup\n   |-- init/               # cpu.weight:100\n   |-- system/             # cpu.weight:9800\n   `-- user/               # cpu.weight:100\n</code></pre> <p>Finit itself and its helper scripts and services are placed in the top-level leaf-node group <code>init/</code>, which also is reserved.</p> <p>All run/task/service/sysv processes are placed in their own sub-group in <code>system/</code>.  The name of each sub-group is taken from the respective <code>.conf</code> file from <code>/etc/finit.d</code>.</p> <p>All getty/tty processes are placed in their own sub-group in <code>user/</code>. The name of each sub-group is taken from the username.</p> <p>A fourth group also exists, the <code>root</code> group.  It is also reserved and primarily intended for RT tasks.  If you have RT tasks they need to be declared as such in their service stanza like this:</p> <pre><code>service [...] &lt;...&gt; cgroup.root /path/to/foo args -- description\n</code></pre> <p>or</p> <pre><code>cgroup.root\nservice [...] &lt;...&gt; /path/to/foo args -- description\nservice [...] &lt;...&gt; /path/to/bar args -- description\n</code></pre> <p>See the Cgroups section for more information, e.g., how to configure per-group limits.</p> <p>The <code>initctl</code> tool has three commands to help debug and optimize the setup and monitoring of cgroups.  See the <code>ps</code>, <code>top</code>, and <code>cgroup</code> commands for details.</p> <p>Note</p> <p>Systems that do not support cgroups, specifically version 2, are automatically detected.  On such systems the above functionality is disabled early at boot.</p>"},{"location":"initctl/","title":"Commands &amp; Status","text":"<p>Finit also implements a modern API to query status, and start/stop services, called <code>initctl</code>.  Unlike <code>telinit</code> the <code>initctl</code> tool does not return until the given command has fully completed.</p> <pre><code>Usage: initctl [OPTIONS] [COMMAND]\n\nOptions:\n  -b, --batch               Batch mode, no screen size probing\n  -c, --create              Create missing paths (and files) as needed\n  -f, --force               Ignore missing files and arguments, never prompt\n  -h, --help                This help text\n  -j, --json                JSON output in 'status' and 'cond' commands\n  -1, --once                Only one lap in commands like 'top'\n  -p, --plain               Use plain table headings, no ctrl chars\n  -q, --quiet               Silent, only return status of command\n  -t, --no-heading          Skip table headings\n  -v, --verbose             Verbose output\n  -V, --version             Show program version\n\nCommands:\n  debug                     Toggle Finit (daemon) debug\n  help                      This help text\n  version                   Show program version\n\n  ls | list                 List all .conf in /etc/finit.d\n  create   &lt;CONF&gt;           Create   .conf in /etc/finit.d/available\n  delete   &lt;CONF&gt;           Delete   .conf in /etc/finit.d/available\n  show     &lt;CONF&gt;           Show     .conf in /etc/finit.d/available\n  edit     &lt;CONF&gt;           Edit     .conf in /etc/finit.d/available\n  touch    &lt;CONF&gt;           Change   .conf in /etc/finit.d/available\n  enable   &lt;CONF&gt;           Enable   .conf in /etc/finit.d/available\n  disable  &lt;CONF&gt;           Disable  .conf in /etc/finit.d/enabled\n  reload                    Reload  *.conf in /etc/finit.d (activate changes)\n\n  cond     set   &lt;COND&gt;     Set (assert) user-defined conditions     +usr/COND\n  cond     get   &lt;COND&gt;     Get status of user-defined condition, see $? and -v\n  cond     clear &lt;COND&gt;     Clear (deassert) user-defined conditions -usr/COND\n  cond     status           Show condition status, default cond command\n  cond     dump  [TYPE]     Dump all, or a type of, conditions and their status\n\n  log      [NAME]           Show ten last Finit, or NAME, messages from syslog\n  start    &lt;NAME&gt;[:ID]      Start service by name, with optional ID\n  stop     &lt;NAME&gt;[:ID]      Stop/Pause a running service by name\n  reload   &lt;NAME&gt;[:ID]      Reload service as if .conf changed (SIGHUP or restart)\n                            This allows restart of run/tasks that have already run\n                            Note: Finit .conf file(s) are *not* reloaded!\n  restart  &lt;NAME&gt;[:ID]      Restart (stop/start) service by name\n  kill     &lt;NAME&gt;[:ID] &lt;S&gt;  Send signal S to service by name, with optional ID\n  ident    [NAME]           Show matching identities for NAME, or all\n  status   &lt;NAME&gt;[:ID]      Show service status, by name\n  status                    Show status of services, default command\n\n  cgroup                    List cgroup config overview\n  ps                        List processes based on cgroups\n  top                       Show top-like listing based on cgroups\n\n  plugins                   List installed plugins\n\n  runlevel [0-9]            Show or set runlevel: 0 halt, 6 reboot\n  reboot                    Reboot system\n  halt                      Halt system\n  poweroff                  Halt and power off system\n  suspend                   Suspend system\n\n  utmp     show             Raw dump of UTMP/WTMP db\n</code></pre> <p>For services not supporting <code>SIGHUP</code> the <code>&lt;!&gt;</code> notation in the .conf file must be used to tell Finit to stop and start it on <code>reload</code> and <code>runlevel</code> changes.  If <code>&lt;&gt;</code> holds more conditions, these will also affect how a service is maintained.</p> <p>Note</p> <p>Even though it is possible to start services not belonging in the current runlevel these services will not be respawned automatically by Finit if they exit (crash).  Hence, if the runlevel is 2, the below Dropbear SSH service will not be restarted if it is killed or exits.</p> <p>The <code>status</code> command is the default, it displays a quick overview of all monitored run/task/services.  Here we call <code>initctl -p</code>, suitable for scripting and documentation:</p> <pre><code>alpine:~# initctl -p\nPID   IDENT     STATUS   RUNLEVELS     DESCRIPTION\n======================================================================\n1506  acpid     running  [---2345----] ACPI daemon\n1509  crond     running  [---2345----] Cron daemon\n1489  dropbear  running  [---2345----] Dropbear SSH daemon\n1511  klogd     running  [S-12345----] Kernel log daemon\n1512  ntpd      running  [---2345----] NTP daemon\n1473  syslogd   running  [S-12345----] Syslog daemon\n\nalpine:~# initctl -pv\nPID   IDENT     STATUS   RUNLEVELS     COMMAND\n======================================================================\n1506  acpid     running  [---2345----] acpid -f\n1509  crond     running  [---2345----] crond -f -S $CRON_OPTS\n1489  dropbear  running  [---2345----] dropbear -R -F $DROPBEAR_OPTS\n1511  klogd     running  [S-12345----] klogd -n $KLOGD_OPTS\n1512  ntpd      running  [---2345----] ntpd -n $NTPD_OPTS\n1473  syslogd   running  [S-12345----] syslogd -n\n</code></pre> <p>The environment variables to each of the services above are read from, in the case of Alpine Linux, <code>/etc/conf.d/</code>.  Other distributions may have other directories, e.g., Debian use <code>/etc/default/</code>.</p> <p>The <code>status</code> command takes an optional <code>NAME:ID</code> argument.  Here we check the status of <code>dropbear</code>, which only has one instance in this system:</p> <pre><code>alpine:~# initctl -p status dropbear\n     Status : running\n   Identity : dropbear\nDescription : Dropbear SSH daemon\n     Origin : /etc/finit.d/enabled/dropbear.conf\nEnvironment : -/etc/conf.d/dropbear\nCondition(s):\n    Command : dropbear -R -F $DROPBEAR_OPTS\n   PID file : !/run/dropbear.pid\n        PID : 1485\n       User : root\n      Group : root\n     Uptime : 2 hour 46 min 56 sec\n  Runlevels : [---2345----]\n     Memory : 1.2M\n     CGroup : /system/dropbear cpu 0 [100, max] mem [--.--, max]\n              |- 1485 dropbear -R -F\n              |- 2634 dropbear -R -F\n              |- 2635 ash\n              `- 2652 initctl -p status dropbear\n\nApr  8 12:19:49 alpine authpriv.info dropbear[1485]: Not backgrounding\nApr  8 12:37:45 alpine authpriv.info dropbear[2300]: Child connection from 192.168.121.1:47834\nApr  8 12:37:46 alpine authpriv.notice dropbear[2300]: Password auth succeeded for 'root' from 192.168.121.1:47834\nApr  8 12:37:46 alpine authpriv.info dropbear[2300]: Exit (root) from &lt;192.168.121.1:47834&gt;: Disconnect received\nApr  8 15:02:11 alpine authpriv.info dropbear[2634]: Child connection from 192.168.121.1:48576\nApr  8 15:02:12 alpine authpriv.notice dropbear[2634]: Password auth succeeded for 'root' from 192.168.121.1:48576\n</code></pre>"},{"location":"keventd/","title":"keventd","text":"<p>The kernel event daemon bundled with Finit is a simple uevent monitor for <code>/sys/class/power_supply</code>.  It provides the <code>sys/pwr/ac</code> condition, which can be useful to prevent power hungry services like anacron to run when a laptop is only running on battery, for instance.</p> <p>Since keventd is not an integral part of Finit yet it is not enabled by default.  Enable it using <code>./configure --with-keventd</code>.  The bundled <code>contrib/</code> build scripts for Debian, Alpine, and Void have this enabled.</p> <p>This daemon is planned to be extended with monitoring of other uevents, patches and ideas are welcome in the issue tracker.</p>"},{"location":"plugins/","title":"Hooks &amp; Plugins","text":"<p>Finit can be extended to add general functionality in the form of I/O monitors, or hook plugins.  It is even possible to run scripts at these hook points, see below.</p> <p>The following sections detail existing plugins and hook points.  For more information, see the plugins listed below.</p>"},{"location":"plugins/#plugins","title":"Plugins","text":"<p>For your convenience a set of optional plugins are available:</p> <ul> <li> <p>alsa-utils.so: Restore and save ALSA sound settings on   startup/shutdown.  Optional plugin.</p> </li> <li> <p>bootmisc.so: Setup necessary files and system directories for, e.g.,   UTMP (tracks logins at boot).  This plugin is central to get a working   system and runs at <code>HOOK_BASEFS_UP</code>.  The <code>/var</code>, <code>/run</code>, and <code>/dev</code>   file systems must be writable for this plugin to work.</p> </li> </ul> <p>This plugin is a wrapper for the tmpfiles.d(5) implementation that   Finit has.  Capable but limited: no aging, attributes, or subvolumes.</p> <p>By default, <code>/lib/finit/tmpfiles.d</code> carries all the default .conf   files distributed with Finit.  It is read first but can be overridden   by any of the standard tmpfiles.d directories, e.g. <code>/etc/tmpfiles.d</code>.</p> <p>Note</p> <p>On an embedded system both <code>/var</code> and <code>/run</code> can be <code>tmpfs</code> RAM disks and <code>/dev</code> is usually a <code>devtmpfs</code>.  This must be defined in the <code>/etc/fstab</code> file and in the Linux kernel config.</p> <ul> <li> <p>dbus.so: Setup and start system message bus, D-Bus, at boot.   Optional plugin.</p> </li> <li> <p>hook-scripts.so: Trigger the execution of scripts from plugin hook   points (see Hooks).  Optional plugin.</p> </li> </ul> <p>This plugin is particularly useful for early boot debugging that needs   to take place before regular services are available.</p> <p>For example, say that you want to enable some kernel tracing before   modules are loaded. With hook scripts, you can just drop in a shell   script in <code>/libexec/finit/hook/mount/all/</code> that will poke the right   control files in tracefs.</p> <p>Scripts are located in <code>/libexec/finit/hook</code> by default, this can be   customized at build-time using the <code>--with-hook-scripts-path=PATH</code>   argument to <code>configure</code>.</p> <ul> <li>hotplug.so: Replaced with <code>/lib/finit/system/10-hotplug.conf</code>, which   checks for <code>udevd</code> and <code>mdev</code> at boot.  This file can be overridden by a   file in <code>/etc/finit.d/10-hotplug.conf</code>.</li> </ul> <p>Enabled by default.</p> <p>Tip</p> <p>See the Services section in the configuration guide for an example how to run <code>mdevd</code>, alternative to plain mdev.</p> <ul> <li> <p>rtc.so: Restore and save system clock from/to RTC on boot/halt.   Enabled by default.</p> </li> <li> <p>modules-load.so: Scans <code>/etc/modules-load.d/*.conf</code> for modules to   load using <code>modprobe</code>.  Each file can contain multiple lines with the   name of the module to load.  Any line starting with the standard UNIX   comment character, <code>#</code>, or <code>;</code>, is skipped.</p> </li> </ul> <p>Modules are by default loaded in runlevel <code>S</code> using the <code>task</code> stanza.   Each module gets a unique <code>name:modprobe.foo</code>, and optional<code>:ID</code>.  The   runlevel can be changed per file using:</p> <pre><code>    set runlevel 2345\n</code></pre> <p>The <code>:ID</code> is a globally incremented index, which can be disabled per   file (anywhere) using the following config line:</p> <pre><code>    set noindex\n</code></pre> <p>To change the index used by the plugin:</p> <pre><code>    set index 1234\n</code></pre> <p>Since these tasks run in the background, they return <code>[ OK ]</code> at boot,   unless the modprobe tool does not exist.  Check syslog for warnings   and the actual status of the operation using <code>initctl</code>.</p> <p>Important</p> <p>Unlike the traditional .conf <code>module</code> directive, which load any listed module immediately, this plugin creates a background <code>task</code> which load the module(s) in the background.  The program is modprobe, <code>/sbin/modprobe</code>, which you can override per .conf file:</p> <pre><code>set modprobe /path/to/maybe-a-modprobe-wrapper\n</code></pre> <ul> <li> <p>netlink.so: Listens to Linux kernel Netlink events for gateway and   interfaces.  These events are then sent to the Finit service monitor   for services that may want to be SIGHUP'ed on new default route or   interfaces going up/down.  Enabled by default.</p> </li> <li> <p>resolvconf.so: Setup necessary files for <code>resolvconf</code> at startup.   Optional plugin.</p> </li> <li> <p>tty.so: Watches <code>/dev</code>, using inotify, for new device nodes (TTY's)   to start/stop getty consoles on them on demand.  Useful when plugging   in a usb2serial converter to login to your embedded device.  Enabled   by default.</p> </li> <li> <p>urandom.so: Setup random seed at startup.  Enabled by default.</p> </li> <li> <p>x11-common.so: Setup necessary files for X-Window.  Optional plugin.</p> </li> </ul> <p>Usually you want to hook into the boot process once, simple hook plugins like <code>bootmisc.so</code> are great for that purpose.  They are called at each hook point in the boot process, useful to insert some pre-bootstrap mechanisms, like generating configuration files, restoring HW device state, etc.  Available hook points are:</p>"},{"location":"plugins/#hooks","title":"Hooks","text":"<p>In the below listings, the first label is the hook point for a C plugin, the second is the condition name and hook script path.  A hook script is a plain shell script, or program, that does a very small dedicated job at the below hook points.</p> <p>See Run-parts Scripts for details on the requirements, possibilities, and limitations of hook scripts.</p> <p>All hook scripts are called with at least one environment variable set, the hook name, useful when reusing the same hook script for multiple hook points:</p> <ul> <li><code>FINIT_HOOK_NAME</code>: set to the second label, e.g., <code>hook/net/up</code></li> <li><code>FINIT_SHUTDOWN</code>: set for <code>hook/sys/shutdown</code> and later to one     of <code>halt</code>, <code>poweroff</code>, or <code>reboot</code>.</li> </ul> <p>Example:</p> <pre><code>$ mkdir -p /libexec/finit/hook/sys/down\n$ cat &lt;&lt;EOF &gt;/libexec/finit/hook/sys/down/foo.sh\n#!/bin/sh\necho 'I run just before the reboot() syscall at shutdown/reboot'\necho 'I have access to /dev since devtmpfs is exempt from umount'\necho \"FINIT_HOOK_NAME: $FINIT_HOOK_NAME\"\nif [ -n \"$FINIT_SHUTDOWN\" ]; then\n        echo \"FINIT_SHUTDOWN:  $FINIT_SHUTDOWN\"\nfi\nexit 0\nEOF\n$ chmod +x /libexec/finit/hook/sys/down/foo.sh\n</code></pre> <p>Important</p> <p>To use hook scripts, even for pre-bootstrap and pre-shutdown tasks, you must build with <code>configure --enable-hook-scripts-plugin</code>.</p>"},{"location":"plugins/#bootstrap-hooks","title":"Bootstrap Hooks","text":"<ul> <li> <p><code>HOOK_BANNER</code>, <code>hook/sys/banner</code>: The very first point at which a   plugin can run.  Intended to be used as a banner replacement.   Essentially this runs just before entering runlevel S.  Assume nothing   is available, so be prepared to use absolute paths, etc.</p> </li> <li> <p><code>HOOK_ROOTFS_UP</code>, <code>hook/mount/root</code>: When <code>finit.conf</code> has been read   and <code>/</code> has is mounted \u2014 very early</p> </li> <li> <p><code>HOOK_MOUNT_ERROR</code>, <code>hook/mount/error</code>: executed if <code>mount -a</code> fails</p> </li> <li> <p><code>HOOK_MOUNT_POST</code>, <code>hook/mount/post</code>: always executed after <code>mount -a</code></p> </li> <li> <p><code>HOOK_BASEFS_UP</code>, <code>hook/mount/all</code>: All of <code>/etc/fstab</code> is mounted,   swap is available and default init signals are setup</p> </li> <li> <p><code>HOOK_SVC_PLUGIN</code>, <code>hook/svc/plugin</code>: Called in <code>conf_init()</code> right   before loading <code>/etc/finit.conf</code>.  For plugins to register any early   run/task/services, please do NOT use any earlier hook point.  That   will cause uninitialized rlimits that lead to unpredictable results   when Finit later tries to start the run/task/service.</p> </li> <li> <p><code>HOOK_NETWORK_UP</code>, <code>hook/net/up</code>: System bootstrap, runlevel S, has   completed and networking is up (<code>lo</code> is up and the <code>network</code> script   has run)</p> </li> <li> <p><code>HOOK_SVC_UP</code>, <code>hook/svc/up</code>: All services in the active runlevel have   been launched</p> </li> <li> <p><code>HOOK_SYSTEM_UP</code>, <code>hook/sys/up</code>: All services and everything in   <code>/etc/finit.d</code> has been launched</p> </li> </ul>"},{"location":"plugins/#runtime-hooks","title":"Runtime Hooks","text":"<ul> <li> <p><code>HOOK_SVC_RECONF</code>, N/A: Called when the user has changed something in   the <code>/etc/finit.d</code> directory and issued <code>SIGHUP</code>.  The hook is called   when all modified/removed services have been stopped.  When the hook   has completed, Finit continues to start all modified and new services.</p> </li> <li> <p><code>HOOK_RUNLEVEL_CHANGE</code>, N/A: Called when the user has issued a   runlevel change.  The hook is called when services not matching the   new runlevel have been been stopped.  When the hook has completed,   Finit continues to start all services in the new runlevel.</p> </li> </ul>"},{"location":"plugins/#shutdown-hooks","title":"Shutdown Hooks","text":"<ul> <li> <p><code>HOOK_NETWORK_DN</code>, <code>hook/net/down</code>: Called right after having changed   to runlevel 6, or 0, when all services have received their 'stop' signal.</p> </li> <li> <p><code>HOOK_SHUTDOWN</code>, <code>hook/sys/shutdown</code>: Called at shutdown/reboot, right   before all services are sent <code>SIGTERM</code></p> </li> <li> <p><code>HOOK_SVC_DN</code>, <code>hook/svc/down</code>: In shutdown/reboot, all services and   non-reserved processes have been killed.  Note: only hook scripts   can run here!</p> </li> <li> <p><code>HOOK_SYSTEM_DN</code>, <code>hook/sys/down</code>: In shutdown/reboot, called after   all non-reserved file systems have been unmounted, just before Finit   tells the kernel to reboot or shut down.  Note: only hook scripts   can run here!</p> </li> </ul> <p>Plugins like <code>tty.so</code> extend finit by acting on events, they are called I/O plugins and are called from the finit main loop when <code>poll()</code> detects an event.  See the source code for <code>plugins/*.c</code> for more help and ideas.</p>"},{"location":"requirements/","title":"Requirements","text":"<p>Finit is capable of running on both desktop/server systems with udev and embedded systems that usually come with BusyBox mdev.  Some systems have systemd-udev or eudev today instead of the original udev, Finit probes for all of them at runtime and expects <code>/dev/</code> to be a writable file system using <code>devtmpfs</code>.  It is also possible to run on a statically set up <code>/dev</code> if needed.  It is however not a good idea to have both udev and mdev installed at the same time, this will lead to unpredictable results.</p> <p>At boot Finit calls either <code>mdev</code> or <code>udevd</code> to populate <code>/dev</code>, this is done slightly differently and on systems with udev you might want to add the following one-shot task early in your <code>/etc/finit.conf</code>:</p> <pre><code>run [S] udevadm settle --timeout=120 -- Waiting for udev\n</code></pre> <p>Finit has a built-in Getty for TTYs, but requires a working <code>/bin/login</code> or <code>/bin/sh</code>, if no TTYs are configured in <code>/etc/finit.conf</code>.</p> <p>For a fully operational system <code>/var</code>, <code>/run</code> and <code>/tmp</code> must be set up properly in <code>/etc/fstab</code> -- which is iterated over at boot.</p>"},{"location":"runlevels/","title":"Runlevel Support","text":"<p>Basic support for runlevels is included in Finit from v1.8.  By default all services, tasks, run commands and TTYs listed without a set of runlevels get a default set <code>[234]</code> assigned.  The default runlevel after boot is 2.</p> <p>Finit supports runlevels 0-9, and S, with 0 reserved for halt, 6 reboot and S for services that only run at bootstrap.  Runlevel 1 is the single user level, where usually no networking is enabled.  In Finit this is more of a policy for the user to define.  Normally only runlevels 1-6 are used, and even more commonly, only the default runlevel is used.</p> <p>To specify an allowed set of runlevels for a <code>service</code>, <code>run</code> command, <code>task</code>, or <code>tty</code>, add <code>[NNN]</code> to your <code>/etc/finit.conf</code>, like this:</p> <pre><code>service [S12345] syslogd -n -x             -- System log daemon\nrun     [S]      /etc/init.d/acpid start   -- Starting ACPI Daemon\ntask    [S]      /etc/init.d/kbd start     -- Preparing console\nservice [S12345] &lt;pid/syslogd&gt; klogd -n -x -- Kernel log daemon\n\ntty     [12345]  /dev/tty1\ntty     [2]      /dev/tty2\ntty     [2]      /dev/tty3\ntty     [2]      /dev/tty4\ntty     [2]      /dev/tty5\ntty     [2]      /dev/tty6\n</code></pre> <p>In this example syslogd is first started, in parallel, and then acpid is called using a conventional SysV init script.  It is called with the run command, meaning the following task command to start the kbd script is not called until the acpid init script has fully completed.  Then the keyboard setup script is called in parallel with klogd as a monitored service.</p> <p>Again, tasks and services are started in parallel, while run commands are called in the order listed and subsequent commands are not started until a run command has completed.  Also, task and run commands are run in a shell, so pipes and redirects can be used.</p> <p>The following examples illustrate this.  Bootstrap task and run commands are also removed when they have completed, <code>initctl show</code> will not list them.</p> <pre><code>task [S] echo \"foo\" | cat &gt;/tmp/bar\nrun  [S] echo \"$HOME\" &gt;/tmp/secret\n</code></pre> <p>Switching between runlevels can be done by calling init with a single argument, e.g. init 5, or using <code>initctl runlevel 5</code>, both switch to runlevel 5.  When changing runlevels Finit also automatically reloads all <code>.conf</code> files in the <code>/etc/finit.d/</code> directory.  So if you want to set a new system config, switch to runlevel 1, change all config files in the system, and touch all <code>.conf</code> files in <code>/etc/finit.d</code> before switching back to the previous runlevel again \u2014 that way Finit can both stop old services and start any new ones for you, without rebooting the system.</p>"},{"location":"runparts/","title":"Runparts &amp; <code>/etc/rc.local</code>","text":"<p>At the end of the boot, when all bootstrap (<code>S</code>) tasks and services have started, but not networking, Finit calls its built-in run-parts(8) command on any configured <code>runparts &lt;DIR&gt;</code> directory.  This happens just before changing to the configured runlevel (default 2).  (Networking is enabled just prior to changing from single user mode.)</p> <pre><code>runparts /etc/rc.d/\n</code></pre> <p>Right after the runlevel change when all services have started properly, <code>/etc/rc.local</code> is called.</p> <p>No configuration stanza in <code>/etc/finit.conf</code> is required for <code>rc.local</code>. If it exists and is an executable shell script Finit calls it at the very end of the boot, before calling the <code>HOOK_SYSTEM_UP</code>.  See more in the Hook Scripts section.</p>"},{"location":"runparts/#limitations","title":"Limitations","text":"<p>It is not possible to call Finit via signals or use <code>initctl</code> in any runparts or <code>/etc/rc.local</code> script.  This because Finit is single threaded and is calling these scripts in a blocking fashion at the end of runlevel S, at which point the event loop has not yet been started.</p> <p>The event loop is the whole thing which Finit is built around, except for runlevel S, which remains a slow procession through a lot of set up, with a few hooks and blocking call outs to external scripts.</p> <p>However, not all <code>initctl</code> commands are prohibited. Supported commands:</p> <ul> <li><code>initctl cond</code>: only operate on files in <code>/run/finit/cond</code></li> <li><code>initctl enable/disable</code>: enabled run/task/service is activated on    the runlevel change from S to 2</li> <li><code>initctl touch/show/create/delete/list</code>: <code>create</code>, provided the    non-interactive mode is used, again changes take effect in the    runlevel change directly after bootstrap</li> <li><code>initctl -f reboot/poweroff/halt</code>: provided the <code>-f</code> flag is used to    force direct kernel commands</li> </ul> <p>Tip</p> <p>you can set a <code>usr/</code> condition in <code>/etc/rc.local</code> and have a service/task in runlevel 2 depend on it to execute.</p>"},{"location":"service/","title":"Starting &amp; Monitoring","text":"<p>Finit can start and monitor the following types of daemons:</p> <ul> <li>Forks to background, creates a PID file</li> <li>Runs in foreground and signals ready by:</li> <li>creating a PID file</li> <li>does not create a PID file -- Finit can create it for you (optional)</li> <li>other mechanism (systemd, s6)</li> </ul> <p>Finit can not start and monitor a daemon that:</p> <ul> <li>Forks to background and does not create a PID file</li> </ul> Forking Creates PID File Finit creates PID File \u2714 Yes Yes No \u2714 No Yes No \u2714 No No Yes, optionally \u2718 Yes No No <p>Note</p> <p>PID files is one mechanism used to assert conditions to synchronize the start and stop of other, dependent, services.  Other mechanisms are described in the Service Synchronization section.</p>"},{"location":"service/#forks-to-bg-w-pid-file","title":"Forks to bg w/ PID file","text":"<p>There are two syntax variants, type 1 and type 2.  The former is the traditional one used also for <code>sysv</code> start/stop scripts, and the latter is inspired by systemd, with a twist -- it lets Finit guess the pifdile to look for based on the standard path and the basename of the command.</p> <pre><code>service pid:!/run/serv.pid serv       -- Forking service, type 1\nservice type:forking       serv       -- Forking service, type 2\n</code></pre> <p>In this example the resulting files to watch for are <code>/run/serv.pid</code> and <code>/var/run/serv.pid</code>, respectively.  On most modern Linux systems this is the same directory (<code>/var/run</code> is a symlink to <code>../run</code>).</p>"},{"location":"service/#runs-in-fg-w-pid-file","title":"Runs in fg w/ PID file","text":"<pre><code>service                    serv -n -p -- Foreground service w/ PID file\n</code></pre>"},{"location":"service/#runs-in-fg-wo-pid-file","title":"Runs in fg w/o PID file","text":"<p>Same as previous, but we tell Finit to create the PID file, because we need it to synchronize start/stop of a dependent service.</p> <pre><code>service pid:/run/serv.pid  serv -n    -- Foreground service w/o PID file\n</code></pre>"},{"location":"service/#runs-in-fg-w-custom-pid-file","title":"Runs in fg w/ custom PID file","text":"<pre><code>service pid:/run/servy.pid serv -n -p -P /run/servy.pid -- Foreground service w/ custom PID file\n</code></pre>"},{"location":"signals/","title":"Finit Signals","text":"<p>Finit is often used on embedded and small Linux systems with BusyBox. Though Finit comes with its own tools for (poweroff, halt, reboot), for compatibility with the existing BusyBox toolset the following signals have been adopted:</p>"},{"location":"signals/#sighup","title":"<code>SIGHUP</code>","text":"<p>Same effect as <code>finit q</code>, <code>init q</code>, or <code>initctl reload</code>, reloads all *.conf files in <code>/etc/finit.d/</code></p> <p>This also restarts the API (initctl) socket, like SysV init and systemd does on USR1 with their FIFO/D-Bus.</p>"},{"location":"signals/#sigusr1","title":"<code>SIGUSR1</code>","text":"<p>Since Finit 4.1 this signal causes Finit to restart its API (initctl) socket, like SysV init and systemd does on USR1 with their FIFO/D-Bus.</p> <p>Finit &lt;= 4.0 performed a system halt (like USR2 without power-off), but this caused compatibility problems with systemd and sysvinit on desktop systems.  Hence, since Finit 4.1 it is no longer possible to halt a system with a signal.</p>"},{"location":"signals/#sigusr2","title":"<code>SIGUSR2</code>","text":"<p>Calls shutdown hooks, including <code>HOOK_SHUTDOWN</code>, stopping all running processes, and unmounts all file systems.  Then tells kernel to power off the system, if ACPI or similar exists to actually do this.  If the kernel fails power-off, Finit falls back to halt.</p> <p>SysV init N/A, systemd dumps its internal state to log.</p>"},{"location":"signals/#sigterm","title":"<code>SIGTERM</code>","text":"<p>Like <code>SIGUSR2</code>, but tell kernel to reboot the system when done.</p> <p>SysV init N/A, systemd rexecutes itself.</p>"},{"location":"signals/#sigint","title":"<code>SIGINT</code>","text":"<p>Sent from kernel when the CTRL-ALT-DEL key combo is pressed.  SysV init and systemd default to reboot with <code>shutdown -r</code>.</p> <p>Finit currently forwards this to <code>SIGTERM</code>.</p>"},{"location":"signals/#sigpwr","title":"<code>SIGPWR</code>","text":"<p>Sent from a power daemon, like <code>powstatd(8)</code>, on changes to the UPS status.  Traditionally SysV init read /etc/powerstatus and acted on \"OK\", \"FAIL\", or \"LOW\" and then removed the file. Finit currently forwards this to <code>SIGUSR2</code>.</p>"},{"location":"state-machine/","title":"State Machine","text":"<p>A service is bound to a state machine that is in one of ten states.  For run/tasks there is an additional end state called <code>DONE</code>.  All processes managed by Finit start in the <code>HALTED</code> state.  The image shows how both conditions and commands drive the machine.</p> <p></p> <p>The current state depends on the two following conditions:</p> <ul> <li><code>E</code>: Service enabled. In order for <code>E</code> to be satisfied, the service   must be allowed to run in the current runlevel and not be stopped.</li> </ul> <p>A service may be stopped, or blocked, for several reasons:</p> <ul> <li>The user has manually stopped the service using <code>initctl stop NAME</code></li> <li>The program exits immediately. I.e. keeps crashing (make sure to use     the 'run this service in the foreground' command line option)</li> <li> <p>The binary is missing in the filesystem</p> </li> <li> <p><code>C</code>: Service conditions are satisfied:</p> </li> <li> <p><code>on</code> (+): The condition is asserted.</p> </li> <li><code>off</code> (-): The condition is deasserted.</li> <li><code>flux</code> (~): The condition state is unknown.</li> </ul> <p>For a detailed description of conditions, and how to debug them, see the Finit Conditions document.</p>"},{"location":"watchdog/","title":"Bundled Watchdog Daemon","text":"<p>When built <code>--with-watchdog</code> a separate service is built and installed in <code>/libexec/finit/watchdogd</code>.  If this exists at runtime, and the WDT device node exists, Finit will start it and treat it as the elected watchdog service to delegate its reboot to.  This delegation is to ensure that the system is rebooted by a hardware watchdog timer -- on many embedded systems this is crucial to ensure all circuits on the board are properly reset for the next boot, in effect ensuring the system works the same after both a power-on and reboot event.</p> <p>Note</p> <p>The watchdog reboot delegation can be enabled with the <code>reboot-watchdog</code> configuration option in <code>/etc/finit.conf</code>.  By default this is disabled and the system reboots directly via the SoC using the kernel's <code>reboot(2)</code> syscall.  See Runlevels for details.</p> <p>The delegation is performed at the very last steps of system shutdown, if reboot has been selected, <code>reboot-watchdog</code> is enabled, and an elected watchdog is known.  First a <code>SIGPWR</code> is sent to advise watchdogd of the pending reboot.  Then, when the necessary steps of preparing the system for shutdown (umount etc.) are completed, Finit sends <code>SIGTERM</code> to watchdogd and puts itself in a 10 sec timeout loop waiting for the WDT to reset the board.  If a reset is not done before the timeout, Finit falls back to <code>reboot(RB_AUTOBOOT)</code> which tells the kernel to do the reboot.</p> <p>An external watchdog service can also be used.  The more advanced cousin watchdogd is the recommended option here.  It can register itself with Finit using the same IPC as <code>initctl</code>.  If the bundled watchdogd is running a hand-over takes place, so it's safe to have both services installed on a system.  For the hand-over to work it requires that the WDT driver supports the safe exit functionality where <code>\"V\"</code> is written to the device before closing the device descriptor.  If the kernel driver has been built without this, the only option is to remove <code>/libexec/finit/watchdogd</code> or build without it at configure time.</p>"},{"location":"config/","title":"Overview","text":"<p>This section provides an overview of Finit's configuration system. For detailed information on specific topics, see the individual sections in the navigation menu.</p>"},{"location":"config/#configuration-file-syntax","title":"Configuration File Syntax","text":"<p>The file format is line based, empty lines and comments, lines starting with <code>#</code>, are ignored.  A configuration directive starts with a keyword followed by a space and the rest of the line is treated as the value.</p> <p>As of Finit v4.4, configuration directives can be broken up in multiple lines using the continuation character <code>\\</code>, and trailing comments are also allowed.  Example:</p> <pre><code># Escape \\# chars if you want them literal in, e.g., descriptions\nservice name:sysklogd [S123456789]   \\\n    env:-/etc/default/sysklogd       \\\n    syslogd -F $SYSLOGD_ARGS         \\\n    -- System log daemon \\# 1   # Comments allowed\n</code></pre> <p>The .conf files <code>/etc/finit.conf</code> and <code>/etc/finit.d/*</code> support many directives.  Some are restricted, e.g., only available at bootstrap, runlevel <code>S</code>.  Read on in Files &amp; Layout for more on how to structure your .conf files.</p> <p>For details on restrictions, see Limitations.</p>"},{"location":"config/capabilities/","title":"Linux Capabilities","text":"<p>Finit supports Linux capabilities, allowing services to run with minimal required privileges instead of running as root. This significantly improves system security by following the principle of least privilege.</p>"},{"location":"config/capabilities/#overview","title":"Overview","text":"<p>Linux capabilities divide the traditional root privileges into distinct units that can be independently granted to processes. For example, a web server only needs the capability to bind to privileged ports (&lt; 1024), not full root access.</p> <p>Finit uses the modern IAB (Inheritable, Ambient, Bounding) API from libcap, which is the same approach used by other modern service managers like dinit.</p>"},{"location":"config/capabilities/#basic-usage","title":"Basic Usage","text":"<p>Capabilities are specified using the <code>caps:</code> directive in service configuration:</p> <pre><code>service [2345] name:nginx \\\n        @www-data:www-data \\\n        caps:^cap_net_bind_service \\\n        /usr/sbin/nginx -g 'daemon off;' \\\n        -- Web server\n</code></pre> <p>This example allows nginx to bind to privileged ports (like 80 and 443) while running as the unprivileged <code>www-data</code> user.</p>"},{"location":"config/capabilities/#iab-format","title":"IAB Format","text":"<p>The capability string uses the IAB (Inheritable, Ambient, Bounding) format with the following prefixes:</p> <ul> <li><code>^</code> Ambient (and Inheritable) - Recommended for most use cases</li> <li>Capabilities survive across <code>exec()</code> calls</li> <li>Automatically raised to effective after exec</li> <li> <p>Example: <code>^cap_net_bind_service</code></p> </li> <li> <p><code>%</code> Inheritable only</p> </li> <li>Requires the executed binary to have matching file capabilities</li> <li>Less common, more complex setup</li> <li> <p>Example: <code>%cap_net_admin</code></p> </li> <li> <p><code>!</code> Bounding - Block capability from bounding set</p> </li> <li>Prevents the service from ever acquiring this capability</li> <li>Useful for security hardening</li> <li>Example: <code>!cap_sys_admin</code></li> </ul> <p>Multiple capabilities can be specified as a comma-separated list:</p> <pre><code>caps:^cap_net_raw,^cap_net_admin,^cap_net_bind_service\n</code></pre>"},{"location":"config/capabilities/#common-use-cases","title":"Common Use Cases","text":""},{"location":"config/capabilities/#web-server-privileged-ports","title":"Web Server (Privileged Ports)","text":"<p>Allow a web server to bind to ports 80 and 443 without running as root:</p> <pre><code>service [2345] name:webserver \\\n        @www-data:www-data \\\n        caps:^cap_net_bind_service \\\n        /usr/sbin/nginx -g 'daemon off;'\n</code></pre>"},{"location":"config/capabilities/#network-monitoring-raw-sockets","title":"Network Monitoring (Raw Sockets)","text":"<p>Allow packet capture without root privileges:</p> <pre><code>service [2345] name:tcpdump \\\n        @tcpdump \\\n        caps:^cap_net_raw,^cap_net_admin \\\n        /usr/sbin/tcpdump -i eth0 -w /var/log/capture.pcap\n</code></pre>"},{"location":"config/capabilities/#ntp-daemon-system-time","title":"NTP Daemon (System Time)","text":"<p>Allow time synchronization without full root:</p> <pre><code>service [2345] name:ntpd \\\n        @ntp \\\n        caps:^cap_sys_time,^cap_sys_nice \\\n        /usr/sbin/ntpd -n\n</code></pre>"},{"location":"config/capabilities/#available-capabilities","title":"Available Capabilities","text":"<p>Common capabilities include (see <code>man 7 capabilities</code> for the complete list):</p> <ul> <li><code>cap_chown</code> - Make arbitrary changes to file UIDs and GIDs</li> <li><code>cap_dac_override</code> - Bypass file read, write, and execute permission checks</li> <li><code>cap_dac_read_search</code> - Bypass file read permission checks</li> <li><code>cap_fowner</code> - Bypass permission checks on operations that normally require filesystem UID</li> <li><code>cap_kill</code> - Bypass permission checks for sending signals</li> <li><code>cap_net_admin</code> - Perform various network-related operations</li> <li><code>cap_net_bind_service</code> - Bind to privileged ports (&lt; 1024)</li> <li><code>cap_net_raw</code> - Use RAW and PACKET sockets</li> <li><code>cap_setgid</code> - Make arbitrary manipulations of process GIDs</li> <li><code>cap_setuid</code> - Make arbitrary manipulations of process UIDs</li> <li><code>cap_sys_admin</code> - Perform system administration operations (very powerful!)</li> <li><code>cap_sys_module</code> - Load and unload kernel modules</li> <li><code>cap_sys_nice</code> - Raise process nice value and change scheduling</li> <li><code>cap_sys_time</code> - Set system clock</li> </ul>"},{"location":"config/capabilities/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Use the minimum required capabilities</li> <li>Only grant what the service actually needs</li> <li> <p>Don't grant <code>cap_sys_admin</code> unless absolutely necessary</p> </li> <li> <p>Always specify a user</p> </li> <li>Always use <code>@user</code> to drop to a non-root user</li> <li> <p>Capabilities work best when combined with user separation</p> </li> <li> <p>Use ambient capabilities (<code>^</code>)</p> </li> <li>The <code>^</code> prefix ensures capabilities survive exec()</li> <li> <p>Simpler than setting file capabilities on binaries</p> </li> <li> <p>Block dangerous capabilities</p> </li> <li>Use <code>!</code> to explicitly block capabilities you don't want</li> <li> <p>Example: <code>!cap_sys_admin,!cap_sys_module</code></p> </li> <li> <p>Test with <code>getpcaps</code></p> </li> <li>After starting a service, verify its capabilities:      <pre><code>getpcaps $(pidof nginx)\n</code></pre></li> <li>Should show only the capabilities you granted</li> </ol>"},{"location":"config/capabilities/#verification","title":"Verification","text":"<p>After configuring a service with capabilities, verify it works correctly:</p> <pre><code># Start the service\ninitctl start webserver\n\n# Check the process capabilities\ngetpcaps $(pidof nginx)\n\n# Should show something like:\n# 12345: cap_net_bind_service=eip\n\n# Verify the user\nps -o user,pid,cmd -p $(pidof nginx)\n\n# Should show the service running as the specified user\n</code></pre>"},{"location":"config/capabilities/#requirements","title":"Requirements","text":"<ul> <li>Linux kernel 4.3+ (for ambient capabilities support)</li> <li>libcap library installed</li> <li>Finit built with <code>--enable-libcap</code></li> </ul>"},{"location":"config/capabilities/#limitations","title":"Limitations","text":"<ul> <li>Capabilities are only applied when both <code>@user</code> and <code>caps:</code> are specified</li> <li>The service must drop to a non-root user for capabilities to be effective</li> <li>Some very old binaries may not work correctly with ambient capabilities</li> <li>File system capabilities are not managed by Finit (use <code>setcap</code> for that)</li> </ul>"},{"location":"config/capabilities/#see-also","title":"See Also","text":"<ul> <li><code>man 7 capabilities</code> - Linux capabilities overview</li> <li><code>man 3 cap_iab</code> - IAB capability API documentation</li> <li><code>man 8 setcap</code> - Set file capabilities</li> <li><code>man 8 getcap</code> - Query file capabilities</li> <li><code>man 1 capsh</code> - Capability shell wrapper</li> </ul>"},{"location":"config/cgroups/","title":"Cgroups","text":"<p>There are three major cgroup configuration directives:</p> <ol> <li>Global top-level group: <code>init</code>, <code>system</code>, <code>user</code>, or a custom group</li> <li>Selecting a top-level group for a set of run/task/services</li> <li>Per run/task/service limits</li> </ol> <p>Note</p> <p>Linux cgroups and details surrounding values are not explained in the Finit documentation.  The Linux admin-guide cover this well: https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html</p>"},{"location":"config/cgroups/#top-level-group-configuration","title":"Top-level Group Configuration","text":"<pre><code># Top-level cgroups and their default settings.  All groups mandatory\n# but more can be added, max 8 groups in total currently.  The cgroup\n# 'root' is also available, reserved for RT processes.  Settings are\n# as-is, only one shorthand 'mem.' exists, other than that it's the\n# cgroup v2 controller default names.\ncgroup init   cpu.weight:100\ncgroup user   cpu.weight:100\ncgroup system cpu.weight:9800\n</code></pre> <p>Adding an extra cgroup <code>maint/</code> will require you to adjust the weight of the above three.  We leave <code>init/</code> and <code>user/</code> as-is reducing weight of <code>system/</code> to 9700.</p> <pre><code>cgroup system cpu.weight:9700\n\n# Example extra cgroup 'maint'\ncgroup maint  cpu.weight:100\n</code></pre> <p>By default, the <code>system/</code> cgroup is selected for almost everything.  The <code>init/</code> cgroup is reserved for PID 1 itself and its closest relatives. The <code>user/</code> cgroup is for local TTY logins spawned by getty.</p>"},{"location":"config/cgroups/#selecting-cgroups","title":"Selecting Cgroups","text":"<p>To select a different top-level cgroup, e.g. <code>maint/</code>, one can either define it for a group of run/task/service directives in a <code>.conf</code> or per each stanza:</p> <pre><code>cgroup.maint\nservice [...] &lt;...&gt; /path/to/foo args -- description\nservice [...] &lt;...&gt; /path/to/bar args -- description\n</code></pre> <p>or</p> <pre><code>service [...] &lt;...&gt; cgroup.maint /path/to/foo args -- description\n</code></pre> <p>The latter form also allows per-stanza limits. Two syntaxes are supported:</p> <p>New comma-separated syntax (recommended):</p> <pre><code>service [...] &lt;...&gt; cgroup.maint,cpu.max:10000,mem.max:655360 /path/to/foo args -- description\n</code></pre> <p>Old colon-separated syntax (legacy):</p> <pre><code>service [...] &lt;...&gt; cgroup.maint:cpu.max:10000,mem.max:655360 /path/to/foo args -- description\n</code></pre> <p>Both syntaxes work identically. The new comma-separated syntax is recommended as it's more consistent with other option parsing in Finit.</p> <p>Note the <code>mem.</code> exception to the rule: every cgroup setting maps directly to cgroup v2 syntax. I.e., <code>cpu.max</code> maps to the file <code>/sys/fs/cgroup/maint/foo/cpu.max</code>. There is no filtering, except for expanding the shorthand <code>mem.</code> to <code>memory.</code>. If the file is not available, either the cgroup controller is not available in your Linux kernel, or the name is misspelled.</p>"},{"location":"config/cgroups/#overriding-cgroup-leaf-names","title":"Overriding Cgroup Leaf Names","text":"<p>By default, the cgroup leaf directory name is derived from the service configuration filename (without the <code>.conf</code> extension). For example, a service defined in <code>system/10-hotplug.conf</code> would create a cgroup at <code>/sys/fs/cgroup/system/10-hotplug/</code> by default.</p> <p>To use a more descriptive name (recommended for clarity), you can specify <code>name:</code> in the cgroup directive:</p> <pre><code>service [...] &lt;...&gt; cgroup.system,name:udevd /lib/systemd/systemd-udevd -- Device event daemon\n</code></pre> <p>This creates the cgroup at <code>/sys/fs/cgroup/system/udevd/</code> instead.</p> <p>The syntax supports combining the name override with other options:</p> <pre><code>service [...] &lt;...&gt; cgroup.system,name:udevd,cpu.max:10000 /lib/systemd/systemd-udevd -- Device event daemon\n</code></pre> <p>Or with delegation:</p> <pre><code>service [2345] user:podman group:podman \\\n    cgroup.containers,name:podman,delegate,mem.max:4G \\\n    /usr/bin/podman system service -- Podman API\n</code></pre> <p>A daemon using <code>SCHED_RR</code> currently need to run outside the default cgroups.</p> <pre><code>service [...] &lt;...&gt; cgroup.root /path/to/daemon arg -- Real-Time process\n</code></pre>"},{"location":"config/cgroups/#cgroup-delegation","title":"Cgroup Delegation","text":"<p>For services that need to create their own child cgroups (container runtimes like Docker, Podman, systemd-nspawn, LXC), use the <code>delegate</code> option:</p> <pre><code>service [2345] user:dockerd group:dockerd \\\n    cgroup.system,delegate /usr/bin/dockerd -- Docker daemon\n</code></pre> <p>Or with the old colon syntax:</p> <pre><code>service [2345] user:dockerd group:dockerd \\\n    cgroup.system:delegate /usr/bin/dockerd -- Docker daemon\n</code></pre> <p>This allows the container runtime to:</p> <ul> <li>Create child cgroups for containers</li> <li>Manage controller settings for containers</li> <li>Move processes between cgroups</li> </ul> <p>When delegation is enabled, Finit:</p> <ol> <li>Creates the service cgroup as a domain group (not a leaf)</li> <li>Enables all available controllers in <code>cgroup.subtree_control</code></li> <li>Changes ownership of delegation files to the service user</li> <li>Moves the service process to the cgroup root</li> <li>Lets the container runtime manage its own subdirectories</li> </ol> <p>Requirements:</p> <ul> <li>The service should specify <code>user:</code> and <code>group:</code> for proper ownership</li> <li>Controllers are delegated from the parent cgroup</li> </ul> <p>Example with additional config (new syntax):</p> <pre><code>service [2345] user:podman group:podman \\\n    cgroup.containers,delegate,mem.max:4G \\\n    /usr/bin/podman system service -- Podman API\n</code></pre> <p>Or with old syntax:</p> <pre><code>service [2345] user:podman group:podman \\\n    cgroup.containers:delegate,mem.max:4G \\\n    /usr/bin/podman system service -- Podman API\n</code></pre> <p>Both examples delegate the cgroup while also setting a 4GB memory limit.</p> <p>Cgroup structure with delegation:</p> <p>Initially, the service process runs directly in the cgroup root:</p> <pre><code>/sys/fs/cgroup/system/container@web/\n\u251c\u2500\u2500 cgroup.procs            (service PID - owned by service user)\n\u251c\u2500\u2500 cgroup.subtree_control  (+cpu +memory +io - owned by service user)\n\u2514\u2500\u2500 (container children will be created here)\n</code></pre> <p>Once the container runtime creates child cgroups (e.g., <code>libpod-*/</code>), cgroups v2 enforces the \"no internal processes\" rule. When Finit detects this (<code>EBUSY</code> error), it automatically creates an <code>supervisor/</code> subdirectory and moves service-related processes there:</p> <pre><code>/sys/fs/cgroup/system/container@web/\n\u251c\u2500\u2500 cgroup.procs            (empty)\n\u251c\u2500\u2500 cgroup.subtree_control  (+cpu +memory +io)\n\u251c\u2500\u2500 supervisor/             (service processes)\n\u2502   \u2514\u2500\u2500 cgroup.procs        (conmon PIDs, etc.)\n\u2514\u2500\u2500 libpod-$HASH/           (container processes)\n    \u2514\u2500\u2500 cgroup.procs        (container PIDs)\n</code></pre> <p>This happens automatically - no configuration needed. Without delegation, the cgroup would be a leaf and the container runtime could not create child cgroups.</p>"},{"location":"config/env/","title":"Environment Variables","text":""},{"location":"config/env/#environment-variables","title":"Environment Variables","text":"<p>In Finit v4.3 support for setting environment variables in <code>finit.conf</code>, and any <code>*.conf</code>, was added.  It is worth noting that these are global and shared with all services -- the only way to have a service-local environment is detailed in Services Environment.</p> <p>The syntax for global environment variables is straight forward.  In Finit v4.4 the <code>set</code> keyword was added for completeness, but the old syntax (without the <code>set</code> prefix) is still honored:</p> <pre><code>set foo=bar\nset baz=\"qux\"\n</code></pre> <p>On reload of .conf files, all tracked environment variables are cleared so if <code>foo=bar</code> is removed from <code>finit.conf</code>, or any <code>finit.d/*.conf</code> file, it will no longer be used by Finit or any new (!) started run/tasks or services.  The environment of already started processes can not be changed.</p> <p>The only variables reset to sane defaults on .conf reload are:</p> <pre><code>PATH=_PATH_STDPATH\nSHELL=_PATH_BSHELL\nLOGNAME=root\nUSER=root\n</code></pre> <p>It is entirely possible to override these as well from the .conf files, but be careful.  Changing SHELL changes the behavior of <code>system()</code> and a lot of other commands as well.</p>"},{"location":"config/files/","title":"Files &amp; Layout","text":"<p>Originally Finit was configured using a single file, <code>/etc/finit.conf</code>, and although still possible to use a single configuration file, today the following layout is recommended:</p> <pre><code>/\n|- etc/\n|  |- finit.d/\n|  |   |- available/\n|  |   |  `- my-service.conf\n|  :   |- enabled/\n|  :   |  `- my-service.conf -&gt; ../available/my-service.conf\n|  :   :\n|  :   |- static-service.conf\n|  :   `- another-static.conf\n|  :\n|  `- finit.conf\n|- lib\n|   `- finit/\n|       `- system/\n|           |- 10-hotplug.conf\n|           `- ...\n`- run/\n    `- finit/\n        `- system/\n            |- dbus.conf\n            |- keventd.conf\n            |- runparts.conf\n            |- watchdogd.conf\n            `- ...\n</code></pre> <p>Configuration files in <code>/etc</code> are provided by the user, or projects like finit-skel and extended by the user.</p> <p>The files in <code>/lib/finit/system/*.conf</code> are system critical services and setup provided by Finit, e.g. udev/mdev that must run very early at system bootstrap.  This system directory was introduced in Finit v4.4 to replace the hard-coded services provided by plugins before.  All .conf files in this directory be either replaced by a system administrator or overridden by a file with the same name in <code>/etc/finit.d/</code>.</p> <p>The files in <code>/run/finit/system/*.conf</code> are created by plugins and Finit bundled services like runparts, watchdog, and <code>keventd</code> if they are enabled.  Like <code>/lib/finit/system/*.conf</code>, these files can be overridden by file with the same name in <code>/etc/finit.d/</code>.</p> <p>Services in the <code>available/</code> and <code>enabled/</code> sub-directories are called dynamic services, in contrast to static services -- the only difference being where they are installed and if the <code>initctl</code> tool can manage them with the <code>enable</code> and <code>disable</code> commands.  An administrator can always create files and symlinks manually.</p> <p>At bootstrap, and <code>initctl reload</code>, all .conf files are read, starting with <code>finit.conf</code>, then <code>/lib/finit/system/*.conf</code>, <code>finit.d/*.conf</code>, and finally all <code>finit.d/enabled/*.conf</code> files.  Each directory is a unique group, where files within each group are sorted alphabetically.</p> <p>Example:</p> <pre><code>/lib/finit/system/10-hotplug.conf\n/lib/finit/system/90-testserv.conf\n/run/finit/system/dbus.conf\n/run/finit/system/runparts.conf\n/etc/finit.d/10-abc.conf\n/etc/finit.d/20-abc.conf\n/etc/finit.d/enabled/1-aaa.conf\n/etc/finit.d/enabled/1-abc.conf\n</code></pre> <p>The resulting combined configuration is read line by line, each <code>run</code>, <code>task</code>, and <code>service</code> added to an ordered list that ensures they are started in the same order.  This is important because of the blocking properties of the <code>run</code> statement.  For an example on the relation of <code>service</code> and <code>run</code> statements, and dependency handling between them, see Conditional Loading, below.</p> <p>Note</p> <p>The names <code>finit.conf</code> and <code>finit.d/</code> are only defaults.  They can be changed at compile-time with two <code>configure</code> options: <code>--with-config=/etc/foo.conf</code> and <code>--with-rcsd=/var/foo.d</code>.</p> <p>They can also be overridden from the kernel command line using: <code>-- finit.config=/etc/bar.conf</code> and in that file use the top-level configuration directive <code>rcsd /path/to/finit.d</code>.</p>"},{"location":"config/files/#filesystem-layout","title":"Filesystem Layout","text":"<p>Finit is most comfortable with a traditional style Linux filesystem layout, as specified in the FHS:</p> <pre><code>/.\n |- bin/\n |- dev/          # Mounted automatically if devtmpfs is available\n |   |- pts/      # Mounted automatically by Finit if it exists\n |   `- shm/      # Mounted automatically by Finit if it exists\n |- etc/\n |   |- finit.d/\n |   |   |- available/\n |   |   `- enabled/\n |    `- finit.conf\n |- home/\n |- lib/\n |- libexec/\n |- mnt/\n |- proc/         # Mounted automatically by Finit if it exists\n |- root/\n |- run/          # Mounted automatically by Finit if it exists\n |   `- lock/     # Created automatically if Finit mounts /run\n |- sbin/\n |- sys/          # Mounted automatically by Finit if it exists\n |- tmp/          # Mounted automatically by Finit if it exists\n |- usr/\n `- var/\n     |- cache/\n     |- db/\n     |- lib/\n     |   `- misc/\n     |- lock/\n     |- log/\n     |- run -&gt; ../run\n     |- spool/\n     `- tmp/\n</code></pre> <p>Finit starts by mounting the critical file systems <code>/dev</code>, <code>/proc/</code>, and <code>/sys</code>, unless they are already mounted.  When all plugins and other, core Finit functions, have been set up, all relevant filesystems (where <code>PASS &gt; 0</code>) are checked and mounted from the selected <code>fstab</code>, either the default <code>/etc/fstab</code>, or any custom one selected from the command line, or at build time.</p> <p>To provide a smooth ride, file system not listed in the given <code>fstab</code>, e.g. <code>/tmp</code> and <code>/run</code>, are automatically mounted by Finit, as listed above, provided their respective mount point exists.</p> <p>With all filesystems mounted, Finit calls <code>swapon</code>.</p> <p>Tip</p> <p>To see what happens when all filesystems are mounted, have a look at the <code>bootmisc.so</code> plugin.</p> <p>At shutdown, and after having stopped all services and other lingering processes have been killed, filesystems are unmounted in the reverse order, and <code>swapoff</code> is called.</p>"},{"location":"config/files/#managing-services","title":"Managing Services","text":"<p>Using <code>initctl disable my-service</code> the symlink (above) is removed and the service is queued for removal.  Several changes can be made to the system, but it is not until <code>initctl reload</code> is called that the changes are activated.</p> <p>To add a new static service, drop a <code>.conf</code> file in <code>/etc/finit.d/</code> and run <code>initctl reload</code>.  (It is also possible to <code>SIGHUP</code> PID 1, or call <code>finit q</code>, but that has been deprecated with the <code>initctl</code> tool).  Finit monitors all known active <code>.conf</code> files, so if you want to force a restart of any service you can touch its corresponding <code>.conf</code> file in <code>/etc/finit.d</code> and call <code>initctl reload</code>.  Finit handles all conditions and dependencies between services automatically, see the section on Service Synchronization for more details.</p> <p>On <code>initctl reload</code> the following is checked for all services:</p> <ul> <li>If a service's <code>.conf</code> file has been removed, or its conditions are no   longer satisfied, the service is stopped.</li> <li>If the file is modified, or a service it depends on has been reloaded,   the service is reloaded (stopped and started).</li> <li>If a new service is added it is automatically started \u2014 respecting   runlevels and return values from any callbacks.</li> </ul> <p>For more info on the different states of a service, see the separate document Finit Services.</p>"},{"location":"config/files/#alternate-finitd","title":"Alternate finit.d/","text":"<p>Syntax: <code>rcsd /path/to/finit.d</code></p> <p>The Finit rcS.d directory is set at compile time with:</p> <pre><code>./configure --with-rcsd=/etc/finit.d\n</code></pre> <p>A system with multiple use-cases may be bootstrapped with different configurations, starting with the kernel command line option:</p> <pre><code>-- finit.config=/etc/factory.conf\n</code></pre> <p>This file in turn can use the <code>rcsd</code> directive to tell Finit to use another set of .conf files, e.g.:</p> <pre><code>rcsd /etc/factory.d\n</code></pre> <p>Note</p> <p>This directive is only available from the top-level bootstrap .conf file, usually <code>/etc/finit.conf</code>.</p>"},{"location":"config/files/#including-finit-configs","title":"Including Finit Configs","text":"<p>Syntax: <code>include &lt;CONF&gt;</code></p> <p>Include another configuration file.  Absolute path required.</p>"},{"location":"config/limitations/","title":"Limitations","text":"<p>As of Finit v4 there are no limitations to where <code>.conf</code> settings can be placed.  Except for the system/global <code>rlimit</code> and <code>cgroup</code> top-level group declarations, which can only be set from <code>/etc/finit.conf</code>, since it is the first <code>.conf</code> file Finit reads.</p> <p>Originally, <code>/etc/finit.conf</code> was the only way to set up a Finit system. Today it is mainly used for bootstrap settings like system hostname, early module loading for watchdogd, network bringup and system shutdown. These can now also be set in any <code>.conf</code> file in <code>/etc/finit.d</code>.</p> <p>There is, however, nothing preventing you from having all configuration settings in <code>/etc/finit.conf</code>.</p> <p>Important</p> <p>The default <code>rcsd</code>, i.e., <code>/etc/finit.d</code>, was previously the Finit runparts directory.  Finit &gt;=v4.0 no longer has a default <code>runparts</code> directory, make sure to update your setup, or the finit configuration, accordingly.</p>"},{"location":"config/logging/","title":"General Logging","text":"<p>Syntax: <code>log size:200k count:5</code></p> <p>Log rotation for run/task/services using the <code>log</code> sub-option with redirection to a log file.  Global setting, applies to all services.</p> <p>The size can be given as bytes, without a specifier, or in <code>k</code>, <code>M</code>, or <code>G</code>, e.g. <code>size:10M</code>, or <code>size:3G</code>.  A value of <code>size:0</code> disables log rotation.  The default is <code>200k</code>.</p> <p>The count value is recommended to be between 1-5, with a default 5. Setting count to 0 means the logfile will be truncated when the MAX size limit is reached.</p>"},{"location":"config/logging/#redirecting-output","title":"Redirecting Output","text":"<p>The <code>run</code>, <code>task</code>, and <code>service</code> stanzas also allow the keyword <code>log</code> to redirect <code>stderr</code> and <code>stdout</code> of the application to a file or syslog using the native <code>logit</code> tool.  This is useful for programs that do not support syslog on their own, which is sometimes the case when running in the foreground.</p> <p>The full syntax is:</p> <pre><code>log:/path/to/file\nlog:prio:facility.level,tag:ident\nlog:console\nlog:null\nlog\n</code></pre> <p>Default <code>prio</code> is <code>daemon.info</code> and default <code>tag</code> is the basename of the service or run/task command.</p> <p>Log rotation is controlled using the global <code>log</code> setting.</p> <p>Example:</p> <pre><code>service log:prio:user.warn,tag:ntpd /sbin/ntpd pool.ntp.org -- NTP daemon\n</code></pre>"},{"location":"config/logging/#output-buffering","title":"Output Buffering","text":"<p>When using the <code>log</code> directive, Finit redirects the service's stdout and stderr to a pipe connected to a logger process.  Programs detect this as non-interactive output (i.e., <code>isatty()</code> returns false) and typically switch from line-buffered to fully-buffered mode.</p> <p>Most well-behaved daemons explicitly flush their output or use syslog directly, so this is rarely an issue.  However, if a service's log messages appear delayed or batched, you can force line-buffered output by wrapping the command with <code>stdbuf</code>:</p> <pre><code>service log /usr/bin/stdbuf -oL /path/to/command -- My service\n</code></pre> <p>The <code>-oL</code> option forces line-buffered output, and <code>-o0</code> forces unbuffered output.  See <code>stdbuf(1)</code> for details.</p> <p>Note</p> <p>Using <code>stdbuf</code> is rarely necessary. Only use it if you observe actual buffering issues with a specific service.</p>"},{"location":"config/rescue/","title":"Rescue Mode","text":"<p>Finit supports a rescue mode which is activated by the <code>rescue</code> option on the kernel command line.  See cmdline docs for how to activate it.</p> <p>This rescue mode can be disabled at configure time using:</p> <pre><code>configure --without-rescue\n</code></pre> <p>The rescue mode comes in two flavors; traditional and fallback.</p> <p>Note</p> <p>In this mode <code>initctl</code> will not work.  Use the <code>-f</code> flag to force <code>reboot</code>, <code>shutdown</code>, or <code>poweroff</code>.</p>"},{"location":"config/rescue/#traditional","title":"Traditional","text":"<p>This is what most users expect.  A very early maintenance login prompt, served by the system <code>sulogin</code> program from util-linux, or BusyBox.  If that is not found in <code>$PATH</code>, the bundled <code>/libexec/finit/sulogin</code> program is used instead.  If a successful login is made, or if the user exits (Ctrl-D), the rescue mode is ended and the system boots up normally.</p> <p>Warning</p> <p>The bundled sulogin in Finit can at configure time be given another user than the default (root).  If the sulogin user does not have a password, or the account is locked, the user is presented with a prompt: <code>\"Press enter to enter maintenance mode.\"</code>, which will open up a root shell without prompting for password!</p>"},{"location":"config/rescue/#fallback","title":"Fallback","text":"<p>If no <code>sulogin</code> program is found, Finit tries to bring up as much of its own functionality as possible, yet limiting many aspects, meaning; no network, no <code>fsck</code> of file systems in <code>/etc/fstab</code>, no <code>/etc/rc.local</code>, no <code>runparts</code>, and most plugins are skipped (except those that provide functionality for the condition subsystem).</p> <p>Instead of reading <code>/etc/finit.conf</code> et al, system configuration is read from <code>/lib/finit/rescue.conf</code>, which can be freely modified by the system administrator.</p> <p>The bundled default <code>rescue.conf</code> contains nothing more than:</p> <pre><code>runlevel 1\ntty [12345] rescue\n</code></pre> <p>The <code>tty</code> has the <code>rescue</code> option set, which works similar to the board bring-up tty option <code>notty</code>.  The major difference being that <code>sulogin</code> is started to query for root/admin password.  If <code>sulogin</code> is not found, <code>rescue</code> behaves like <code>notty</code> and gives a plain root shell prompt.</p> <p>If Finit cannot find <code>/lib/finit/rescue.conf</code> it defaults to:</p> <pre><code>tty [12345] rescue\n</code></pre> <p>There is no way to exit the fallback rescue mode.</p>"},{"location":"config/runlevels/","title":"Runlevels","text":"<p>Finit supports runlevels, but unlike other init systems runlevels are declared per service/run/task/sysv command.  When booting up a system Finit pass through three phases:</p> <ol> <li>Setting up the console, parsing any command line options, and other     housekeeping tasks like mounting all filesystems, and calling <code>fsck</code></li> <li>Starting all run/task/services in runlevel S, then waiting for all     services to have started, and all run/tasks to have completed</li> <li>Go to runlevel 2, or whatever the user has set in the configuration</li> </ol> <p>Available runlevels:</p> <ul> <li><code>S</code>: bootStrap</li> <li><code>1</code>: Single user mode</li> <li><code>2-5</code>: traditional multi-user mode</li> <li><code>6</code>: reboot</li> <li><code>7-9</code>: multi-user mode (extra)</li> <li><code>0</code>: shutdown</li> </ul> <p>Runlevel S (bootStrap), is for tasks supposed to run once at boot, and services like <code>syslogd</code>, which need to start early and run throughout the lifetime of your system.</p> <p>Example:</p> <pre><code>task [S] /lib/console-setup/console-setup.sh\nservice [S12345] env:-/etc/default/rsyslog rsyslogd -n $RSYSLOGD_ARGS\n</code></pre> <p>When bootstrap has completed, Finit moves to runlevel 2.  This can be changed in <code>/etc/finit.conf</code> using the <code>runlevel N</code> directive, or by a script running in runlevel S that calls, e.g., <code>initctl runlevel 9</code>. The latter is useful if startup scripts detect problems outside of Finit's control, e.g., critical services/devices missing or hardware problems.</p> <p>Each runlevel must be allowed to \"complete\".  Meaning, all services in runlevel S must have started and all run/tasks have been started and collected (exited).  Finit waits 120 seconds for all run/tasks in S to complete before proceeding to 2.</p> <p>Finit first stops everything that is not allowed to run in 2, and then brings up networking.  Networking is expected to be available in all runlevels except: S, 1 (single user level), 6, and 0.  Networking is enabled either by the <code>network script</code> directive, or if you have an <code>/etc/network/interfaces</code> file, Finit calls <code>ifup -a</code> -- at the very least the loopback interface is brought up.</p> <p>Note</p> <p>When moving from runlevel S to 2, all run/task/services that were constrained to runlevel S only are dropped from bookkeeping.  So when reaching the prompt, <code>initctl</code> will not show these run/tasks.  This is a safety mechanism to prevent bootstrap-only tasks from accidentally being run again.  E.g., <code>console-setup.sh</code> above.</p>"},{"location":"config/runlevels/#runlevel-configuration","title":"Runlevel Configuration","text":"<p>Syntax: <code>runlevel &lt;N&gt;</code></p> <p>The system runlevel to go to after bootstrap (S) has completed.  <code>N</code> is the runlevel number 0-9, where 6 is reserved for reboot and 0 for halt. Completed in this context means all services have been started and all run/tasks have been started and collected.</p> <p>It is recommended to keep runlevel 1 as single-user mode, because Finit disables networking in this mode.</p> <p>Default: 2</p> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#networking","title":"Networking","text":"<p>Syntax: <code>network &lt;PATH&gt;</code></p> <p>Script or program to bring up networking, with optional arguments.</p> <p>Deprecated.  We recommend using dedicated task/run stanzas per runlevel, or <code>/etc/network/interfaces</code> if you have a system with <code>ifupdown</code>, like Debian, Ubuntu, Linux Mint, or an embedded BusyBox system.</p> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#system-hostname","title":"System Hostname","text":"<p>Syntax: <code>host &lt;NAME&gt;</code>, or <code>hostname &lt;NAME&gt;</code></p> <p>Set system hostname to NAME, unless <code>/etc/hostname</code> exists in which case the contents of that file is used.</p> <p>Deprecated.  We recommend using <code>/etc/hostname</code> instead.</p> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#kernel-modules","title":"Kernel Modules","text":"<p>Syntax: <code>module &lt;MODULE&gt; [ARGS]</code></p> <p>Load a kernel module, with optional arguments.  Similar to <code>insmod</code> command line tool.</p> <p>Deprecated, there is both a <code>modules-load.so</code> and a <code>modprobe.so</code> plugin that can handle module loading better.  The former supports loading from <code>/etc/modules-load.d/</code>, the latter uses kernel modinfo to automatically load (or coldplug) every required module.  For hotplug we recommend the BusyBox mdev tool, add to <code>/etc/mdev.conf</code>:</p> <pre><code>$MODALIAS=.*  root:root       0660    @modprobe -b \"$MODALIAS\"\n</code></pre> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#resource-limits","title":"Resource Limits","text":"<p>Syntax: <code>rlimit [hard|soft] RESOURCE &lt;LIMIT|unlimited&gt;</code></p> <p>Set the hard or soft limit for a resource, or both if that argument is omitted.  <code>RESOURCE</code> is the lower-case <code>RLIMIT_</code> string constants from <code>setrlimit(2)</code>, without prefix.  E.g. to set <code>RLIMIT_CPU</code>, use <code>cpu</code>.</p> <p>LIMIT is an integer that depends on the resource being modified, see the man page, or the kernel <code>/proc/PID/limits</code> file, for details. Finit versions before v3.1 used <code>infinity</code> for <code>unlimited</code>, which is still supported, albeit deprecated.</p> <pre><code># No process is allowed more than 8MB of address space\nrlimit hard as 8388608\n\n# Core dumps may be arbitrarily large\nrlimit soft core infinity\n\n# CPU limit for all services, soft &amp; hard = 10 sec\nrlimit cpu 10\n</code></pre> <p><code>rlimit</code> can be set globally, in <code>/etc/finit.conf</code>, or locally per each <code>/etc/finit.d/*.conf</code> read.  I.e., a set of task/run/service stanzas can share the same rlimits if they are in the same .conf.</p>"},{"location":"config/runlevels/#miscellaneous-settings","title":"Miscellaneous Settings","text":"<p>Syntax: <code>reboot-delay &lt;0-60&gt;</code></p> <p>Optional delay at reboot (or shutdown or halt) to allow kernel filesystem threads to complete after calling <code>sync(2)</code> before rebooting.  This applies primarily to filesystems that do not have a reboot notifier implemented.  At the point of writing, the only known filesystems affected are: ubifs, jffs2.</p> <p>Default: 0 (disabled)</p> <p>When enabled (non-zero), this delay runs after file systems have been unmounted and the root filesystem has been remounted read-only, and sync(2) has been called, twice.</p> <p>\"On Linux, sync is only guaranteed to schedule the dirty blocks for writing; it can actually take a short time before all the blocks are finally written.</p> <p>Syntax: <code>reboot-watchdog &lt;on|off|true|false|1|0&gt;</code></p> <p>Controls whether the system should reboot via the watchdog timer (WDT) or directly via the SoC/kernel.  When enabled, Finit will:</p> <ol> <li>Send <code>SIGPWR</code> to the registered watchdog daemon before shutdown</li> <li>Send <code>SIGTERM</code> to the watchdog daemon and wait up to 10 seconds     for the watchdog to trigger a hardware reset</li> </ol> <p>When disabled (default), Finit skips the watchdog reboot logic and calls the kernel's <code>reboot(2)</code> syscall directly for a clean SoC reboot.</p> <p>Default: off (reboot via SoC)</p> <p>Note</p> <p>This setting only affects reboots.  The watchdog daemon will still run and monitor the system during normal operation.</p>"},{"location":"config/runparts/","title":"Run-parts Scripts","text":""},{"location":"config/runparts/#run-parts-scripts","title":"Run-parts Scripts","text":"<p>Syntax: <code>runparts [progress] [sysv] &lt;DIR&gt;</code></p> <p>Call run-parts(8) on <code>DIR</code> to run start scripts.  All executable files in the directory are called, in alphabetic order.  The scripts in this directory are executed at the very end of runlevel <code>S</code>.</p> <p>A common use-case for runparts scripts is to create and enable/disable services, which Finit will then apply when changing runlevel from S to whatever the next runlevel is set to be (default 2).  E.g., generate a <code>/etc/chrony.conf</code> and call <code>initctl enable chronyd</code>.</p> <p>Options:</p> <ul> <li><code>progress</code>: display the progress of each script being executed</li> <li><code>sysv</code>: run only SysV style scripts, i.e., <code>SNNfoo</code>, or <code>KNNbar</code>,    where <code>NN</code> is a number (0-99).</li> </ul> <p>If global debug mode is enabled, the <code>runparts</code> program is also called with the debug flag.</p> <p>Limitations:</p> <p>Scripts called from <code>runparts</code>, or hook scripts (see below), are limited in their interaction with Finit.  Like the standalone <code>run</code> stanza and the <code>/etc/rc.local</code> shell script, Finit waits for their completion before continuing.  None of them can issue commands to start, stop, or restart other services.  Also, ensure all your services and programs either terminate or start in the background or you will block Finit.</p> <p>Note</p> <p><code>runparts</code> scripts are only read and executed in runlevel S.  See hook scripts for other ways to run scripts at certain points during the complete lifetime of the system.</p> <p>Recommendations:</p> <p>It can be beneficial to use <code>01-name</code>, <code>02-othername</code>, etc., to ensure the scripts are started in that order, e.g., if there is a dependency order between scripts.  Symlinks to existing daemons can talso be used, but make sure they daemonize (background) themselves properly, otherwise Finit will lock up.</p> <p>If <code>S[0-9]foo</code> and <code>K[0-9]bar</code> style naming is used, the executable will be called with an extra argument, <code>start</code> and <code>stop</code>, respectively. E.g., <code>S01foo</code> will be called as <code>S01foo start</code>.  Of course, <code>S01foo</code> and <code>K01foo</code> may be a symlink to to <code>another/directory/foo</code>.</p>"},{"location":"config/service-env/","title":"Environment","text":""},{"location":"config/service-env/#service-environment","title":"Service Environment","text":"<p>Finit supports sourcing environment variables from <code>/etc/default/*</code>, or similar <code>--with-sysconfig=DIR</code>.  This is a common pattern from SysV init scripts, where the start-stop script is a generic script for the given service, <code>foo</code>, and the options for the service are sourced from the file <code>/etc/default/foo</code>.  Like this:</p> <ul> <li> <p><code>/etc/default/foo</code>:</p> <pre><code>FOO_OPTIONS=--extra-arg=\"bar\" -s -x\n</code></pre> </li> <li> <p><code>/etc/finit.conf</code>:</p> <pre><code>service [2345] env:-/etc/default/foo foo -n $FOO_OPTIONS -- Example foo daemon\n</code></pre> </li> </ul> <p>Here the service <code>foo</code> is started with <code>-n</code>, to make sure it runs in the foreground, and the with the options found in the environment file.  With the <code>ps</code> command we can see that the process is started with:</p> <pre><code>foo -n --extra-arg=bar -s -x\n</code></pre> <p>Note</p> <p>The leading <code>-</code> in <code>env:</code> determines if Finit should treat a missing environment file as blocking the start of the service or not.  When <code>-</code> is used, a missing environment file does not block the start.</p>"},{"location":"config/service-opts/","title":"Service Options","text":"<p>The run/task/tty/service/sysv directives take modifiers, or options, to control their behavior.  This section lists them with their limitations. All modifiers must be placed between the directive and its command.</p> <p>The name of a service, shown by the <code>initctl</code> tool, defaults to the basename of the service executable. It can be changed with the <code>name:</code> option:</p> <pre><code>name:&lt;service-name&gt;\n</code></pre> <p>For multiple instances of a service, with the same <code>name</code>, set the identifier <code>:ID</code> to prevent Finit from replacing previous instances:</p> <pre><code>service name:ssdp :eth1 ssdpd eth1 -- Windows discovery on eth1\nservice name:ssdp :eth2 ssdpd eth2 -- Windows discovery on eth2\n</code></pre> <p>The <code>initctl</code> tool will list these two services as:</p> <ul> <li>ssdp:eth1</li> <li>ssdp:eth2</li> </ul> <p>Conflicting services that must be prevented from starting, use the <code>conflict:</code> option:</p> <pre><code>service [S12345789] udevd -- Device event management daemon\nrun [S] conflict:udevd mdev -s -- Populating device tree\n</code></pre> <p>Multiple conflicting services can be separated using <code>,</code>:</p> <pre><code>service :1 abc\nservice :2 abc\nservice conflict:abc:1,abc:2 cde\n</code></pre> <p>If a service should not be automatically started, it can be configured as manual with the optional <code>manual</code> argument. The service can then be started at any time by running <code>initctl start &lt;service&gt;</code>.</p> <pre><code>manual:yes\n</code></pre> <p>Other run/task/service options are:</p> <ul> <li><code>caps:...</code> -- see the Linux Capabilities section</li> <li><code>cgroups:...</code> -- see the Cgroups section</li> <li><code>env:[-]/path/to/env</code> -- see the Service Environment section</li> <li><code>log:...</code> -- see Redirecting Output</li> <li><code>nowarn</code> -- see Conditional Loading</li> <li><code>notify:...</code> -- see Service Synchronization</li> <li><code>if:...</code> -- see Conditional Execution</li> <li><code>type:forking</code> -- see description of the service directive</li> </ul> <p>As mentioned previously, services are automatically started, restarted, and stopped, depending on the configuration and conditions.  Within the confines of that the following options are available:</p> <ul> <li><code>restart:NUM</code> -- number of times Finit tries to restart a crashing     service, default: 10, max: 255.  When this limit is reached the     service is marked crashed and must be restarted manually with     <code>initctl restart NAME</code></li> <li><code>restart_sec:SEC</code> -- number of seconds before Finit tries to restart     a crashing service, default: 2 seconds for the first five retries,     then back-off to 5 seconds.  The maximum of this configured value     and the above (2 and 5) will be used</li> <li><code>restart:always</code> -- no upper limit on the number of times Finit     tries to restart a crashing service.  Same as <code>restart:-1</code></li> <li><code>norestart</code> -- dont restart on failures, same as <code>restart:0</code></li> <li><code>respawn</code> -- bypasses the <code>restart</code> mechanism completely, allows     endless restarts.  Useful in many use-cases, but not what <code>service</code>     was originally designed for so not the default behavior</li> <li><code>oncrash:reboot</code> -- when all retries have failed, and the service     has crashed, if this option is set the system is rebooted</li> <li><code>oncrash:script</code> -- similarly, but instead of rebooting, call the     <code>post:script</code> action with exit code <code>crashed</code>, see below</li> <li><code>reload:'script [args]'</code> -- some services do not support <code>SIGHUP</code> but     may have other ways to update the configuration of a running daemon.     When <code>reload:script</code> is defined it is preferred over <code>SIGHUP</code>.  Like     systemd, Finit sets <code>$MAINPID</code> as a convenience to scripts, which in     effect also allow <code>reload:'kill -HUP $MAINPID'</code></li> <li><code>stop:'script [args]'</code> -- some services may require alternate methods     to be stopped.  If a <code>stop:script</code> is defined it is preferred over     <code>SIGTERM</code> and <code>stop</code>, for <code>service</code> and <code>sysv</code>, respectively.     Similar to <code>reload:script</code>, Finit sets <code>$MAINPID</code></li> </ul> <p>Caution</p> <p>Both <code>reload:script</code> and <code>stop:script</code> are called as PID 1, without any timeout!  Meaning, it is up to you to ensure the script is not blocking for seconds at a time or never terminates.</p> <p>When stopping a service (run/task/sysv/service), either manually or when moving to another runlevel, Finit starts by sending <code>SIGTERM</code>, to allow the process to shut down gracefully (unless a <code>stop:'script'</code> is used). However, if the process has not been collected within 3 seconds, Finit will send <code>SIGKILL</code>.  To stop the process using a different signal than <code>SIGTERM</code>, use <code>halt:SIGNAL</code>, e.g., <code>halt:SIGPWR</code>.  To change the delay between the stop signal and KILL, use the option <code>kill:&lt;1-60&gt;</code>, e.g., <code>kill:10</code> to wait 10 seconds before sending <code>SIGKILL</code>.</p> <p>Services, including the <code>sysv</code> variant, support pre/post/ready and cleanup scripts:</p> <ul> <li><code>pre:[0-3600,]script</code> -- called before the sysv/service is stated</li> <li><code>post:[0-3600,]script</code> -- called after the sysv/service has stopped</li> <li><code>ready:[0-3600,]script</code> -- called when the sysv/service is ready</li> <li><code>cleanup:[0-3600,]script</code> -- called when run/task/sysv/service is removed</li> </ul> <p>The optional number (0-3600) is the timeout before Finit kills the script, it defaults to the kill delay value and can be disabled by setting it to zero.  These scripts run as the same <code>@USER:GROUP</code> as the service itself, with any <code>env:file</code> sourced.  The scripts are executed from the <code>$HOME</code> of the given user.  The scripts are not called with any argument, but get a set of environment variables:</p> <ul> <li><code>SERVICE_IDENT=foo:1</code></li> <li><code>SERVICE_NAME=foo</code></li> <li><code>SERVICE_ID=1</code></li> </ul> <p>The <code>post:script</code> is called with an additional set of environment variables.  Yes, the text is correct, the naming was an accident:</p> <ul> <li><code>EXIT_CODE=[exited,signal,crashed]</code>: normal exit, signaled, or    crashed</li> <li><code>EXIT_STATUS=[num,SIGNAME]</code>: set to one of exit status code from    the program, if it exited normally, or the signal name (<code>HUP</code>,    <code>TERM</code>, etc.) if it exited due to signal</li> </ul> <p>When a run/task/sys/service is removed (disable + reload) it is first stopped and then removed from the runlevel.  The <code>post:script</code> always runs when the process has stopped, and the <code>cleanup:script</code> runs when the the stanza has been removed from the runlevel.</p> <p>Important</p> <p>These script actions are intended for setup, cleanup, and readiness notification.  It is up to the user to ensure the scripts terminate.</p>"},{"location":"config/service-sync/","title":"Service Synchronization","text":"<p>Finit was created for fast booting systems.  Faster than a regular SysV Init based system at the time.  Early on the need for a guaranteed start order of services (daemons) arose.  I.e., service <code>A</code> must be guaranteed to have started (and be ready!) before <code>B</code>.  The model that was chosen to determine this was very simple: PID files.</p> <p>Early on in UNIX daemons were controlled with basic IPC like signals, and the way for a user to know that a daemon was ready to respond to signals (minimally having set up its signal handler), was to tell the user;</p> <p>\"Hey, you can send signals to me using the PID in this file: <code>/var/run/daemon.pid</code>\".</p> <p>Since most systems run fairly unchanged after boot, Finit could rely on the PID file for <code>A</code> being created before launching <code>B</code>.  This method has worked well for a long time, and for systems based on Open Source it was easy to either add PID file support to a daemon without support for it, or fix ordering issues (PID file created before signal handler is set up) in existing daemons.</p> <p>However, with the advent of other Init systems (Finit is rather old), most notably systemd and s6, other methods for signaling \"readiness\" arrived and daemons were adapted to these new schemes to a larger extent.</p> <p>As of Finit v4.4 partial support for systemd and s6 style readiness notification is available, and the native PID file mode of operation is, as of Finit v4.6 optional, by default it is still enabled, but this can be changed in <code>finit.conf</code>:</p> <pre><code>readiness none\n</code></pre> <p>This will be made the default in Finit 5.0.  In this mode of operation, every service needs to explicitly declare their readiness notification, like this:</p> <pre><code>service notify:pid     watchdogd\nservice notify:systemd foo\nservice notify:s6      bar\nservice notify:none    qux\n</code></pre> <p>The <code>notify:none</code> syntax is for completeness in systems which run in <code>readiness pid</code> mode (default).  Services declared with <code>notify:none</code> will transition to ready as soon as Finit has started them, e.g., <code>service/qux/ready</code>.</p> <p>To synchronize two services the following condition can be used:</p> <pre><code>service notify:pid                 watchdogd\nservice &lt;service/watchdogd/ready&gt;  stress-ng --cpu 8\n</code></pre> <p>For details on the syntax and options, see below.</p> <p>Note</p> <p>On <code>initctl reload</code> conditions are set in \"flux\", while figuring out which services to stop, start or restart.  Services that need to be restarted have their <code>ready</code> condition removed before Finit issue a SIGHUP (if they support that), or stop-starting them.  A daemon is expected to reassert its readiness, e.g. systemd style daemons to write <code>READY=1\\n</code>.</p> <p>However, the s6 notify mode does not support this because in s6 you are expected to close your notify descriptor after having written <code>\\n</code>.  This means s6 style daemons currently must be stop-started. (Declare the service with <code>&lt;!&gt;</code> in its condition statement.)</p> <p>For default, PID file style readiness notification, daemons are expected to either create their PID files, or touch it using <code>utimensat()</code> to reassert readiness.  Triggering both the <code>&lt;pid/&gt;</code> and <code>&lt;.../ready&gt;</code> conditions.</p>"},{"location":"config/service-wrappers/","title":"Service Wrapper Scripts","text":"<p>If your service requires to run additional commands, executed before the service is actually started, like the systemd <code>ExecStartPre</code>, you can use a wrapper shell script to start your service.</p> <p>The Finit service <code>.conf</code> file can be put into <code>/etc/finit.d/available</code>, so you can control the service using <code>initctl</code>.  Then use the path to the wrapper script in the Finit <code>.conf</code> service stanza.  The following example employs a wrapper script in <code>/etc/start.d</code>.</p> <p>Example:</p> <ul> <li> <p><code>/etc/finit.d/available/program.conf</code>:</p> <pre><code>service [235] &lt;!&gt; /etc/start.d/program -- Example Program\n</code></pre> </li> <li> <p><code>/etc/start.d/program:</code></p> <pre><code>#!/bin/sh\n# Prepare the command line options\nOPTIONS=\"-u $(cat /etc/username)\"\n\n# Execute the program\nexec /usr/bin/program $OPTIONS\n</code></pre> </li> </ul> <p>Note</p> <p>The example sets <code>&lt;!&gt;</code> to denote that it doesn't support <code>SIGHUP</code>. That way Finit will stop/start the service instead of sending SIGHUP at restart/reload events.</p>"},{"location":"config/services/","title":"Services","text":"<p>Syntax: <code>service [LVLS] &lt;COND&gt; /path/to/daemon ARGS -- Optional description</code></p> <p>Service, or daemon, to be monitored and automatically restarted if it exits prematurely.  Finit tries to restart services that die, by default 10 times before giving up and marking them as crashed.  After which they have to be manually restarted with <code>initctl restart NAME</code>.  The limits controlling this are configurable, see the options below.</p> <p>Tip</p> <p>To allow endless restarts, see the <code>respawn</code> option</p> <p>For daemons that support it, we recommend appending <code>--foreground</code>, <code>--no-background</code>, <code>-n</code>, <code>-F</code>, or similar command line argument to prevent them from forking off a sub-process in the background.  This is the most reliable way to monitor a service.</p> <p>However, not all daemons support running in the foreground, or they may start logging to the foreground as well, these are forking daemons and are supported using the same syntax as forking <code>sysv</code> services, using the <code>pid:!/path/to/pidfile.pid</code> syntax.  There is an alternative syntax that may be more intuitive, where Finit can also guess the PID file based on the daemon's command name:</p> <pre><code>service type:forking ntpd -- NTP daemon\n</code></pre> <p>This example lets BusyBox <code>ntpd</code> daemonize itself.  Finit uses the basename of the binary to guess the PID file to watch for the PID: <code>/var/run/ntpd.pid</code>.  If Finit guesses wrong, you have to submit the full <code>pid:!/path/to/file.pid</code>.</p> <p>Example:</p> <p>In the case of <code>ospfd</code> (below), we omit the <code>-d</code> flag (daemonize) to prevent it from forking to the background:</p> <pre><code>service [2345] &lt;pid/zebra&gt; /sbin/ospfd -- OSPF daemon\n</code></pre> <p><code>[2345]</code> denote the runlevels <code>ospfd</code> is allowed to run in, they are optional and default to level 2-5 if omitted.</p> <p><code>&lt;...&gt;</code> is the condition for starting <code>ospfd</code>.  In this example Finit waits for another service, <code>zebra</code>, to have created its PID file in <code>/var/run/quagga/zebra.pid</code> before starting <code>ospfd</code>.  Finit watches all files in <code>/var/run</code>, for each file named <code>*.pid</code>, or <code>*/pid</code>, Finit opens it and find the matching <code>NAME:ID</code> using the PID.</p> <p>Some services do not maintain a PID file and rather than patching each application Finit provides a workaround.  A <code>pid</code> keyword can be set to have Finit automatically create (when starting) and later remove (when stopping) the PID file.  The file is created in the <code>/var/run</code> directory using the <code>basename(1)</code> of the service.  The default can be modified with an optional <code>pid:</code>-argument:</p> <pre><code>pid[:[/path/to/]filename[.pid]]\n</code></pre> <p>For example, by adding <code>pid:/run/bar.pid</code> to the service <code>/sbin/bar</code>, that PID file will, not only be created and removed automatically, but also be used by the Finit condition subsystem.  So a service/run/task can depend on <code>&lt;pid/bar&gt;</code>, like this foo will not be started until bar has started:</p> <pre><code>service pid:/run/bar.pid bar -- Bar Service\nservice &lt;pid/bar&gt; foo -- Foo Service\n</code></pre> <p>Needless to say, it is better if <code>bar</code> creates its own PID file when it has completed starting up and is ready for service.</p> <p>As an alternative \"readiness\" notification, Finit supports both systemd and s6 style notification.  This can be enabled by using the <code>notify</code> option:</p> <ul> <li><code>notify:systemd</code> -- tells Finit the service uses the <code>sd_notify()</code>     API to signal PID 1 when it has completed its startup and is ready     to service events.  The sd_notify() API expects <code>NOTIFY_SOCKET</code>     to be set to the socket where the application can send <code>\"READY=1\\n\"</code>     when it is starting up or has processed a <code>SIGHUP</code>.</li> <li><code>notify:s6</code> -- puts Finit in s6 compatibility mode.  Compared to the     systemd notification, s6 expect compliant daemons to send <code>\"\\n\"</code>     and then close their socket.  Finit takes care of \"hard-wiring\" the     READY state as long as the application is running, events across any     <code>SIGHUP</code>.  Since s6 can give its applications the descriptor number     (must be &gt;3) on then command line, Finit provides the following     syntax (<code>%n</code> is replaced by Finit with then descriptor number):<pre><code>service [S12345789] notify:s6 mdevd -O 4 -D %n\n</code></pre> </li> </ul> <p>When a service is ready, either by Finit detecting its PID file, or their respective readiness mechanism has been triggered, Finit creates then service's ready condition which other services can depend on:</p> <pre><code>$ initctl -v cond get service/mdevd/ready\non\n</code></pre> <p>This can be used to synchronize the start of another run/task/service:</p> <pre><code>task [S] &lt;service/mdevd/ready&gt; @root:root mdevd-coldplug\n</code></pre> <p>Finit waits for <code>mdevd</code> to notify it, before starting <code>mdevd-coldplug</code>. Notice how both start in runlevel S, and the coldplug task only runs in S.  When the system moves to runlevel 2 (the default), coldplug is no longer part of the running configuration (<code>initctl show</code>), this is to ensure that coldplug is not called more than once.</p> <p>For a detailed description of conditions, and how to debug them,  see the Finit Conditions document.</p>"},{"location":"config/services/#non-privileged-services","title":"Non-privileged Services","text":"<p>Every <code>run</code>, <code>task</code>, or <code>service</code> can also list the privileges the <code>/path/to/cmd</code> should be executed with.  Prefix the command with <code>@USR[:GRP[,SUPP,...]]</code>, where group and supplementary groups are optional, like this:</p> <pre><code>run [2345] @joe:users logger \"Hello world\"\n</code></pre> <p>Finit reads the user's supplementary group membership from <code>/etc/group</code> automatically.  Any groups the user belongs to will be inherited by the service.</p> <p>To specify additional supplementary groups beyond those in <code>/etc/group</code>, append them after the primary group, separated by commas:</p> <pre><code>service @caddy:caddy,ssl-cert /usr/bin/caddy run\n</code></pre> <p>This runs the <code>caddy</code> service as user <code>caddy</code>, with primary group <code>caddy</code>, inheriting any groups <code>caddy</code> is a member of in <code>/etc/group</code>, plus the additional <code>ssl-cert</code> group.  This is useful when a service needs access to resources owned by groups not listed in <code>/etc/group</code>.</p> <p>For multiple instances of the same command, e.g. a DHCP client or multiple web servers, add <code>:ID</code> somewhere between the <code>run</code>, <code>task</code>, <code>service</code> keyword and the command, like this:</p> <pre><code>service :80  [2345] httpd -f -h /http -p 80   -- Web server\nservice :8080[2345] httpd -f -h /http -p 8080 -- Old web server\n</code></pre> <p>Without the <code>:ID</code> to the service the latter will overwrite the former and only the old web server would be started and supervised.</p>"},{"location":"config/services/#conditional-loading","title":"Conditional Loading","text":"<p>Finit support conditional loading of stanzas.  The following example is take from the <code>system/hotplug.conf</code> file in the Finit distribution. Here we only show a simplified subset.</p> <p>Starting with the <code>nowarn</code> option.</p> <pre><code>service nowarn name:udevd pid:udevd /lib/systemd/systemd-udevd\nservice nowarn name:udevd pid:udevd udevd\n</code></pre> <p>When loading the .conf file Finit looks for <code>/lib/systemd/systemd-udevd</code> if that is not found Finit automatically logs a warning.  The <code>nowarn</code> option disables this warning so that the second line can be evaluated, which also provides a service named <code>udevd</code>.</p> <pre><code>run nowarn if:udevd &lt;pid/udevd&gt; :1 udevadm settle -t 0\n</code></pre> <p>This line is only loaded if we know of a service named <code>udevd</code>.  Again, we do not warn if <code>udevadm</code> is not found, execution will also stop here until the PID condition is asserted, i.e., Finit detecting udevd has started.</p> <pre><code>run nowarn conflict:udevd [S] mdev -s -- Populating device tree\n</code></pre> <p>If <code>udevd</code> is not available, we try to run <code>mdev</code>, but if that is not found, again we do not warn.</p> <p>Conditional loading statements can also be negated, so the previous stanza can also be written as:</p> <pre><code>run nowarn if:!udevd [S] mdev -s -- Populating device tree\n</code></pre> <p>The reason for using <code>conflict</code> in this example is that a conflict can be resolved.  Stanzas marked with <code>conflict:foo</code> are rechecked at runtime.</p>"},{"location":"config/services/#conditional-execution","title":"Conditional Execution","text":"<p>Similar to conditional loading of stanzas there is conditional runtime execution.  This can be confusing at first, since Finit already has a condition subsystem, but this is more akin to the qualification to a runlevel.  E.g., a <code>task [123]</code> is qualified to run only in runlevel 1, 2, and 3.  It is not considered for other runlevels.</p> <p>Conditional execution qualify a run/task/service based on a condition. Consider this (simplified) example from the Infix operating system:</p> <pre><code>run [S]                       name:startup &lt;pid/sysrepo&gt; confd -b --load startup-config\nrun [S] if:&lt;usr/fail-startup&gt; name:failure &lt;pid/sysrepo&gt; confd    --load failure-config\n</code></pre> <p>The two run statements reside in the same .conf file so Finit runs them in true sequence.  If loading the file <code>startup-config</code> fails confd sets the condition <code>usr/fail-startup</code>, thus allowing the next run statement to load <code>failure-config</code>.</p> <p>Notice the critical difference between the <code>&lt;pid/sysrepo&gt;</code> condition and <code>if:&lt;usr/fail-startup&gt;</code>.  The former is a condition for starting and the latter is a condition to check if a run/task/service is qualified to even be considered.</p> <p>Conditional execution statements can also be negated, so provided the file loaded did the opposite, i.e., set a condition on success, the previous stanza can also be written as:</p> <pre><code>run [S] if:&lt;!usr/startup-ok&gt; name:failure &lt;pid/sysrepo&gt; confd ...\n</code></pre>"},{"location":"config/sysv/","title":"SysV Init Compatibility","text":"<p>It is not possible to run unmodified SysV init systems with Finit.  This was never the intention and is not the strength of Finit.  However, it comes with a few SysV Init compatibility features to ease the transition from a serialized boot process.</p>"},{"location":"config/sysv/#sysv-init-scripts","title":"SysV Init Scripts","text":"<p>Syntax: <code>sysv [LVLS] &lt;COND&gt; /path/to/init-script -- Optional description</code></p> <p><code>&lt;COND&gt;</code> is described in the Services section.</p> <p>Similar to <code>task</code> is the <code>sysv</code> stanza, which can be used to call SysV style scripts.  The primary intention for this command is to be able to reuse much of existing setup and init scripts in Linux distributions.</p> <p>When entering an allowed runlevel, Finit calls <code>init-script start</code>, when entering a disallowed runlevel, Finit calls <code>init-script stop</code>, and if the Finit .conf, where <code>sysv</code> stanza is declared, is modified, Finit calls <code>init-script restart</code> on <code>initctl reload</code>.  Similar to how <code>service</code> stanzas work.</p> <p>Forking services started with <code>sysv</code> scripts can be monitored by Finit by declaring the PID file to look for: <code>pid:!/path/to/pidfile.pid</code>. Notice the leading <code>!</code>, it signifies Finit should not try to create the file, but rather watch that file for the resulting forked-off PID.  This syntax also works for forking daemons that do not have a command line option to run it in the foreground, more on this below in <code>service</code>.</p> <p>Tip</p> <p>See also SysV Init Compatibility.</p>"},{"location":"config/sysv/#runparts-directory","title":"<code>runparts DIRECTORY</code>","text":"<p>For a directory with traditional start/stop scripts that should run, in order, at bootstrap, Finit provides the <code>runparts</code> directive.  It runs in runlevel S, at the very end of it (before calling <code>/etc/rc.local</code>) making it perfect for most scenarios.</p> <p>For syntax details, see the Run-parts Scripts section. Here is an example take from a Debian installation:</p> <pre><code>runparts /etc/rc2.d\n</code></pre> <p>Files in these directories are usually named <code>SNNfoo</code> and <code>KNNfoo</code>, which Finit knows about and automatically appends the correct argument:</p> <pre><code>/bin/sh -c /etc/rc2.d/S01openbsd-inetd start\n</code></pre> <p>or</p> <pre><code>/bin/sh -c /etc/rc0.d/K01openbsd-inetd stop\n</code></pre> <p>Files that do not match this pattern are started similarly but without the extra command line argument.</p>"},{"location":"config/sysv/#startstop-scripts","title":"Start/Stop Scripts","text":"<p>For syntax details, see SysV Init Scripts, above. Here follows an example taken from a Debian installation:</p> <pre><code>sysv [2345] &lt;pid/syslogd&gt; /etc/init.d/openbsd-inetd -- OpenBSD inet daemon\n</code></pre> <p>The init script header could be parsed to extract <code>Default-Start:</code> and other parameters for the <code>sysv</code> command to Finit.  There is currently no way to detail a generic syslogd dependency in Finit, so <code>Should-Start:</code> in the header must be mapped to the condition system in Finit using an absolute reference, here we depend on the sysklogd project's syslogd.</p>"},{"location":"config/sysv/#etcrclocal","title":"<code>/etc/rc.local</code>","text":"<p>One often requested feature, early on, was a way to run a site specific script to set up, e.g., static routes or firewall rules.  A user can add a <code>task</code> or <code>run</code> command in the Finit configuration for this, but for compatibility reasons the more widely know <code>/etc/rc.local</code> is used if it exists, and is executable.  It is called very late in the boot process when the system has left runlevel S, stopped all old and started all new services in the target runlevel (default 2).</p> <p>In Finit releases before v4.5 this script blocked Finit execution and made it as good as impossible to call <code>initctl</code> during that time.</p>"},{"location":"config/sysv/#init-q","title":"<code>init q</code>","text":"<p>When <code>/sbin/finit</code> is installed as <code>/sbin/init</code>, it is possible to use <code>init q</code> to reload the configuration.  This is the same as calling <code>initctl reload</code>.</p>"},{"location":"config/task-and-run/","title":"One-shot Tasks","text":""},{"location":"config/task-and-run/#run-sequence","title":"run (sequence)","text":"<p>Syntax: <code>run [LVLS] &lt;COND&gt; /path/to/cmd ARGS -- Optional description</code></p> <p><code>&lt;COND&gt;</code> is described in the Services section.</p> <p>One-shot command to run in sequence when entering a runlevel, with optional arguments and description.  <code>run</code> commands are guaranteed to be completed before running the next command.  Useful when serialization is required.</p> <p>Warning</p> <p>Try to avoid the <code>run</code> command.  It blocks much of the functionality in Finit, like (re)starting other (perhaps crashing) services while a <code>run</code> task is executing.  Use other synchronization mechanisms instead, like conditions.</p> <p>Incomplete list of unsupported <code>initctl</code> commands in <code>run</code> tasks:</p> <ul> <li><code>initctl runlevel N</code>, setting runlevel</li> <li><code>initctl reboot</code></li> <li><code>initctl halt</code></li> <li><code>initctl poweroff</code></li> <li><code>initctl suspend</code></li> </ul> <p>To prevent <code>initctl</code> from calling Finit when enabling and disabling services from inside a <code>run</code> task, use the <code>--force</code> option.  See also the <code>--quiet</code> and <code>--batch</code> options.</p>"},{"location":"config/task-and-run/#task-parallel","title":"task (parallel)","text":"<p>Syntax: <code>task [LVLS] &lt;COND&gt; /path/to/cmd ARGS -- Optional description</code></p> <p><code>&lt;COND&gt;</code> is described in the Services section.</p> <p>One-shot like 'run', but starts in parallel with the next command.</p> <p>Both <code>run</code> and <code>task</code> commands are run in a shell, so basic pipes and redirects can be used:</p> <pre><code>task [s] echo \"foo\" | cat &gt;/tmp/bar\n</code></pre> <p>Please note, <code>;</code>, <code>&amp;&amp;</code>, <code>||</code>, and similar are not supported.  Any non-trivial constructs are better placed in a separate shell script.</p>"},{"location":"config/templating/","title":"Templating","text":"<p>Finit comes with rudimentary support for templating, similar to that of systemd.  Best illustrated with an example:</p> <pre><code>$ initctl show avahi-autoipd@\nservice :%i avahi-autoipd --syslog %i -- ZeroConf for %i\n</code></pre> <p>To enable ZeroConf for, e.g., <code>eth0</code>, use</p> <pre><code>$ initctl enable avahi-autoipd@eth0.conf\n</code></pre> <p>The enabled symlink will be set up to <code>avahi-autoipd@.conf</code> and every instance of <code>%i</code> will in the instantiated directive be replaced with <code>eth0</code>.  Inspect the resulting instantiated template with <code>initctl show avahi-autoipd:eth0</code> and check the status of a running instance with:</p> <pre><code>$ initctl status avahi-autoipd:eth0\n     Status : running\n   Identity : avahi-autoipd:eth0\nDescription : ZeroConf for eth0\n     Origin : /etc/finit.d/enabled/avahi-autoipd@eth0.conf\nEnvironment : -/etc/default/avahi-autoipd-eth0\n    Command : avahi-autoipd $AVAHI_AUTOIPD_ARGS eth0\n   PID file : /run/avahi-autoipd.eth0.pid\n        PID : 4190\n       User : root\n      Group : root\n     Uptime : 24 sec\n   Restarts : 0 (0/10)\n  Runlevels : [---2345-789]\n     Memory : 20.0k\n     CGroup : /system/avahi-autoipd@eth0 cpu 0 [100, max] mem [0, max]\n              \u2514\u2500 4190 avahi-autoipd: [eth0] bound 169.254.1.9  \n\nJul  8 11:51:42 infix-c0-ff-ee finit[1]: Starting avahi-autoipd:eth0[4190]\n</code></pre>"},{"location":"config/tty/","title":"TTYs and Consoles","text":"<p>Syntax: <code>tty [LVLS] &lt;COND&gt; DEV [BAUD] [noclear] [nowait] [nologin] [TERM]</code> <code>tty [LVLS] &lt;COND&gt; CMD &lt;ARGS&gt; [noclear] [nowait]</code> <code>tty [LVLS] &lt;COND&gt; [notty] [rescue]</code></p> <p>The first variant of this option uses the built-in getty on the given TTY device DEV, in the given runlevels.  DEV may be the special keyword <code>@console</code>, which is expanded from <code>/sys/class/tty/console/active</code>, useful on embedded systems.</p> <p>The default baud rate is 0, i.e., keep kernel default.</p> <p>The <code>tty</code> stanza inherits runlevel, condition (and other feature) parsing from the <code>service</code> stanza.  So TTYs can run in one or many runlevels and depend on any condition supported by Finit.  This is useful e.g. to depend on <code>&lt;pid/elogind&gt;</code> before starting a TTY.</p> <p>Example:</p> <pre><code>tty [12345] /dev/ttyAMA0 115200 noclear vt220\n</code></pre> <p>The second <code>tty</code> syntax variant is for using an external getty, like agetty or the BusyBox getty.</p> <p>The third variant is for board bringup and the <code>rescue</code> boot mode.  No device node is required in this variant, the same output that the kernel uses is reused for stdio.  If the <code>rescue</code> option is omitted, a shell is started (<code>nologin</code>, <code>noclear</code>, and <code>nowait</code> are implied), if the rescue option is set the bundled <code>/libexec/finit/sulogin</code> is started to present a bare-bones root login prompt.  If the root (uid:0, gid:0) user does not have a password set, no rescue is possible.  For more information, see the Rescue Mode section.</p> <p>By default, the first two syntax variants clear the TTY and wait for the user to press enter before starting getty.</p> <p>Example:</p> <pre><code>tty [12345] /sbin/getty  -L 115200 /dev/ttyAMA0 vt100\ntty [12345] /sbin/agetty -L ttyAMA0 115200 vt100 nowait\n</code></pre> <p>The <code>noclear</code> option disables clearing the TTY after each session. Clearing the TTY when a user logs out is usually preferable.</p> <p>The <code>nowait</code> option disables the <code>press Enter to activate console</code> message before actually starting the getty program.  On small and embedded systems running multiple unused getty wastes both memory and CPU cycles, so <code>wait</code> is the preferred default.</p> <p>The <code>nologin</code> option disables getty and <code>/bin/login</code>, and gives the user a root (login) shell on the given TTY <code>&lt;DEV&gt;</code> immediately. Needless to say, this is a rather insecure option, but can be very useful for developer builds, during board bringup, or similar.</p> <p>Notice the ordering, the <code>TERM</code> option to the built-in getty must be the last argument.</p> <p>Embedded systems may want to enable automatic <code>DEV</code> by supplying the special <code>@console</code> device.  This works regardless weather the system uses <code>ttyS0</code>, <code>ttyAMA0</code>, <code>ttyMXC0</code>, or anything else.  Finit figures it out by querying sysfs: <code>/sys/class/tty/console/active</code>.  The speed can be omitted to keep the kernel default.</p> <p>Most systems get by fine by just using <code>console</code>, which will evaluate to <code>/dev/console</code>.  If you have to use <code>@console</code> to get any output, you may have some issue with your kernel config.</p> <p>Example:</p> <pre><code>tty [12345] @console noclear vt220\n</code></pre> <p>On really bare bones systems, or for board bringup, Finit can give you a shell prompt as soon as bootstrap is done, without opening any device node:</p> <pre><code>tty [12345789] notty\n</code></pre> <p>This should of course not be enabled on production systems.  Because it may give a user root access without having to log in.  However, for board bringup and system debugging it can come in handy.</p> <p>One can also use the <code>service</code> stanza to start a stand-alone shell:</p> <pre><code>service [12345] /bin/sh -l\n</code></pre>"}]}