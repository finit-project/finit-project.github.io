{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Reverse engineered from the EeePC fastinit \"gaps filled with frog DNA \u2026\" \u2014 Claudio Matsuoka</p> <p>Finit is a process starter and supervisor designed to run as PID 1 on Linux systems.  It consists of a set of plugins and can be set up using configuration files.  Plugins start at hook points and can run various set up tasks and/or install event handlers that later provide runtime services, e.g., PID file monitoring, or conditions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Runlevels, defined per service</li> <li>One-shot tasks, services (daemons), or SysV init start/stop scripts</li> <li>Runparts and <code>/etc/rc.local</code> support</li> <li>Process supervision similar to systemd</li> <li>Fine-grained privilege control:<ul> <li>Linux capabilities for minimal required privileges</li> <li>Supplementary groups for multi-group resource access</li> </ul> </li> <li>Sourcing environment files</li> <li>Conditions for network/process/custom dependencies</li> <li>Readiness notification; PID files (native) for synchronizing system     startup, support for systemd sd_notify(), or s6 style too</li> <li>Limited support for tmpfiles.d(5) (no aging, attributes, or subvolumes)</li> <li>Pre/Post script actions</li> <li>Rudimentary templating support</li> <li>Tooling to enable/disable services</li> <li>Automatic reload of modified configuration files (optional)</li> <li>Built-in getty</li> <li>Built-in watchdog, with support for hand-over to watchdogd</li> <li>Built-in support for Debian/BusyBox <code>/etc/network/interfaces</code></li> <li>Cgroups v2, both configuration and monitoring in <code>initctl top</code></li> <li>Plugin support for customization</li> <li>Proper rescue mode with bundled <code>sulogin</code> for protected maintenance shell</li> <li>Switch root support for initramfs-to-real-root transitions</li> <li>Integration with watchdogd for full system supervision</li> <li>Logging to kernel ring buffer before <code>syslogd</code> has started, see the     recommended sysklogd project for complete logging integration     and how to log to the kernel ring buffer from scripts using <code>logger</code></li> </ul> <p>For a more thorough overview, see the Features section.</p> <p>Tip</p> <p>See SysV Init Compatibility for help to quickly get going with an existing SysV or BusyBox init setup.</p>"},{"location":"#origin","title":"Origin","text":"<p>This project is based on the original finit by Claudio Matsuoka which was reverse engineered from syscalls of the EeePC fastinit.</p> <p>Finit is developed and maintained by Joachim Wiberg at GitHub. Please file bug reports, clone it, or send pull requests for bug fixes and proposed extensions.</p>"},{"location":"build/","title":"Building","text":""},{"location":"build/#building-finit","title":"Building Finit","text":"<p>Finit comes with a traditional configure script to control features and optional plugins to enable.  It depends on two external libraries:</p> <ul> <li>libuEv, the event loop</li> <li>libite (-lite), much needed frog DNA</li> </ul> <p>Important</p> <p>Most free/open source software packages that use <code>configure</code> default to install to <code>/usr/local</code>.  However, some Linux distributions do no longer search that path for installed software, e.g. Fedora and Alpine Linux.  To get finit's configure script to find its dependencies you have to help the <code>pkg-config</code> tool a bit if you do not change the default prefix path:</p> <pre><code>PKG_CONFIG_LIBDIR=/usr/local/lib/pkgconfig ./configure\n</code></pre> <p>The configure script checks for all dependencies, including the correct version of the above mentioned libraries.  Currently required versions:</p> <ul> <li>libite v2.2.0, or later</li> <li>libuEv v2.2.0, or later</li> </ul>"},{"location":"build/#configure","title":"Configure","text":"<p>Below are a few of the main switches to configure:</p> <ul> <li> <p><code>--prefix=..</code>: Usually you want to set this to <code>/usr</code>, default is the GNU   default: <code>/usr/local</code></p> </li> <li> <p><code>--exec-prefix=..</code>: This you want to set to the empty string, or <code>/</code>, to   ensure the programs <code>finit</code> and <code>initctl</code> are installed to the proper   locations.  Linux expects an \"init\" in <code>/sbin</code>, default: <code>--prefix</code></p> </li> <li> <p><code>--sysconfdir=..</code>: follows <code>--prefix</code>, you likely want it to be <code>/etc</code></p> </li> <li> <p><code>--localstatedir=..</code>: follows <code>--prefix</code>, you likely want <code>/var</code></p> </li> <li> <p><code>--enable-static</code>: Build Finit statically.  The plugins will be   built-ins (.o files) and all external libraries, except the C library   will be linked statically.</p> </li> <li> <p><code>--enable-kernel-cmdline</code>: Enable Finit pre-4.1 parsing of init args from   <code>/proc/cmdline</code>, this is not recommended since Finit may be running as the   init for container apps that can see the host's <code>/proc</code> filesystem</p> </li> <li> <p><code>--enable-alsa-utils-plugin</code>: Enable the optional <code>alsa-utils.so</code> sound plugin.</p> </li> <li> <p><code>--enable-dbus-plugin</code>: Enable the optional D-Bus <code>dbus.so</code> plugin.</p> </li> <li> <p><code>--enable-resolvconf-plugin</code>: Enable the <code>resolvconf.so</code> optional plugin.</p> </li> <li> <p><code>--enable-x11-common-plugin</code>: Enable the optional X Window <code>x11-common.so</code> plugin.</p> </li> <li> <p><code>--with-sulogin</code>: Enable bundled <code>sulogin</code> program.  Default is to use the   system <code>sulogin(8)</code>.  The sulogin shipped with Finit allows password-less   login if the <code>root</code> user is disabled or has no password at all.</p> </li> </ul> <p>For more configure flags, see ./configure --help</p> <p>Note</p> <p>The configure script is not available in the GIT sources.  It is however included in (officially supported) released tarballs.  The idea is that you should not need GNU autotools to build, only the above mentioned dependencies, a POSIX shell, a C compiler and make. Any contributing to Finit can generate it from <code>configure.ac</code> using the <code>autogen.sh</code> script.</p>"},{"location":"build/#example","title":"Example","text":"<p>First, unpack the archive:</p> <pre><code>$ tar xf finit-4.3.tar.gz\n$ cd finit-4.3/\n</code></pre> <p>Then configure, build and install:</p> <pre><code>$ ./configure --prefix=/usr                 --exec-prefix=         \\\n              --sysconfdir=/etc             --localstatedir=/var   \\\n              --with-keventd                --with-watchdog\n$ make\n.\n.\n.\n$ DESTDIR=/tmp/finit make install\n</code></pre> <p>In this example the finit-4.3.tar.gz archive is unpacked to the user's home directory, configured, built and installed to a temporary staging directory.  The environment variable <code>DESTDIR</code> controls the destination directory when installing, very useful for building binary standalone packages.</p> <p>Finit 4.1 and later can detect if it runs on an embedded system, or a system that use BusyBox tools instead of udev &amp; C:o.  On such systems <code>mdev</code> instead of <code>udev</code> is used.  However, remember to also change the Linux config to:</p> <pre><code>CONFIG_UEVENT_HELPER_PATH=\"/sbin/mdev\"\n</code></pre> <p>Tip</p> <p>If you run into problems starting Finit, take a look at <code>finit.c</code>. One of the most common problems is a custom Linux kernel build that lack <code>CONFIG_DEVTMPFS</code>.  Another is too much cruft in the system <code>/etc/fstab</code>.</p>"},{"location":"build/#running","title":"Running","text":"<p>Having successfully built Finit it is now be time to take it for a test drive.  The <code>make install</code> attempts to set up finit as the system system init, <code>/sbin/init</code>, but this is usually a symlink pointing to the current init.</p> <p>So either change the symlink, or change your boot loader (GRUB, LOADLIN, LILO, U-Boot/Barebox or RedBoot) configuration to append the following to the kernel command line:</p> <pre><code>append=\"init=/sbin/finit\"\n</code></pre> <p>Remember to also set up an initial <code>/etc/finit.conf</code> before rebooting!</p>"},{"location":"build/#recovery","title":"Recovery","text":"<p>To rescue a system with Finit, append the following to the kernel command line:</p> <pre><code>append=\"init=/sbin/finit rescue\"\n</code></pre> <p>This tells Finit to start in a very limited recovery mode, no services are loaded, no filesystems are mounted or checked, and no networking is enabled.  The default Finit rescue mode configuration is installed into <code>/lib/finit/rescue.conf</code>, which can be safely removed or changed.</p> <p>By default the a root shell, without login, is started.</p> <p>Important</p> <p>In rescue mode <code>initctl</code> will not work, the same goes for <code>reboot</code>, <code>shutdown</code>, and <code>poweroff</code> commands, provided they are the Finit versions of these commands.  Use the <code>-f</code> flag to force the action.</p>"},{"location":"build/#debugging","title":"Debugging","text":"<p>Edit, or append to, the kernel command line: remove <code>quiet</code> to enable kernel messages and add <code>finit.debug</code> to enable Finit debug messages.</p> <pre><code>append=\"init=/sbin/finit -- finit.debug\"\n</code></pre> <p>Notice the <code>--</code> separator.</p> <p>To debug startup issues, in particular issues with getty/login, add the following to your Finit .conf file:</p> <pre><code>tty [12345789] notty noclear\n</code></pre> <p>The <code>notty</code> option ensures reusing the stdin/stdout set up by the kernel.  Remember, this is only for debugging and would leave your production system potentially wide open.</p> <p>There is also a rescue shell available, in case Finit crashes and the kernel usually reboots: <code>configure --enable-emergency-shell</code>.  However, the behavior of Finit is severely limited when this is enabled, so use it only for debugging start up issues when Finit crashes.</p> <p>Caution</p> <p>None of these options should be enabled on production systems since they can potentially give a user root access.</p>"},{"location":"cmdline/","title":"Command Line Options","text":""},{"location":"cmdline/#tips-tricks-with-the-kernel-cmdline","title":"Tips &amp; Tricks with the kernel cmdline","text":"<p>This document summarizes the different boot parameters that can be passed on the Linux kernel command line.  Not limited to Finit.</p> <p>Important</p> <p>Remember to use <code>--</code> to separate kernel parameters from parameters to init.  E.g., <code>init=/sbin/finit -- finit.debug rescue</code></p> <p>The <code>bool</code> setting is one of <code>on, off, true false, 1, 0</code>.</p> <ul> <li> <p><code>debug</code>: Enable kernel debug.  Debug messages are printed to the    console until Finit starts up, unless <code>loglevel=7</code> (below) is used.</p> </li> <li> <p><code>fsck.mode=&lt;auto,force,skip&gt;</code>, default: <code>auto</code>, unless built with   <code>configure --enable-fastboot</code>, in which case the default is <code>skip</code></p> </li> <li> <p><code>fsck.repair=&lt;preen,yes,no&gt;</code>, default: <code>preen</code>, unless built with   <code>configure --enable-fsckfix</code>, in which case the default is <code>yes</code>.   This configure option also sets <code>fsck.mode=force</code>, unless fastboot   is selected at the same time.  I.e., the <code>--enable-fastboot</code> build   option overrides the <code>fsck.mode</code> default value.</p> </li> <li> <p><code>finit.cond=foo[,bar[,baz]]</code>: set <code>&lt;boot/foo&gt;</code> condition, optionally   multiple conditions can be set using the same option, separated with a   comma.  Alternatively, multiple <code>foo.cond=arg</code> can be given.  Each will   result in a <code>&lt;boot/arg&gt;</code> condition being set to control the rest of the   system bootstrap.</p> </li> </ul> <p>Very useful for selecting different boot modes, e.g. manufacturing test,   firmware upgrade, or rescue mode.</p> <p>Note</p> <p><code>&lt;boot/...&gt;</code> conditions cannot be cleared with <code>initctl</code>!</p> <ul> <li><code>finit.config=/path/to/alternative/finit.conf</code>: override the   compile-time bootstrap config file, default:<pre><code>./configure --with-config=/etc/finit.conf\n</code></pre> </li> </ul> <p>Useful when starting up in various rescue mode, factory, or    production test setups.  Use the top-level configuration file    directive <code>rcsd /path/to/finit.d</code> to override the default rcS.d    directory.</p> <ul> <li> <p><code>finit.debug[=bool]</code>: Enable finit debug.  This is operated     independently of the kernel <code>debug</code> setting.  New as of Finit v4.</p> </li> <li> <p><code>finit.fstab=&lt;/path/to/etc/fstab.alternative&gt;</code>: Tell Finit to use an   alternate <code>fstab</code> to mount the file system from.  Remember, this file   must be on the <code>root=...</code> file system provided to Finit from the   kernel.  By default the built-in fstab is used, which itself defaults   to <code>/etc/fstab</code>, but can be changed at build time with:</p> <pre><code>./configure --with-fstab=/path/to/fstab\n</code></pre> </li> </ul> <p>It is even possible to disable a built-in default using:</p> <pre><code>    ./configure --without-fstab\n</code></pre> <p>Making <code>finit.fstab=/path/to/fstab</code> a mandatory command line option.   Note, if the command line fstab is missing, Finit falls back to the   built-in fstab, and if both are missing, the system treats this as a   bad <code>fsck</code> and thus calls <code>sulogin</code>.  If, in turn, <code>sulogin</code> is not   available on the system, Finit calls reboot, which is also what will   happen when a user exits from <code>sulogin</code>.</p> <ul> <li> <p><code>finit.status[=bool]</code>: Control finit boot progress, including banner.   (Used to be <code>finit.show_status</code>, which works but is deprecated.)</p> </li> <li> <p><code>finit.status_style=&lt;classic,modern&gt;</code>: Set Finit boot progress style,   when enabled.</p> </li> <li> <p><code>init=/bin/sh</code>: Bypass system default init and tell kernel to start a     shell.  Note, this shell is very limited and does not support     signals and has no job control.  Recommend using, and modifying,     <code>rescue</code> mode instead.</p> </li> <li> <p><code>loglevel=&lt;0-7&gt;</code>, sets the kernel's log level, which is more granular   than <code>debug</code>.  Also, when <code>loglevel=7</code>, Finit will not disable   kernel logs to the console.  This is very useful when debugging the   kernel at system bring-up.  Since <code>loglevel=7</code> is the same as <code>debug</code>   this means you have to use <code>quiet</code> for a quiet boot, until sysklogd   takes over logging of kernel events.</p> </li> <li> <p><code>panic=SEC</code>: By default the kernel does not reboot after a kernel     panic.  This setting will cause a kernel reboot after SEC seconds.</p> </li> <li> <p><code>quiet</code>: Suppress kernel logging to console, except for warnings and   errors.  Also, see <code>loglevel</code> and <code>quiet</code> above.</p> </li> <li> <p><code>rescue</code>: Start rescue/maintenance mode.  If your system     comes with the bundled <code>sulogin</code> program (Finit, or from util-linux,     or Busybox), you will be given a root login to a maintenance shell.     However, if <code>sulogin</code> is missing, the file <code>/lib/finit/rescue.conf</code>     is read and the system booted in a limited fallback mode.</p> <p>This option can be disabled with <code>configure --without-rescue</code></p> <p>Note: in this mode <code>initctl</code> will not work.  Correct the problem and use <code>reboot -f</code> to force reboot.</p> </li> <li> <p><code>single</code>, or <code>S</code>: Overrides the configured runlevel (default: 2) to go     to after bootstrap by forcing it to runlevel 1, this is also known     as single user mode.  Useful to debug startup problems.  All services     and TTYs in <code>[1]</code> will be started, so a <code>tty [1] @console nologin</code>     configuration presents you with a root console without login.</p> </li> <li> <p><code>1-9</code>, except <code>6</code>: override the configured <code>runlevel</code>.  Like the <code>S</code>    and <code>rescue</code>, giving a single number on the kernel command line tells    Finit to ignore any <code>runlevel</code> in <code>/etc/finit.conf</code> as well as the    configure fallback <code>--with-runlevel=N</code> setting.  Remember, <code>6</code> is the    reboot runlevel and is not permitted.  Any other values are ignored.</p> </li> </ul> <p>For more on kernel boot parameters, see the man page bootparam(7).</p>"},{"location":"commands/","title":"Rebooting & Halting","text":""},{"location":"commands/#rebooting-halting","title":"Rebooting &amp; Halting","text":"<p>Traditionally, rebooting and halting a UNIX system is done by switching to the corresponding runlevel (0 or 6).  Over time this has changed and Finit comes with its own tooling providing: <code>shutdown</code>, <code>reboot</code>, <code>poweroff</code>, and <code>suspend</code>.  These commands are also available from the <code>initctl</code> tool.</p> <p>For compatibility reasons Finit listens to the same set of signals as BusyBox init.  This is not 100% compatible with SysV init, but clearly the more common combination for Finit.  For more details, see the Signal section.</p>"},{"location":"conditions/","title":"Conditions","text":""},{"location":"conditions/#conditions","title":"Conditions","text":"<p>Conditions were added to Finit in v3 with the intention of providing a mechanism for common synchronization problems.  For example:</p> <ul> <li>\"wait for service A to start before starting service B\", or</li> <li>\"wait for basic network access to be available\"</li> </ul> <p>Conditions are similar in syntax to declaring runlevels per service. They are specified within angle brackets <code>&lt;&gt;</code> and can be applied to any of the <code>service</code>, <code>task</code>, or <code>run</code> stanza.  Multiple conditions may be specified separated by comma.  Multiple conditions are logically AND'ed during evaluation, i.e. all conditions must be satisfied in order for a service to run.</p> <p>A special syntax, using a leading <code>!</code> in run/task/service conditions, denote if a:</p> <ul> <li>service does not support <code>SIGHUP</code></li> <li>run/task should not block runlevel changes (i.e., bootstrap)</li> </ul> <p>Finit guarantees by default that all run/tasks run (at least) once per runlevel.  For most tasks this is a good default, for example checking SSH host keys or loading keymap.  However, for conditions that are unlikely to happen it is not. (See example below.)</p>"},{"location":"conditions/#example","title":"Example","text":"<pre><code>service [2345] &lt;pid/setupd,pid/zebra&gt; /sbin/netd -- Network monitor\n</code></pre> <p>In this example the Network monitor daemon <code>netd</code> is not started until both the <code>pid/setupd</code> and <code>pid/zebra</code> conditions are satisfied.  A <code>pid/</code> condition is satisfied by the corresponding service's PID file being created, i.e., the service's default readiness notification.</p> <p>Important</p> <p>Conditions also stop services when a condition is no longer asserted. I.e., if the <code>zebra</code> process above stops or restarts, <code>netd</code> will also stop or restart.</p> <p>Another example is <code>dropbear</code>, it does not support <code>SIGHUP</code>, but we can also see optional sourcing of arguments from an environment file:</p> <pre><code>service [2345789] &lt;!&gt; env:-/etc/default/dropbear dropbear -F -R $DROPBEAR_ARGS -- Dropbear SSH daemon\n</code></pre> <p>Finally, the weird \"block runlevel changes\" example.  Here we see what happens when Finit receives <code>SIGPWR</code>, sent from a power daemon like powstatd(8).  A condition is asserted and a user can set up their own task to act on it.  We do not want this task to block Finit from moving to the next runlevel after bootstrap, so we set <code>&lt;!&gt;</code>:</p> <pre><code>task [S0123456789] &lt;!sys/pwr/fail&gt; name:pwrfail initctl poweroff -- Power failure, shutting down\n</code></pre>"},{"location":"conditions/#triggering","title":"Triggering","text":"<p>Conditions are mainly triggered (asserted) by built-in plugins, e.g.,</p> <ul> <li><code>netlink.so</code>: provides <code>&lt;net/...&gt;</code></li> <li><code>pidfile.so</code>: provides <code>&lt;pid/...&gt;</code></li> <li>Cmdline <code>finit.cond=arg</code>: provides <code>&lt;boot/arg&gt;</code></li> </ul> <p>See below for built-in conditions.  Finit also supports user-defined conditions, sometimes referred to as static or one-shot conditions. They live in the <code>&lt;usr/...&gt;</code> namespace and are constrained to a flat hierarchy without any sub-directories, unlike the pidfile plugin, for instance.</p> <p>User-defined conditions are controlled using the <code>initctl cond set</code> and <code>initctl cond clear</code> commands:</p> <pre><code>initctl cond set foo\ninitctl cond clear foo\n</code></pre> <p>The purpose of user-defined conditions is to be able to start or stop services, or run/task jobs, on external site-dependent stimuli.</p> <p>Example:</p> <pre><code>service [2345] &lt;usr/foo&gt; alarm --arg foo -- Foo alarm\n</code></pre> <p>For convenience, prefixing with <code>usr/</code> is allowed, but any other slashes or period characters are disallowed.  E.g., to trigger the <code>Foo alarm</code>, the same as above, can also be achieved like this:</p> <pre><code>initctl cond set usr/foo\ninitctl cond clear usr/foo\n</code></pre> <p>Conditions retain their current state until the next reconfiguration or runlevel change.  At that point all set conditions transition into the <code>flux</code> state, meaning the condition's state is unknown.  (For more info on this, see Internals.)  Thus, after a reconfiguration it is up to the \"owner\" of the condition to convey the new (or possibly unchanged) state of it.</p> <p>Static (one-shot) conditions, like <code>usr/</code>, never enter the <code>flux</code> state.</p> <p>Important</p> <p>For <code>pid/</code> conditions it is expected that the service reassert, i.e., \"touch\" or recreate, their PID file on <code>SIGHUP</code>.  This can be done by calling <code>utimensat()</code> on the PID file.  Provided, of course, that the service supports reloading on <code>SIGHUP</code>, otherwise it will be restarted by Finit when they instead exit on the signal.  For such services, use <code>&lt;!&gt;</code> to tell Finit the service does not support <code>SIGHUP</code>.</p>"},{"location":"conditions/#built-in-conditions","title":"Built-in Conditions","text":"<p>Finit comes with a set of plugins for conditions:</p> <ul> <li><code>devmon</code> (built-in)</li> <li><code>netlink</code></li> <li><code>pidfile</code></li> <li><code>sys</code></li> <li><code>usr</code></li> </ul> <p>The <code>devmon</code> (built-in) plugin monitors <code>/dev</code> and <code>/dev/dir</code> for device nodes being created and removed.  It is active only when a run, task, or service has declared a <code>&lt;dev/foo&gt;</code> or <code>&lt;dev/dir/bar&gt;</code> condition.</p> <p>The <code>pidfile</code> plugin (recursively) watches <code>/run/</code> (recursively) for PID files created by the monitored services, and sets a corresponding condition in the <code>pid/</code> namespace.</p> <p>Similarly, the <code>netlink</code> plugin provides basic conditions for when an interface is brought up/down and when a default route (gateway) is set, in the <code>net/</code> namespace.</p> <p>The <code>sys</code> and <code>usr</code> plugins monitor are passive condition monitors where the action is provided by <code>keventd</code>, signal handlers, and in the case of <code>usr</code>, the end-user via the <code>initctl</code> tool.</p> <p>Additionally, the various states of a run/task/sysv/service can also be used as conditions, the image above shows the state names.  The syntax for a <code>service</code> type process: <code>&lt;service/foo/STATE&gt;</code>.  The other types, in particular run/task/sysv, there are the additional states <code>success</code> and <code>failure</code>.</p> <p>With the example listed above, finit does not start the <code>/sbin/netd</code> daemon until <code>setupd</code> and <code>zebra</code> has started and created their PID files.  Which they do when they have completed their initial set up and are ready to receive signals.</p> <p>Finit expects monitored services to touch their PID files, i.e. update the mtime, when they reload their configuration files after a <code>SIGHUP</code>. Some services do not support <code>SIGHUP</code> and are instead restarted, which is a crude but effective way to have the PID file touched (re-created).</p> <p>Built-in conditions:</p> <ul> <li><code>pid/&lt;SERVICE&gt;</code></li> <li><code>net/route/default</code></li> <li><code>net/&lt;IFNAME&gt;/exist</code></li> <li><code>net/&lt;IFNAME&gt;/up</code></li> <li><code>net/&lt;IFNAME&gt;/running</code></li> <li><code>service/&lt;NAME[:ID]&gt;/&lt;STATE&gt;</code></li> <li><code>{run, task, sysv}/&lt;NAME[:ID]&gt;/{&lt;STATE&gt;, success, failure}</code></li> <li><code>sys/pwr/ac</code></li> <li><code>sys/pwr/fail</code></li> <li><code>sys/key/ctrlaltdel</code></li> <li><code>usr/foo</code></li> <li><code>boot/arg</code></li> <li><code>dev/node</code> and <code>dev/dir/node</code></li> </ul> <p>Note</p> <p>Here, <code>up</code> means administratively up, the interface flag <code>IFF_UP</code>. <code>running</code> is the <code>IFF_RUNNING</code> flag, meaning operatively up.  The difference is that <code>running</code> tells if the NIC has link.</p>"},{"location":"conditions/#composition","title":"Composition","text":"<p>The <code>pid/</code> conditions are generated by the Finit <code>pidfile.so</code> plugin and composed from a service's <code>name:</code> and <code>:id</code>.  By default the basename of the daemon and the empty string.</p> service condition /sbin/foo pid/foo /sbin/bar -p /run/baz.pid pid/bar name:lxc :foo lxc-start -n foo -p /run/lxc/foo.pid pid/lxc:foo /usr/bin/dbus-daemon pid/dbus-daemon :222 dropbear -p 222 pid/dropbear:222 <p>The condition is asserted when <code>pidfile.so</code> receives an inotify event for a file matching <code>/run/*.pid</code>, <code>/run/**/*.pid</code>, or <code>/run/**/pid</code>, which contains the PID of the service Finit has started.</p> <p>When Finit configuration files are changed and the <code>initctl reload</code> command is called, it is expected of services to touch their PID files for Finit to reassert their conditions.</p> <p>Daemons that don't create PID files, or fail to touch them on reload, can be worked around by using the <code>pid:/path/to/file.pid</code> syntax in the service stanza for the daemon.  It is far from optimal since any synchronization of depending services may fail due to the daemon not having reinitialized/created their IPC sockets, or similar.</p> <p>Note</p> <p>In versions of Finit prior to v4, the PID conditions were called 'svc' conditions, and they were far more complex.</p>"},{"location":"conditions/#debugging","title":"Debugging","text":"<p>If a service is not being started as it should, the problem might be that one of its conditions is not in the expected state.  Use the command <code>initctl status</code> to inspect service status.  Services in the <code>waiting</code> state are pending a condition.</p> <p>In that situation, running <code>initctl cond show</code> reveals which of the conditions that are not satisfied.  Listed as <code>off</code> below.</p> <p>Example:</p> <pre><code>~ # initctl cond show\nPID     IDENT         STATUS  CONDITION (+ ON, ~ FLUX, - OFF)\n=======================================================================\n1419    /sbin/netd    on      &lt;+pid/setupd,+pid/zebra&gt;\n0       /sbin/udhcpc  off     &lt;-net/vlan1/exist&gt;\n</code></pre> <p>Here we can see that <code>netd</code> is allowed to run since both its conditions are in the <code>on</code> state, as indicated by the <code>+</code>-prefix.  <code>udhcpc</code> however is not allowed to run since <code>net/vlan1/exist</code> condition is not satisfied. As indicated by the <code>-</code>-prefix.</p> <p>To fake interface <code>vlan1</code> suddenly appearing, and test what happens to <code>udhcpc</code> we can enable debug mode and assert the condition, like this:</p> <pre><code>~ # initctl debug\n~ # mkdir -p /var/run/finit/cond/net/vlan1\n~ # cp /var/run/finit/cond /var/run/finit/cond/net/vlan1/exist\n</code></pre> <p>Then watch the console for the debug messages and then check the output from <code>initctl cond show</code> again.  The client will likely have failed to start, but at least the condition is now satisfied.</p> <p>There is also the <code>initctl cond dump</code> command, which dumps all known conditions, their current status, and their origin.</p>"},{"location":"conditions/#internals","title":"Internals","text":"<p>As shown previously, conditions are implemented as simple files in the file system, in the <code>/var/run/finit/cond/</code> sub-directory.  The files are created, updated, and removed by condition plugins.  To debug them, see the previous section.</p> <p>A condition is always in one of three states:</p> <ul> <li><code>on</code> (+): The condition is asserted.</li> <li><code>off</code> (-): The condition is deasserted.</li> <li><code>flux</code> (~): The conditions state is unknown.</li> </ul> <p>All conditions that have not explicitly been set are interpreted as being in the <code>off</code> state.</p> <p></p> <p>When a reconfiguration is requested, Finit transitions all conditions to the <code>flux</code> state.  As a result, services that depend on a condition are sent <code>SIGSTOP</code>.  Once the new state of the condition is asserted, the service receives <code>SIGCONT</code>.  If the condition is no longer satisfied the service will then be stopped, otherwise no further action is taken.</p> <p>This STOP/CONT handling minimizes the number of unnecessary service restarts that would otherwise occur because a depending service was sent <code>SIGHUP</code> for example.</p> <p>Therefore, any plugin that supplies Finit with conditions must ensure that their state is updated after each reconfiguration.  This can be done by binding to the <code>HOOK_SVC_RECONF</code> hook.  For an example of how to do this, see <code>plugins/pidfile.c</code>.</p>"},{"location":"distro/","title":"Distributions","text":""},{"location":"distro/#distro-recommendations","title":"Distro Recommendations","text":"<p>Finit supports two directory layouts for managing service configurations:</p> <ol> <li>Simple layout - all configuration files directly in <code>/etc/finit.d/</code></li> <li>Distro layout - separate <code>available/</code> and <code>enabled/</code> directories</li> </ol> <p>The distro layout is recommended for distributions that need clear separation between installed and enabled services, and want to use the <code>initctl enable/disable</code> commands for service management.</p>"},{"location":"distro/#simple-layout","title":"Simple Layout","text":"<p>Finit supports using a flat directory structure:</p> <pre><code>    /etc/\n      |-- finit.d/              -- All enabled services\n      |    |-- lighttpd.conf\n      |     `- *.conf\n      |-- finit.conf            -- Bootstrap tasks and services\n      :\n</code></pre> <p>In this layout, you enable a service by placing its <code>.conf</code> file in <code>/etc/finit.d/</code> and disable it by removing the file. This works well for embedded systems or custom setups where services are managed by other tools or generated dynamically.</p> <p>No tooling support</p> <p>The <code>initctl enable/disable</code> commands do not work with this layout. You must manually manage files in <code>/etc/finit.d/</code>.</p>"},{"location":"distro/#distro-layout","title":"Distro Layout","text":"<p>Distributions typically want clearer separation between available (installed) and enabled services. Finit supports this through the <code>available/</code> and <code>enabled/</code> subdirectories:</p> <pre><code>    /etc/\n      |-- finit.d/\n      |    |-- available/      -- Installed but disabled services\n      |    |    |-- httpd.conf\n      |    |    |-- ntpd.conf\n      |    |    `-- sshd.conf\n      |    |-- enabled/        -- Enabled services (symlinks)\n      |    |     `- sshd.conf  -- Symlink to ../available/sshd.conf\n      |-- finit.conf           -- Bootstrap tasks and services\n      :\n</code></pre> <p>In this layout: - available/ contains all installed service configurations - enabled/ contains symlinks to configurations that should start at boot - Services are enabled/disabled by creating/removing symlinks</p> <p>Recommended</p> <p>This is the recommended layout.  In fact, the <code>initctl enable/disable</code> commands require this layout with both <code>available/</code> and <code>enabled/</code> directories and will not work without it.</p>"},{"location":"distro/#managing-services-with-initctl","title":"Managing Services with initctl","text":"<p>When using the distro layout, the <code>initctl</code> tool provides convenient commands for managing service configurations:</p> <pre><code>   list              List all .conf in /etc/finit.d/\n   enable   &lt;CONF&gt;   Enable .conf by creating symlink in enabled/\n   disable  &lt;CONF&gt;   Disable .conf by removing symlink from enabled/\n   reload            Reload *.conf in /etc/finit.d/ (activate changes)\n</code></pre> <p>Example usage:</p> <pre><code># Enable sshd (creates enabled/sshd.conf -&gt; ../available/sshd.conf)\ninitctl enable sshd\n\n# Disable httpd (removes enabled/httpd.conf symlink)\ninitctl disable httpd\n\n# Apply changes (reload configuration and start/stop services)\ninitctl reload\n</code></pre> <p>The <code>.conf</code> suffix is optional - <code>initctl</code> adds it automatically if missing.</p> <p>Remember <code>initctl reload</code></p> <p>Changes made with <code>enable</code>/<code>disable</code> take effect only after running <code>initctl reload</code>, unless Finit was built with <code>--enable-auto-reload</code> which automatically detects and applies configuration changes.</p>"},{"location":"distro/#service-overrides","title":"Service Overrides","text":"<p>The <code>initctl</code> tool only operates on symlinks in the <code>enabled/</code> directory. If you place a regular (non-symlink) <code>.conf</code> file directly in the parent directory (e.g., <code>/etc/finit.d/</code>), <code>initctl</code> will ignore it. This allows you to create system-level overrides that cannot be accidentally disabled by package management tools.</p>"},{"location":"distro/#customizing-directory-paths","title":"Customizing Directory Paths","text":"<p>Distributions can customize the directory names and locations at build time using the Finit <code>configure</code> script:</p> <pre><code>./configure --with-rcsd=/etc/init.d --with-config=/etc/init.d/init.conf\n</code></pre> <p>This changes the default <code>/etc/finit.d/</code> to <code>/etc/init.d/</code> and moves the bootstrap configuration file accordingly.</p> <p>Remember to set <code>--prefix</code></p> <p>Remember to set <code>--prefix</code> and related options appropriately. The default prefix is <code>/usr/local</code>, which is likely not what you want for a system init. See the build documentation for details.</p> <p>Example with custom paths:</p> <pre><code>    /etc/\n      |-- init.d/\n      |    |-- available/      -- Installed services\n      |    |    |-- httpd.conf\n      |    |    |-- ntpd.conf\n      |    |    `-- sshd.conf\n      |    |-- enabled/        -- Enabled services (symlinks)\n      |    |     `- sshd.conf  -- Symlink to ../available/sshd.conf\n      |     `- init.conf       -- Bootstrap tasks and services\n      :\n</code></pre> <p>Notice how both the service directory and bootstrap configuration file now use the custom <code>/etc/init.d/</code> path specified at build time.</p>"},{"location":"example/","title":"Quick Example","text":""},{"location":"example/#configuration-example","title":"Configuration Example","text":"<p>This example <code>/etc/finit.conf</code> can also be split up in multiple <code>.conf</code> files in <code>/etc/finit.d</code>.  Available, but not yet enabled, services can be placed in <code>/etc/finit.d/available</code> and enabled by an operator using the initctl tool.</p> <p>See the contrib/ directory on GitHub for examples, or take a peek at systems using Finit, like Infix OS and myLinux.</p> <p>Tip</p> <p>As of Finit v4.4, <code>.conf</code> lines can be broken up using the standard UNIX continuation character (<code>\\</code>), trailing comments are also supported.  The latter means you must escape any hashes used in directives and descriptions (<code>\\#</code>).  For more on this and examples, see the finit.conf(5) manual or the Configuration section.</p> <pre><code># Fallback if /etc/hostname is missing\nhost default\n\n# Runlevel to start after bootstrap, 'S', default: 2\n#runlevel 2\n\n# Support for setting global environment variables, using foo=bar syntax\n# be careful though with variables like PATH, SHELL, LOGNAME, etc.\n#PATH=/usr/bin:/bin:/usr/sbin:/sbin\n\n# Max file size for each log file: 100 kiB, rotate max 4 copies:\n# log =&gt; log.1 =&gt; log.2.gz =&gt; log.3.gz =&gt; log.4.gz\nlog size=100k count=4\n\n# Services to be monitored and respawned as needed\nservice [S12345] env:-/etc/conf.d/watchdog watchdog $WATCHDOG_OPTS $WATCHDOG_DEV -- System watchdog daemon\nservice [S12345] env:-/etc/conf.d/syslog syslogd -n $SYSLOGD_OPTS          -- System log daemon\nservice [S12345] &lt;pid/syslogd&gt; env:-/etc/conf.d/klogd klogd -n $KLOGD_OPTS -- Kernel log daemon\nservice   [2345] env:-/etc/conf.d/lldpd lldpd -d $LLDPD_OPTS               -- LLDP daemon (IEEE 802.1ab)\n\n# The BusyBox ntpd does not use syslog when running in the foreground\n# So we use this trick to redirect stdout/stderr to a log file.  The\n# log file is rotated with the above settings.  The condition declares\n# a dependency on a system default route (gateway) to be set.  A single\n# &lt;!&gt; at the beginning means ntpd does not respect SIGHUP for restart.\nservice [2345] log:/var/log/ntpd.log &lt;!net/route/default&gt; ntpd -n -l -I eth0 -- NTP daemon\n\n# For multiple instances of the same service, add :ID somewhere between\n# the service/run/task keyword and the command.\nservice :80   [2345] merecat -n -p 80   /var/www -- Web server\nservice :8080 [2345] merecat -n -p 8080 /var/www -- Old web server\n\n# Alternative method instead of below runparts, can also use /etc/rc.local\n#sysv [S] /etc/init.d/keyboard-setup       -- Setting up preliminary keymap\n#sysv [S] /etc/init.d/acpid                -- Starting ACPI Daemon\n#task [S] /etc/init.d/kbd                  -- Preparing console\n\n# Hidden from boot progress, using empty `--` description\n#sysv [S] /etc/init.d/keyboard-setup       --\n#sysv [S] /etc/init.d/acpid                --\n#task [S] /etc/init.d/kbd                  --\n\n# Run start scripts from this directory\n# runparts /etc/start.d\n\n# Virtual consoles run BusyBox getty, keep kernel default speed\ntty [12345] /sbin/getty -L 0 /dev/tty1  linux nowait noclear\ntty [2345]  /sbin/getty -L 0 /dev/tty2  linux nowait noclear\ntty [2345]  /sbin/getty -L 0 /dev/tty3  linux nowait noclear\n\n# Use built-in getty for serial port and USB serial\n#tty [12345] /dev/ttyAMA0 noclear nowait\n#tty [12345] /dev/ttyUSB0 noclear\n\n# Just give me a shell, I need to debug this embedded system!\n#tty [12345] console noclear nologin\n</code></pre> <p>The <code>service</code> stanza, as well as <code>task</code>, <code>run</code> and others are described in full in the Services Syntax section.</p> <p>Here's a quick overview of some of the most common components needed to start a UNIX daemon:</p> <pre><code>service [LVLS] &lt;COND&gt; log env:[-]/etc/default/daemon daemon ARGS -- Example daemon\n^       ^      ^      ^   ^                          ^      ^       ^\n|       |      |      |   |                          |      |        `---------- Optional description\n|       |      |      |   |                          |       `------------------ Daemon arguments\n|       |      |      |   |                           `------------------------- Path to daemon\n|       |      |      |    `---------------------------------------------------- Optional env. file\n|       |      |       `-------------------------------------------------------- Redirect output to log\n|       |       `--------------------------------------------------------------- Optional conditions\n|        `---------------------------------------------------------------------- Optional Runlevels\n `------------------------------------------------------------------------------ Supervised program (daemon)\n</code></pre> <p>Some components are optional: runlevel(s), condition(s) and description, making it easy to create simple start scripts and still possible for more advanced uses as well:</p> <pre><code>service /usr/sbin/sshd -D\n</code></pre> <p>Dependencies are handled using conditions.  One of the most common conditions is to wait for basic networking to become available:</p> <pre><code>service &lt;net/route/default&gt; nginx -- High performance HTTP server\n</code></pre> <p>Here is another example where we instruct Finit to not start BusyBox <code>ntpd</code> until <code>syslogd</code> has started properly.  Finit waits for <code>syslogd</code> to create its PID file, by default <code>/var/run/syslogd.pid</code>.</p> <pre><code>service [2345] log &lt;!pid/syslogd&gt; ntpd -n -N -p pool.ntp.org\nservice [S12345] syslogd -n -- Syslog daemon\n</code></pre> <p>Notice the <code>log</code> keyword, BusyBox <code>ntpd</code> uses <code>stderr</code> for logging when run in the foreground.  With <code>log</code> Finit redirects <code>stdout</code> + <code>stderr</code> to the system log daemon using the command line <code>logger(1)</code> tool.</p> <p>A service, or task, can have multiple dependencies listed.  Here we wait for both <code>syslogd</code> to have started and basic networking to be up:</p> <pre><code>service [2345] log &lt;pid/syslogd,net/route/default&gt; ntpd -n -N -p pool.ntp.org\n</code></pre> <p>If either condition fails, e.g. loss of networking, <code>ntpd</code> is stopped and as soon as it comes back up again <code>ntpd</code> is restarted automatically.</p> <p>Note</p> <p>Make sure daemons do not fork and detach themselves from the controlling TTY, usually an <code>-n</code> or <code>-f</code> flag, or <code>-D</code> as in the case of OpenSSH above. If it detaches itself, Finit cannot monitor it and will instead try to restart it.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#finit-features","title":"Finit Features","text":"<p>This page highlights some of Finit's key features with examples and usage scenarios. For complete documentation, configuration syntax, and advanced options, see the Configuration section.</p> <p>Process Supervision</p> <p>Start, monitor and restart services should they fail.</p> <p>Getty</p> <p>Finit supports external getty but also comes with a limited built-in Getty, useful for really small systems.  A getty sets up the TTY and waits for user input before handing over to <code>/bin/login</code>, which is responsible for handling the actual authentication.</p> <pre><code>tty [12345] /dev/tty1    nowait  linux\ntty [12345] /dev/ttyAMA0 noclear vt100\ntty [12345] /sbin/getty  -L /dev/ttyAMA0 vt100\n</code></pre> <p>Users of embedded systems may want to enable automatic serial console with the special <code>@console</code> device.  This works regardless whether the system uses <code>ttyS0</code>, <code>ttyAMA0</code>, <code>ttyMXC0</code>, or anything else.  Finit figures it out by querying sysfs: <code>/sys/class/tty/console/active</code>.</p> <pre><code>tty [12345] @console linux noclear\n</code></pre> <p>Notice the optional <code>noclear</code>, <code>nowait</code>, and <code>nologin</code> flags.  The latter is for skipping the login process entirely. For more information, see the TTY and Consoles section.</p> <p>Runlevels</p> <p>Support for SysV init-style runlevels is available, in the same minimal style as everything else in Finit.  The <code>[2345]</code> syntax can be applied to service, task, run, and TTY stanzas.</p> <p>Reserved runlevels are 0 and 6, halt and reboot, respectively just like SysV init.  Runlevel 1 can be configured freely, but is recommended to be kept as the system single-user runlevel since Finit will not start networking here.  The configured <code>runlevel NUM</code> from <code>/etc/finit.conf</code> is what Finit changes to after bootstrap, unless 'single' (or 'S') is given on the kernel cmdline, in which case runlevel 1 is started.</p> <p>All services in runlevel S) are started first, followed by the desired run-time runlevel.  Run tasks in runlevel S can be started in sequence by using <code>run [S] cmd</code>.  Changing runlevels at runtime is done like any other init, e.g. init 4, but also using the more advanced <code>initctl</code> tool.</p> <p>Conditions</p> <p>As mentioned previously, Finit has an advanced dependency system to handle synchronization, called conditions.  It can be used in many ways; depend on another service, network availability, etc.</p> <p>One really cool example useful for embedded systems is to run certain scripts if a board has a certain feature encoded in its device tree.  At bootstrap we run the following <code>ident</code> script:</p> <pre><code>#!/bin/sh\nconddir=/var/run/finit/cond/hw/model\ndtmodel=/sys/firmware/devicetree/base/model\n\nif ! test -e $dtmodel; then\n    exit 0\nfi\n\nmodel=$(cat $dtmodel | tr \"[A-Z] \" \"[a-z]-\")\nmkdir -p $conddir &amp;&amp; ln -s ../../reconf $conddir/$model\n</code></pre> <p>Provided the device tree node exists, and is a string, we can then use the condition <code>&lt;hw/model/foo&gt;</code> when starting other scripts.  Here is an example:</p> <pre><code>run  [S]                /path/to/ident    --\ntask [2] &lt;hw/model/foo&gt; /path/to/foo-init -- Initializing Foo board\n</code></pre> <p>Tip</p> <p>Notice the trick with an empty description to hide the call to <code>ident</code> in the Finit progress output.</p> <p>Plugins</p> <p>Plugins can extend the functionality of Finit and hook into the different stages of the boot process and at runtime.  Plugins are written in C and compiled into a dynamic library loaded automatically by finit at boot.  A basic set of plugins are bundled in the <code>plugins/</code> directory.</p> <p>Capabilities:</p> <ul> <li>Hooks   Hook into the boot at predefined points to extend Finit</li> <li>I/O   Listen to external events and control Finit behavior/services</li> </ul> <p>Extensions and functionality not purely related to what an <code>/sbin/init</code> needs to start a system are available as a set of plugins that either hook into the boot process or respond to various I/O.</p> <p>For more information, see the Plugins section.</p> <p>Automatic Reload</p> <p>By default, Finit monitors <code>/etc/finit.d/</code> and <code>/etc/finit.d/enabled/</code> registering any changes to <code>.conf</code> files.  To activate a change the user must call <code>initctl reload</code>, which reloads all modified files, stops any removed services, starts new ones, and restarts any modified ones.  If the command line arguments of a service have changed, the process will be terminated and then started again with the updated arguments. If the arguments have not been modified and the process supports SIGHUP, the process will receive a SIGHUP rather than being terminated and started.</p> <p>For some use-cases the extra step of calling <code>initctl reload</code> creates an unnecessary overhead, which can be removed at build-time using:</p> <pre><code>configure --enable-auto-reload\n</code></pre> <p>Linux Capabilities</p> <p>Finit supports Linux capabilities, allowing services to run with minimal required privileges instead of running as root. This improves security by following the principle of least privilege.</p> <pre><code>service [2345] name:nginx \\\n        www-data:www-data \\\n        caps:^cap_net_bind_service \\\n        /usr/sbin/nginx -g 'daemon off;'\n</code></pre> <p>In this example, nginx runs as the unprivileged <code>www-data</code> user but retains the ability to bind to privileged ports (80, 443) through the <code>cap_net_bind_service</code> capability.</p> <p>The <code>caps:</code> directive uses the IAB (Inheritable, Ambient, Bounding) format: - <code>^</code> = Ambient (recommended) - capabilities survive exec() - <code>%</code> = Inheritable only - requires file capabilities - <code>!</code> = Bounding - block from acquiring capability</p> <p>Multiple capabilities can be specified as comma-separated:</p> <pre><code>caps:^cap_net_raw,^cap_net_admin,!cap_sys_admin\n</code></pre> <p>See the Linux Capabilities section for detailed information, examples, and security best practices.</p> <p>Supplementary Groups</p> <p>Finit supports supplementary groups for services, allowing them to access resources owned by multiple groups without running as root. This complements capabilities for fine-grained privilege control.</p> <pre><code>service @caddy:caddy,ssl-cert /usr/bin/caddy run\n</code></pre> <p>In this example, the Caddy web server runs as user <code>caddy</code> with primary group <code>caddy</code>, but also has access to resources owned by the <code>ssl-cert</code> group (such as TLS certificates).</p> <p>Finit automatically reads the user's supplementary group membership from <code>/etc/group</code>. Additional groups can be specified explicitly using the syntax <code>@user:group,sup1,sup2,...</code>.</p> <p>See the Non-privileged Services section for more information.</p> <p>Cgroups</p> <p>Finit supports cgroups v2 and comes with the following default groups in which services and user sessions are placed in:</p> <pre><code> /sys/fs/cgroup\n   |-- init/               # cpu.weight:100\n   |-- system/             # cpu.weight:9800\n   `-- user/               # cpu.weight:100\n</code></pre> <p>Finit itself and its helper scripts and services are placed in the top-level leaf-node group <code>init/</code>, which also is reserved.</p> <p>All run/task/service/sysv processes are placed in their own sub-group in <code>system/</code>.  The name of each sub-group is taken from the respective <code>.conf</code> file from <code>/etc/finit.d</code>.</p> <p>All getty/tty processes are placed in their own sub-group in <code>user/</code>. The name of each sub-group is taken from the username.</p> <p>A fourth group also exists, the <code>root</code> group.  It is also reserved and primarily intended for RT tasks.  If you have RT tasks they need to be declared as such in their service stanza like this:</p> <pre><code>service [...] &lt;...&gt; cgroup.root /path/to/foo args -- description\n</code></pre> <p>or</p> <pre><code>cgroup.root\nservice [...] &lt;...&gt; /path/to/foo args -- description\nservice [...] &lt;...&gt; /path/to/bar args -- description\n</code></pre> <p>See the Cgroups section for more information, e.g., how to configure per-group limits.</p> <p>The <code>initctl</code> tool has three commands to help debug and optimize the setup and monitoring of cgroups.  See the <code>ps</code>, <code>top</code>, and <code>cgroup</code> commands for details.</p> <p>Note</p> <p>Systems that do not support cgroups, specifically version 2, are automatically detected.  On such systems the above functionality is disabled early at boot.</p> <p>Service Management</p> <p>Finit includes the <code>initctl</code> tool for managing services and system state at runtime. Key capabilities include:</p> <ul> <li>Enable/Disable services: Manage which services start at boot by moving   configuration files between <code>/etc/finit.d/available</code> and   <code>/etc/finit.d/enabled</code></li> <li>Start/Stop/Restart: Control individual services without requiring a   full system reboot</li> <li>Status monitoring: View service state, PID, uptime, and resource usage</li> <li>Condition management: Set and clear user-defined conditions to control   service dependencies</li> <li>Cgroup monitoring: Real-time process and resource monitoring with   <code>initctl top</code>, similar to the traditional <code>top</code> command but cgroup-aware</li> </ul> <p>Example commands:</p> <pre><code>initctl enable myservice          # Enable service for next boot\ninitctl start myservice           # Start service now\ninitctl status                    # Show all services\ninitctl top                       # Interactive resource monitor\ninitctl cond set usr/custom       # Set custom condition\n</code></pre> <p>See the Commands &amp; Status section for complete documentation.</p> <p>Rescue Mode</p> <p>Finit provides a built-in rescue mode for system recovery and maintenance. When booting with the <code>rescue</code> kernel parameter, the system enters a protected maintenance shell.</p> <p>If the bundled <code>sulogin</code> program is available (from Finit, util-linux, or BusyBox), you'll be prompted for the root password before accessing the maintenance shell. This provides secure access for system recovery.</p> <p>If <code>sulogin</code> is not available, Finit falls back to reading <code>/lib/finit/rescue.conf</code> and boots the system in a limited maintenance mode.</p> <pre><code># Kernel command line\nlinux /vmlinuz root=/dev/sda1 rescue\n</code></pre> <p>In rescue mode, <code>initctl</code> will not work. After fixing the problem, use <code>reboot -f</code> to force reboot.</p> <p>Rescue mode can be disabled at build time with <code>configure --without-rescue</code>.</p> <p>See the Rescue Mode section for more information.</p> <p>Switch Root</p> <p>Finit supports switching from an initramfs to a real root filesystem using the built-in <code>initctl switch-root</code> command.  This allows Finit to serve as the init system in an initramfs for early boot tasks (LUKS unlock, LVM activation, network boot) before transitioning to the real root.</p> <pre><code># In initramfs, after mounting the real root:\ninitctl switch-root /mnt/root\n</code></pre> <p>The switch-root operation:</p> <ol> <li>Runs the <code>HOOK_SWITCH_ROOT</code> hook for cleanup</li> <li>Stops all services gracefully</li> <li>Moves virtual filesystems (<code>/dev</code>, <code>/proc</code>, <code>/sys</code>, <code>/run</code>) to the new root</li> <li>Deletes initramfs contents to free memory</li> <li>Pivots to the new root and execs the new init</li> </ol> <p>See the Switch Root section for complete documentation.</p>"},{"location":"initctl/","title":"Commands & Status","text":""},{"location":"initctl/#commands-status","title":"Commands &amp; Status","text":"<p>Finit also implements a modern API to query status, and start/stop services, called <code>initctl</code>.  Unlike <code>telinit</code> the <code>initctl</code> tool does not return until the given command has fully completed.</p> <pre><code>Usage: initctl [OPTIONS] [COMMAND]\n\nOptions:\n  -b, --batch               Batch mode, no screen size probing\n  -c, --create              Create missing paths (and files) as needed\n  -f, --force               Ignore missing files and arguments, never prompt\n  -h, --help                This help text\n  -j, --json                JSON output in 'status' and 'cond' commands\n  -1, --once                Only one lap in commands like 'top'\n  -p, --plain               Use plain table headings, no ctrl chars\n  -q, --quiet               Silent, only return status of command\n  -t, --no-heading          Skip table headings\n  -v, --verbose             Verbose output\n  -V, --version             Show program version\n\nCommands:\n  debug                     Toggle Finit (daemon) debug\n  help                      This help text\n  version                   Show program version\n\n  ls | list                 List all .conf in /etc/finit.d\n  create   &lt;CONF&gt;           Create   .conf in /etc/finit.d/available\n  delete   &lt;CONF&gt;           Delete   .conf in /etc/finit.d/available\n  show     &lt;CONF&gt;           Show     .conf in /etc/finit.d/available\n  edit     &lt;CONF&gt;           Edit     .conf in /etc/finit.d/available\n  touch    &lt;CONF&gt;           Change   .conf in /etc/finit.d/available\n  enable   &lt;CONF&gt;           Enable   .conf in /etc/finit.d/available\n  disable  &lt;CONF&gt;           Disable  .conf in /etc/finit.d/enabled\n  reload                    Reload  *.conf in /etc/finit.d (activate changes)\n\n  cond     set   &lt;COND&gt;     Set (assert) user-defined conditions     +usr/COND\n  cond     get   &lt;COND&gt;     Get status of user-defined condition, see $? and -v\n  cond     clear &lt;COND&gt;     Clear (deassert) user-defined conditions -usr/COND\n  cond     status           Show condition status, default cond command\n  cond     dump  [TYPE]     Dump all, or a type of, conditions and their status\n\n  log      [NAME]           Show ten last Finit, or NAME, messages from syslog\n  start    &lt;NAME&gt;[:ID]      Start service by name, with optional ID\n  stop     &lt;NAME&gt;[:ID]      Stop/Pause a running service by name\n  reload   &lt;NAME&gt;[:ID]      Reload service as if .conf changed (SIGHUP or restart)\n                            This allows restart of run/tasks that have already run\n                            Note: Finit .conf file(s) are *not* reloaded!\n  restart  &lt;NAME&gt;[:ID]      Restart (stop/start) service by name\n  kill     &lt;NAME&gt;[:ID] &lt;S&gt;  Send signal S to service by name, with optional ID\n  ident    [NAME]           Show matching identities for NAME, or all\n  status   &lt;NAME&gt;[:ID]      Show service status, by name\n  status                    Show status of services, default command\n\n  cgroup                    List cgroup config overview\n  ps                        List processes based on cgroups\n  top                       Show top-like listing based on cgroups\n\n  plugins                   List installed plugins\n\n  runlevel [0-9]            Show or set runlevel: 0 halt, 6 reboot\n  reboot                    Reboot system\n  halt                      Halt system\n  poweroff                  Halt and power off system\n  suspend                   Suspend system\n  switch-root NEWROOT [INIT]  Switch to new root filesystem (initramfs only)\n\n  utmp     show             Raw dump of UTMP/WTMP db\n</code></pre> <p>For services not supporting <code>SIGHUP</code> the <code>&lt;!&gt;</code> notation in the .conf file must be used to tell Finit to stop and start it on <code>reload</code> and <code>runlevel</code> changes.  If <code>&lt;&gt;</code> holds more conditions, these will also affect how a service is maintained.</p> <p>Note</p> <p>Even though it is possible to start services not belonging in the current runlevel these services will not be respawned automatically by Finit if they exit (crash).  Hence, if the runlevel is 2, the below Dropbear SSH service will not be restarted if it is killed or exits.</p> <p>The <code>status</code> command is the default, it displays a quick overview of all monitored run/task/services.  Here we call <code>initctl -p</code>, suitable for scripting and documentation:</p> <pre><code>alpine:~# initctl -p\nPID   IDENT     STATUS   RUNLEVELS     DESCRIPTION\n======================================================================\n1506  acpid     running  [---2345----] ACPI daemon\n1509  crond     running  [---2345----] Cron daemon\n1489  dropbear  running  [---2345----] Dropbear SSH daemon\n1511  klogd     running  [S-12345----] Kernel log daemon\n1512  ntpd      running  [---2345----] NTP daemon\n1473  syslogd   running  [S-12345----] Syslog daemon\n\nalpine:~# initctl -pv\nPID   IDENT     STATUS   RUNLEVELS     COMMAND\n======================================================================\n1506  acpid     running  [---2345----] acpid -f\n1509  crond     running  [---2345----] crond -f -S $CRON_OPTS\n1489  dropbear  running  [---2345----] dropbear -R -F $DROPBEAR_OPTS\n1511  klogd     running  [S-12345----] klogd -n $KLOGD_OPTS\n1512  ntpd      running  [---2345----] ntpd -n $NTPD_OPTS\n1473  syslogd   running  [S-12345----] syslogd -n\n</code></pre> <p>The environment variables to each of the services above are read from, in the case of Alpine Linux, <code>/etc/conf.d/</code>.  Other distributions may have other directories, e.g., Debian use <code>/etc/default/</code>.</p> <p>The <code>status</code> command takes an optional <code>NAME:ID</code> argument.  Here we check the status of <code>dropbear</code>, which only has one instance in this system:</p> <pre><code>alpine:~# initctl -p status dropbear\n     Status : running\n   Identity : dropbear\nDescription : Dropbear SSH daemon\n     Origin : /etc/finit.d/enabled/dropbear.conf\nEnvironment : -/etc/conf.d/dropbear\nCondition(s):\n    Command : dropbear -R -F $DROPBEAR_OPTS\n   PID file : !/run/dropbear.pid\n        PID : 1485\n       User : root\n      Group : root\n     Uptime : 2 hour 46 min 56 sec\n  Runlevels : [---2345----]\n     Memory : 1.2M\n     CGroup : /system/dropbear cpu 0 [100, max] mem [--.--, max]\n              |- 1485 dropbear -R -F\n              |- 2634 dropbear -R -F\n              |- 2635 ash\n              `- 2652 initctl -p status dropbear\n\nApr  8 12:19:49 alpine authpriv.info dropbear[1485]: Not backgrounding\nApr  8 12:37:45 alpine authpriv.info dropbear[2300]: Child connection from 192.168.121.1:47834\nApr  8 12:37:46 alpine authpriv.notice dropbear[2300]: Password auth succeeded for 'root' from 192.168.121.1:47834\nApr  8 12:37:46 alpine authpriv.info dropbear[2300]: Exit (root) from &lt;192.168.121.1:47834&gt;: Disconnect received\nApr  8 15:02:11 alpine authpriv.info dropbear[2634]: Child connection from 192.168.121.1:48576\nApr  8 15:02:12 alpine authpriv.notice dropbear[2634]: Password auth succeeded for 'root' from 192.168.121.1:48576\n</code></pre>"},{"location":"initctl/#switch-root","title":"Switch Root","text":"<p>The <code>switch-root</code> command is used when running Finit in an initramfs to transition to the real root filesystem.  This is similar to the standalone <code>switch_root(8)</code> utility but integrated into Finit.</p> <pre><code>initctl switch-root /mnt/root [/sbin/init]\n</code></pre> <p>Requirements:</p> <ul> <li>Must be run during runlevel S (bootstrap) or runlevel 1</li> <li>The new root must be a mount point (different device than /)</li> <li>Can only be used when Finit is running as PID 1 in an initramfs</li> </ul> <p>For complete documentation and usage examples, see the dedicated Switch Root section.</p>"},{"location":"keventd/","title":"keventd","text":""},{"location":"keventd/#keventd","title":"keventd","text":"<p>The kernel event daemon bundled with Finit is a simple uevent monitor for <code>/sys/class/power_supply</code>.  It provides the <code>sys/pwr/ac</code> condition, which can be useful to prevent power hungry services like anacron to run when a laptop is only running on battery, for instance.</p> <p>Since keventd is not an integral part of Finit yet it is not enabled by default.  Enable it using <code>./configure --with-keventd</code>.  The bundled <code>contrib/</code> build scripts for Debian, Alpine, and Void have this enabled.</p> <p>This daemon is planned to be extended with monitoring of other uevents, patches and ideas are welcome in the issue tracker.</p>"},{"location":"plugins/","title":"Plugins","text":""},{"location":"plugins/#hooks-plugins","title":"Hooks &amp; Plugins","text":"<p>Finit can be extended to add general functionality in the form of I/O monitors, or hook plugins.  It is even possible to run scripts at these hook points, see below.</p> <p>The following sections detail existing plugins and hook points.  For more information, see the plugins listed below.</p>"},{"location":"plugins/#plugins","title":"Plugins","text":"<p>For your convenience a set of optional plugins are available:</p> <ul> <li> <p>alsa-utils.so: Restore and save ALSA sound settings on   startup/shutdown.  Optional plugin.</p> </li> <li> <p>bootmisc.so: Setup necessary files and system directories for, e.g.,   UTMP (tracks logins at boot).  This plugin is central to get a working   system and runs at <code>HOOK_BASEFS_UP</code>.  The <code>/var</code>, <code>/run</code>, and <code>/dev</code>   file systems must be writable for this plugin to work.</p> </li> </ul> <p>This plugin is a wrapper for the tmpfiles.d(5) implementation that   Finit has.  Capable but limited: no aging, attributes, or subvolumes.</p> <p>By default, <code>/lib/finit/tmpfiles.d</code> carries all the default .conf   files distributed with Finit.  It is read first but can be overridden   by any of the standard tmpfiles.d directories, e.g. <code>/etc/tmpfiles.d</code>.</p> <p>Note</p> <p>On an embedded system both <code>/var</code> and <code>/run</code> can be <code>tmpfs</code> RAM disks and <code>/dev</code> is usually a <code>devtmpfs</code>.  This must be defined in the <code>/etc/fstab</code> file and in the Linux kernel config.</p> <ul> <li> <p>dbus.so: Setup and start system message bus, D-Bus, at boot.   Optional plugin.</p> </li> <li> <p>hook-scripts.so: Trigger the execution of scripts from plugin hook   points (see Hooks).  Optional plugin.</p> </li> </ul> <p>This plugin is particularly useful for early boot debugging that needs   to take place before regular services are available.</p> <p>For example, say that you want to enable some kernel tracing before   modules are loaded. With hook scripts, you can just drop in a shell   script in <code>/libexec/finit/hook/mount/all/</code> that will poke the right   control files in tracefs.</p> <p>Scripts are located in <code>/libexec/finit/hook</code> by default, this can be   customized at build-time using the <code>--with-hook-scripts-path=PATH</code>   argument to <code>configure</code>.</p> <ul> <li>hotplug.so: Replaced with <code>/lib/finit/system/10-hotplug.conf</code>, which   checks for <code>udevd</code> and <code>mdev</code> at boot.  This file can be overridden by a   file in <code>/etc/finit.d/10-hotplug.conf</code>.</li> </ul> <p>Enabled by default.</p> <p>Tip</p> <p>See the Services section in the configuration guide for an example how to run <code>mdevd</code>, alternative to plain mdev.</p> <ul> <li> <p>rtc.so: Restore and save system clock from/to RTC on boot/halt.   Enabled by default.</p> </li> <li> <p>modules-load.so: Scans <code>/etc/modules-load.d/*.conf</code> for modules to   load using <code>modprobe</code>.  Each file can contain multiple lines with the   name of the module to load.  Any line starting with the standard UNIX   comment character, <code>#</code>, or <code>;</code>, is skipped.</p> </li> </ul> <p>Modules are by default loaded in runlevel <code>S</code> using the <code>task</code> stanza.   Each module gets a unique <code>name:modprobe.foo</code>, and optional<code>:ID</code>.  The   runlevel can be changed per file using:</p> <pre><code>    set runlevel 2345\n</code></pre> <p>The <code>:ID</code> is a globally incremented index, which can be disabled per   file (anywhere) using the following config line:</p> <pre><code>    set noindex\n</code></pre> <p>To change the index used by the plugin:</p> <pre><code>    set index 1234\n</code></pre> <p>Since these tasks run in the background, they return <code>[ OK ]</code> at boot,   unless the modprobe tool does not exist.  Check syslog for warnings   and the actual status of the operation using <code>initctl</code>.</p> <p>Important</p> <p>Unlike the traditional .conf <code>module</code> directive, which load any listed module immediately, this plugin creates a background <code>task</code> which load the module(s) in the background.  The program is modprobe, <code>/sbin/modprobe</code>, which you can override per .conf file:</p> <pre><code>set modprobe /path/to/maybe-a-modprobe-wrapper\n</code></pre> <ul> <li> <p>netlink.so: Listens to Linux kernel Netlink events for gateway and   interfaces.  These events are then sent to the Finit service monitor   for services that may want to be SIGHUP'ed on new default route or   interfaces going up/down.  Enabled by default.</p> </li> <li> <p>resolvconf.so: Setup necessary files for <code>resolvconf</code> at startup.   Optional plugin.</p> </li> <li> <p>tty.so: Watches <code>/dev</code>, using inotify, for new device nodes (TTY's)   to start/stop getty consoles on them on demand.  Useful when plugging   in a usb2serial converter to login to your embedded device.  Enabled   by default.</p> </li> <li> <p>urandom.so: Setup random seed at startup.  Enabled by default.</p> </li> <li> <p>x11-common.so: Setup necessary files for X-Window.  Optional plugin.</p> </li> </ul> <p>Usually you want to hook into the boot process once, simple hook plugins like <code>bootmisc.so</code> are great for that purpose.  They are called at each hook point in the boot process, useful to insert some pre-bootstrap mechanisms, like generating configuration files, restoring HW device state, etc.  Available hook points are:</p>"},{"location":"plugins/#hooks","title":"Hooks","text":"<p>In the below listings, the first label is the hook point for a C plugin, the second is the condition name and hook script path.  A hook script is a plain shell script, or program, that does a very small dedicated job at the below hook points.</p> <p>See Run-parts Scripts for details on the requirements, possibilities, and limitations of hook scripts.</p> <p>All hook scripts are called with at least one environment variable set, the hook name, useful when reusing the same hook script for multiple hook points:</p> <ul> <li><code>FINIT_HOOK_NAME</code>: set to the second label, e.g., <code>hook/net/up</code></li> <li><code>FINIT_SHUTDOWN</code>: set for <code>hook/sys/shutdown</code> and later to one     of <code>halt</code>, <code>poweroff</code>, or <code>reboot</code>.</li> </ul> <p>Example:</p> <pre><code>$ mkdir -p /libexec/finit/hook/sys/down\n$ cat &lt;&lt;EOF &gt;/libexec/finit/hook/sys/down/foo.sh\n#!/bin/sh\necho 'I run just before the reboot() syscall at shutdown/reboot'\necho 'I have access to /dev since devtmpfs is exempt from umount'\necho \"FINIT_HOOK_NAME: $FINIT_HOOK_NAME\"\nif [ -n \"$FINIT_SHUTDOWN\" ]; then\n        echo \"FINIT_SHUTDOWN:  $FINIT_SHUTDOWN\"\nfi\nexit 0\nEOF\n$ chmod +x /libexec/finit/hook/sys/down/foo.sh\n</code></pre> <p>Important</p> <p>To use hook scripts, even for pre-bootstrap and pre-shutdown tasks, you must build with <code>configure --enable-hook-scripts-plugin</code>.</p>"},{"location":"plugins/#bootstrap-hooks","title":"Bootstrap Hooks","text":"<ul> <li> <p><code>HOOK_BANNER</code>, <code>hook/sys/banner</code>: The very first point at which a   plugin can run.  Intended to be used as a banner replacement.   Essentially this runs just before entering runlevel S.  Assume nothing   is available, so be prepared to use absolute paths, etc.</p> </li> <li> <p><code>HOOK_ROOTFS_UP</code>, <code>hook/mount/root</code>: When <code>finit.conf</code> has been read   and <code>/</code> has is mounted \u2014 very early</p> </li> <li> <p><code>HOOK_MOUNT_ERROR</code>, <code>hook/mount/error</code>: executed if <code>mount -a</code> fails</p> </li> <li> <p><code>HOOK_MOUNT_POST</code>, <code>hook/mount/post</code>: always executed after <code>mount -a</code></p> </li> <li> <p><code>HOOK_BASEFS_UP</code>, <code>hook/mount/all</code>: All of <code>/etc/fstab</code> is mounted,   swap is available and default init signals are setup</p> </li> <li> <p><code>HOOK_SVC_PLUGIN</code>, <code>hook/svc/plugin</code>: Called in <code>conf_init()</code> right   before loading <code>/etc/finit.conf</code>.  For plugins to register any early   run/task/services, please do NOT use any earlier hook point.  That   will cause uninitialized rlimits that lead to unpredictable results   when Finit later tries to start the run/task/service.</p> </li> <li> <p><code>HOOK_NETWORK_UP</code>, <code>hook/net/up</code>: System bootstrap, runlevel S, has   completed and networking is up (<code>lo</code> is up and the <code>network</code> script   has run)</p> </li> <li> <p><code>HOOK_SVC_UP</code>, <code>hook/svc/up</code>: All services in the active runlevel have   been launched</p> </li> <li> <p><code>HOOK_SYSTEM_UP</code>, <code>hook/sys/up</code>: All services and everything in   <code>/etc/finit.d</code> has been launched</p> </li> </ul>"},{"location":"plugins/#runtime-hooks","title":"Runtime Hooks","text":"<ul> <li> <p><code>HOOK_SVC_RECONF</code>, N/A: Called when the user has changed something in   the <code>/etc/finit.d</code> directory and issued <code>SIGHUP</code>.  The hook is called   when all modified/removed services have been stopped.  When the hook   has completed, Finit continues to start all modified and new services.</p> </li> <li> <p><code>HOOK_RUNLEVEL_CHANGE</code>, N/A: Called when the user has issued a   runlevel change.  The hook is called when services not matching the   new runlevel have been been stopped.  When the hook has completed,   Finit continues to start all services in the new runlevel.</p> </li> </ul>"},{"location":"plugins/#switch-root-hooks","title":"Switch Root Hooks","text":"<ul> <li><code>HOOK_SWITCH_ROOT</code>, <code>hook/sys/switchroot</code>: Called when   <code>initctl switch-root</code> is issued, before the transition begins.  Use   this hook to save state, unmount initramfs-only filesystems, or perform   cleanup before switching to the new root.  Only runs when Finit is   operating as PID 1 in an initramfs.</li> </ul> <p>See the Switch Root section for more information.</p>"},{"location":"plugins/#shutdown-hooks","title":"Shutdown Hooks","text":"<ul> <li> <p><code>HOOK_NETWORK_DN</code>, <code>hook/net/down</code>: Called right after having changed   to runlevel 6, or 0, when all services have received their 'stop' signal.</p> </li> <li> <p><code>HOOK_SHUTDOWN</code>, <code>hook/sys/shutdown</code>: Called at shutdown/reboot, right   before all services are sent <code>SIGTERM</code></p> </li> <li> <p><code>HOOK_SVC_DN</code>, <code>hook/svc/down</code>: In shutdown/reboot, all services and   non-reserved processes have been killed.  Note: only hook scripts   can run here!</p> </li> <li> <p><code>HOOK_SYSTEM_DN</code>, <code>hook/sys/down</code>: In shutdown/reboot, called after   all non-reserved file systems have been unmounted, just before Finit   tells the kernel to reboot or shut down.  Note: only hook scripts   can run here!</p> </li> </ul> <p>Plugins like <code>tty.so</code> extend finit by acting on events, they are called I/O plugins and are called from the finit main loop when <code>poll()</code> detects an event.  See the source code for <code>plugins/*.c</code> for more help and ideas.</p>"},{"location":"requirements/","title":"Requirements","text":""},{"location":"requirements/#requirements","title":"Requirements","text":"<p>Finit is capable of running on both desktop/server systems with udev and embedded systems that usually come with BusyBox mdev.  Some systems have systemd-udev or eudev today instead of the original udev, Finit probes for all of them at runtime and expects <code>/dev/</code> to be a writable file system using <code>devtmpfs</code>.  It is also possible to run on a statically set up <code>/dev</code> if needed.  It is however not a good idea to have both udev and mdev installed at the same time, this will lead to unpredictable results.</p> <p>At boot Finit calls either <code>mdev</code> or <code>udevd</code> to populate <code>/dev</code>, this is done slightly differently and on systems with udev you might want to add the following one-shot task early in your <code>/etc/finit.conf</code>:</p> <pre><code>run [S] udevadm settle --timeout=120 -- Waiting for udev\n</code></pre> <p>Finit has a built-in Getty for TTYs, but requires a working <code>/bin/login</code> or <code>/bin/sh</code>, if no TTYs are configured in <code>/etc/finit.conf</code>.</p> <p>For a fully operational system <code>/var</code>, <code>/run</code> and <code>/tmp</code> must be set up properly in <code>/etc/fstab</code> -- which is iterated over at boot.</p>"},{"location":"runlevels/","title":"Runlevels Overview","text":""},{"location":"runlevels/#runlevel-support","title":"Runlevel Support","text":"<p>Basic support for runlevels is included in Finit from v1.8.  By default all services, tasks, run commands and TTYs listed without a set of runlevels get a default set <code>[234]</code> assigned.  The default runlevel after boot is 2.</p> <p>Finit supports runlevels 0-9, and S, with 0 reserved for halt, 6 reboot and S for services that only run at bootstrap.  Runlevel 1 is the single user level, where usually no networking is enabled.  In Finit this is more of a policy for the user to define.  Normally only runlevels 1-6 are used, and even more commonly, only the default runlevel is used.</p> <p>To specify an allowed set of runlevels for a <code>service</code>, <code>run</code> command, <code>task</code>, or <code>tty</code>, add <code>[NNN]</code> to your <code>/etc/finit.conf</code>, like this:</p> <pre><code>service [S12345] syslogd -n -x             -- System log daemon\nrun     [S]      /etc/init.d/acpid start   -- Starting ACPI Daemon\ntask    [S]      /etc/init.d/kbd start     -- Preparing console\nservice [S12345] &lt;pid/syslogd&gt; klogd -n -x -- Kernel log daemon\n\ntty     [12345]  /dev/tty1\ntty     [2]      /dev/tty2\ntty     [2]      /dev/tty3\ntty     [2]      /dev/tty4\ntty     [2]      /dev/tty5\ntty     [2]      /dev/tty6\n</code></pre> <p>In this example syslogd is first started, in parallel, and then acpid is called using a conventional SysV init script.  It is called with the run command, meaning the following task command to start the kbd script is not called until the acpid init script has fully completed.  Then the keyboard setup script is called in parallel with klogd as a monitored service.</p> <p>Again, tasks and services are started in parallel, while run commands are called in the order listed and subsequent commands are not started until a run command has completed.  Also, task and run commands are run in a shell, so pipes and redirects can be used.</p> <p>The following examples illustrate this.  Bootstrap task and run commands are also removed when they have completed, <code>initctl show</code> will not list them.</p> <pre><code>task [S] echo \"foo\" | cat &gt;/tmp/bar\nrun  [S] echo \"$HOME\" &gt;/tmp/secret\n</code></pre> <p>Switching between runlevels can be done by calling init with a single argument, e.g. init 5, or using <code>initctl runlevel 5</code>, both switch to runlevel 5.  When changing runlevels Finit also automatically reloads all <code>.conf</code> files in the <code>/etc/finit.d/</code> directory.  So if you want to set a new system config, switch to runlevel 1, change all config files in the system, and touch all <code>.conf</code> files in <code>/etc/finit.d</code> before switching back to the previous runlevel again \u2014 that way Finit can both stop old services and start any new ones for you, without rebooting the system.</p>"},{"location":"runparts/","title":"Runparts & rc.local","text":""},{"location":"runparts/#runparts-etcrclocal","title":"Runparts &amp; <code>/etc/rc.local</code>","text":"<p>At the end of the boot, when all bootstrap (<code>S</code>) tasks and services have started, but not networking, Finit calls its built-in run-parts(8) command on any configured <code>runparts &lt;DIR&gt;</code> directory.  This happens just before changing to the configured runlevel (default 2).  (Networking is enabled just prior to changing from single user mode.)</p> <pre><code>runparts /etc/rc.d/\n</code></pre> <p>Right after the runlevel change when all services have started properly, <code>/etc/rc.local</code> is called.</p> <p>No configuration stanza in <code>/etc/finit.conf</code> is required for <code>rc.local</code>. If it exists and is an executable shell script Finit calls it at the very end of the boot, before calling the <code>HOOK_SYSTEM_UP</code>.  See more in the Hook Scripts section.</p>"},{"location":"runparts/#limitations","title":"Limitations","text":"<p>It is not possible to call Finit via signals or use <code>initctl</code> in any runparts or <code>/etc/rc.local</code> script.  This because Finit is single threaded and is calling these scripts in a blocking fashion at the end of runlevel S, at which point the event loop has not yet been started.</p> <p>The event loop is the whole thing which Finit is built around, except for runlevel S, which remains a slow procession through a lot of set up, with a few hooks and blocking call outs to external scripts.</p> <p>However, not all <code>initctl</code> commands are prohibited. Supported commands:</p> <ul> <li><code>initctl cond</code>: only operate on files in <code>/run/finit/cond</code></li> <li><code>initctl enable/disable</code>: enabled run/task/service is activated on    the runlevel change from S to 2</li> <li><code>initctl touch/show/create/delete/list</code>: <code>create</code>, provided the    non-interactive mode is used, again changes take effect in the    runlevel change directly after bootstrap</li> <li><code>initctl -f reboot/poweroff/halt</code>: provided the <code>-f</code> flag is used to    force direct kernel commands</li> </ul> <p>Tip</p> <p>you can set a <code>usr/</code> condition in <code>/etc/rc.local</code> and have a service/task in runlevel 2 depend on it to execute.</p>"},{"location":"service/","title":"Managing Services","text":""},{"location":"service/#starting-monitoring","title":"Starting &amp; Monitoring","text":"<p>Finit can start and monitor the following types of daemons:</p> <ul> <li>Forks to background, creates a PID file</li> <li>Runs in foreground and signals ready by:</li> <li>creating a PID file</li> <li>does not create a PID file -- Finit can create it for you (optional)</li> <li>other mechanism (systemd, s6)</li> </ul> <p>Finit can not start and monitor a daemon that:</p> <ul> <li>Forks to background and does not create a PID file</li> </ul> Forking Creates PID File Finit creates PID File \u2714 Yes Yes No \u2714 No Yes No \u2714 No No Yes, optionally \u2718 Yes No No <p>Note</p> <p>PID files is one mechanism used to assert conditions to synchronize the start and stop of other, dependent, services.  Other mechanisms are described in the Service Synchronization section.</p>"},{"location":"service/#forks-to-bg-w-pid-file","title":"Forks to bg w/ PID file","text":"<p>There are two syntax variants, type 1 and type 2.  The former is the traditional one used also for <code>sysv</code> start/stop scripts, and the latter is inspired by systemd, with a twist -- it lets Finit guess the pifdile to look for based on the standard path and the basename of the command.</p> <pre><code>service pid:!/run/serv.pid serv       -- Forking service, type 1\nservice type:forking       serv       -- Forking service, type 2\n</code></pre> <p>In this example the resulting files to watch for are <code>/run/serv.pid</code> and <code>/var/run/serv.pid</code>, respectively.  On most modern Linux systems this is the same directory (<code>/var/run</code> is a symlink to <code>../run</code>).</p>"},{"location":"service/#runs-in-fg-w-pid-file","title":"Runs in fg w/ PID file","text":"<pre><code>service                    serv -n -p -- Foreground service w/ PID file\n</code></pre>"},{"location":"service/#runs-in-fg-wo-pid-file","title":"Runs in fg w/o PID file","text":"<p>Same as previous, but we tell Finit to create the PID file, because we need it to synchronize start/stop of a dependent service.</p> <pre><code>service pid:/run/serv.pid  serv -n    -- Foreground service w/o PID file\n</code></pre>"},{"location":"service/#runs-in-fg-w-custom-pid-file","title":"Runs in fg w/ custom PID file","text":"<pre><code>service pid:/run/servy.pid serv -n -p -P /run/servy.pid -- Foreground service w/ custom PID file\n</code></pre>"},{"location":"signals/","title":"Signals","text":""},{"location":"signals/#finit-signals","title":"Finit Signals","text":"<p>Finit is often used on embedded and small Linux systems with BusyBox. Though Finit comes with its own tools for (poweroff, halt, reboot), for compatibility with the existing BusyBox toolset the following signals have been adopted:</p>"},{"location":"signals/#sighup","title":"<code>SIGHUP</code>","text":"<p>Same effect as <code>finit q</code>, <code>init q</code>, or <code>initctl reload</code>, reloads all *.conf files in <code>/etc/finit.d/</code></p> <p>This also restarts the API (initctl) socket, like SysV init and systemd does on USR1 with their FIFO/D-Bus.</p>"},{"location":"signals/#sigusr1","title":"<code>SIGUSR1</code>","text":"<p>Since Finit 4.1 this signal causes Finit to restart its API (initctl) socket, like SysV init and systemd does on USR1 with their FIFO/D-Bus.</p> <p>Finit &lt;= 4.0 performed a system halt (like USR2 without power-off), but this caused compatibility problems with systemd and sysvinit on desktop systems.  Hence, since Finit 4.1 it is no longer possible to halt a system with a signal.</p>"},{"location":"signals/#sigusr2","title":"<code>SIGUSR2</code>","text":"<p>Calls shutdown hooks, including <code>HOOK_SHUTDOWN</code>, stopping all running processes, and unmounts all file systems.  Then tells kernel to power off the system, if ACPI or similar exists to actually do this.  If the kernel fails power-off, Finit falls back to halt.</p> <p>SysV init N/A, systemd dumps its internal state to log.</p>"},{"location":"signals/#sigterm","title":"<code>SIGTERM</code>","text":"<p>Like <code>SIGUSR2</code>, but tell kernel to reboot the system when done.</p> <p>SysV init N/A, systemd rexecutes itself.</p>"},{"location":"signals/#sigint","title":"<code>SIGINT</code>","text":"<p>Sent from kernel when the CTRL-ALT-DEL key combo is pressed.  SysV init and systemd default to reboot with <code>shutdown -r</code>.</p> <p>Finit currently forwards this to <code>SIGTERM</code>.</p>"},{"location":"signals/#sigpwr","title":"<code>SIGPWR</code>","text":"<p>Sent from a power daemon, like <code>powstatd(8)</code>, on changes to the UPS status.  Traditionally SysV init read /etc/powerstatus and acted on \"OK\", \"FAIL\", or \"LOW\" and then removed the file. Finit currently forwards this to <code>SIGUSR2</code>.</p>"},{"location":"state-machine/","title":"Service State Machine","text":""},{"location":"state-machine/#state-machine","title":"State Machine","text":"<p>A service is bound to a state machine that is in one of ten states.  For run/tasks there is an additional end state called <code>DONE</code>.  All processes managed by Finit start in the <code>HALTED</code> state.  The image shows how both conditions and commands drive the machine.</p> <p></p> <p>The current state depends on the two following conditions:</p> <ul> <li><code>E</code>: Service enabled. In order for <code>E</code> to be satisfied, the service   must be allowed to run in the current runlevel and not be stopped.</li> </ul> <p>A service may be stopped, or blocked, for several reasons:</p> <ul> <li>The user has manually stopped the service using <code>initctl stop NAME</code></li> <li>The program exits immediately. I.e. keeps crashing (make sure to use     the 'run this service in the foreground' command line option)</li> <li> <p>The binary is missing in the filesystem</p> </li> <li> <p><code>C</code>: Service conditions are satisfied:</p> </li> <li> <p><code>on</code> (+): The condition is asserted.</p> </li> <li><code>off</code> (-): The condition is deasserted.</li> <li><code>flux</code> (~): The condition state is unknown.</li> </ul> <p>For a detailed description of conditions, and how to debug them, see the Finit Conditions document.</p>"},{"location":"switchroot/","title":"Switch Root","text":""},{"location":"switchroot/#switch-root","title":"Switch Root","text":"<p>Finit supports switching from an initramfs to a real root filesystem using the <code>initctl switch-root</code> command.  This is useful for systems that use an initramfs for early boot (LUKS, LVM, network boot, etc.) and need to transition to the real root before starting services.</p>"},{"location":"switchroot/#usage","title":"Usage","text":"<pre><code>initctl switch-root NEWROOT [INIT]\n</code></pre> <ul> <li><code>NEWROOT</code>: Path to the mounted new root filesystem (e.g., <code>/mnt/root</code>)</li> <li><code>INIT</code>: Optional path to init on the new root (default: <code>/sbin/init</code>)</li> </ul>"},{"location":"switchroot/#requirements","title":"Requirements","text":"<ol> <li>Must be run during runlevel S (bootstrap) or runlevel 1</li> <li><code>NEWROOT</code> must be a mount point (different device than /)</li> <li><code>INIT</code> must exist and be executable on the new root</li> <li>Finit must be running as PID 1 (in initramfs)</li> </ol>"},{"location":"switchroot/#how-it-works","title":"How It Works","text":"<ol> <li>Runs <code>HOOK_SWITCH_ROOT</code> for any cleanup scripts/plugins</li> <li>Runs <code>HOOK_SHUTDOWN</code> to notify plugins</li> <li>Stops all services and kills remaining processes</li> <li>Exits all plugins gracefully</li> <li>Moves <code>/dev</code>, <code>/proc</code>, <code>/sys</code>, <code>/run</code> to new root</li> <li>Deletes initramfs contents (if on tmpfs/ramfs) to free memory</li> <li>Moves new root mount to <code>/</code></li> <li>Chroots to new root</li> <li>Reopens <code>/dev/console</code> for stdin/stdout/stderr</li> <li>Execs new init as PID 1</li> </ol>"},{"location":"switchroot/#example-initramfs-finitconf","title":"Example: Initramfs finit.conf","text":"<p>Configuration file <code>/etc/finit.conf</code> in the initramfs:</p> <pre><code># /etc/finit.conf in initramfs\n\n# Mount the real root filesystem\nrun [S] name:mount-root /bin/mount /dev/sda1 /mnt/root -- Mounting root filesystem\n\n# Switch to real root after mount completes\nrun [S] name:switch-root /sbin/initctl switch-root /mnt/root -- Switching to real root\n</code></pre> <p>For more complex setups (LUKS, LVM, etc.):</p> <pre><code># Unlock LUKS volume\nrun [S] name:cryptsetup /sbin/cryptsetup open /dev/sda2 cryptroot -- Unlocking encrypted root\n\n# Activate LVM\nrun [S] name:lvm /sbin/lvm vgchange -ay -- Activating LVM volumes\n\n# Mount root\nrun [S] name:mount-root /bin/mount /dev/vg0/root /mnt/root -- Mounting root\n\n# Switch root\nrun [S] name:switch-root /sbin/initctl switch-root /mnt/root -- Switching to real root\n</code></pre>"},{"location":"switchroot/#example-using-runlevel-1-for-switch-root","title":"Example: Using Runlevel 1 for Switch Root","text":"<p>For more complex initramfs setups where ordering of tasks becomes difficult in runlevel S, you can perform the switch-root in runlevel 1:</p> <pre><code># /etc/finit.conf in initramfs\n\n# Start mdevd for device handling\nservice [S] name:mdevd notify:s6 /sbin/mdevd -D %n -- Device event daemon\nrun [S] name:coldplug &lt;service/mdevd/ready&gt; /sbin/mdevd-coldplug -- Coldplug devices\n\n# Mount the real root filesystem (after devices are ready)\nrun [S] name:mount-root &lt;run/coldplug/success&gt; /bin/mount /dev/sda1 /mnt/root -- Mounting root\n\n# Transition to runlevel 1 after all S tasks complete\n# The switch-root runs cleanly in runlevel 1\nrun [1] name:switch-root /sbin/initctl switch-root /mnt/root -- Switching to real root\n</code></pre> <p>This approach separates the initramfs setup (runlevel S) from the switch-root operation (runlevel 1), making task ordering simpler.</p>"},{"location":"switchroot/#hooks","title":"Hooks","text":"<p>The <code>HOOK_SWITCH_ROOT</code> hook runs before the switch begins.  Use it for:</p> <ul> <li>Saving state to the new root</li> <li>Unmounting initramfs-only mounts</li> <li>Cleanup tasks</li> </ul> <p>Plugins can register for <code>HOOK_SWITCH_ROOT</code> just like other hooks:</p> <pre><code>static void my_switch_root_hook(void *arg)\n{\n    /* Cleanup before switch_root */\n}\n\nstatic plugin_t plugin = {\n    .name = \"my-plugin\",\n    .hook[HOOK_SWITCH_ROOT] = {\n        .cb = my_switch_root_hook\n    }\n};\n\nPLUGIN_INIT(plugin_init)\n{\n    plugin_register(&amp;plugin);\n}\n</code></pre>"},{"location":"switchroot/#conditions","title":"Conditions","text":"<p>After switch_root, the new finit instance starts fresh.  No conditions or state are preserved across the switch.  The new finit will:</p> <ol> <li>Re-read <code>/etc/finit.conf</code> from the new root</li> <li>Re-initialize all conditions</li> <li>Start services according to the new configuration</li> </ol>"},{"location":"switchroot/#see-also","title":"See Also","text":"<ul> <li>switch_root(8) - util-linux switch_root utility</li> <li>Kernel initramfs documentation</li> </ul>"},{"location":"watchdog/","title":"Watchdog","text":""},{"location":"watchdog/#bundled-watchdog-daemon","title":"Bundled Watchdog Daemon","text":"<p>When built <code>--with-watchdog</code> a separate service is built and installed in <code>/libexec/finit/watchdogd</code>.  If this exists at runtime, and the WDT device node exists, Finit will start it and treat it as the elected watchdog service to delegate its reboot to.  This delegation is to ensure that the system is rebooted by a hardware watchdog timer -- on many embedded systems this is crucial to ensure all circuits on the board are properly reset for the next boot, in effect ensuring the system works the same after both a power-on and reboot event.</p> <p>Note</p> <p>The watchdog reboot delegation can be enabled with the <code>reboot-watchdog</code> configuration option in <code>/etc/finit.conf</code>.  By default this is disabled and the system reboots directly via the SoC using the kernel's <code>reboot(2)</code> syscall.  See Runlevels for details.</p> <p>The delegation is performed at the very last steps of system shutdown, if reboot has been selected, <code>reboot-watchdog</code> is enabled, and an elected watchdog is known.  First a <code>SIGPWR</code> is sent to advise watchdogd of the pending reboot.  Then, when the necessary steps of preparing the system for shutdown (umount etc.) are completed, Finit sends <code>SIGTERM</code> to watchdogd and puts itself in a 10 sec timeout loop waiting for the WDT to reset the board.  If a reset is not done before the timeout, Finit falls back to <code>reboot(RB_AUTOBOOT)</code> which tells the kernel to do the reboot.</p> <p>An external watchdog service can also be used.  The more advanced cousin watchdogd is the recommended option here.  It can register itself with Finit using the same IPC as <code>initctl</code>.  If the bundled watchdogd is running a hand-over takes place, so it's safe to have both services installed on a system.  For the hand-over to work it requires that the WDT driver supports the safe exit functionality where <code>\"V\"</code> is written to the device before closing the device descriptor.  If the kernel driver has been built without this, the only option is to remove <code>/libexec/finit/watchdogd</code> or build without it at configure time.</p>"},{"location":"config/","title":"Overview","text":"<p>This section provides an overview of Finit's configuration system. For detailed information on specific topics, see the individual sections in the navigation menu.</p>"},{"location":"config/#configuration-file-syntax","title":"Configuration File Syntax","text":"<p>The file format is line based, empty lines and comments, lines starting with <code>#</code>, are ignored.  A configuration directive starts with a keyword followed by a space and the rest of the line is treated as the value.</p> <p>As of Finit v4.4, configuration directives can be broken up in multiple lines using the continuation character <code>\\</code>, and trailing comments are also allowed.  Example:</p> <pre><code># Escape \\# chars if you want them literal in, e.g., descriptions\nservice name:sysklogd [S123456789]   \\\n    env:-/etc/default/sysklogd       \\\n    syslogd -F $SYSLOGD_ARGS         \\\n    -- System log daemon \\# 1   # Comments allowed\n</code></pre> <p>The .conf files <code>/etc/finit.conf</code> and <code>/etc/finit.d/*</code> support many directives.  Some are restricted, e.g., only available at bootstrap, runlevel <code>S</code>.  Read on in Files &amp; Layout for more on how to structure your .conf files.</p> <p>For details on restrictions, see Limitations.</p>"},{"location":"config/capabilities/","title":"Capabilities","text":""},{"location":"config/capabilities/#linux-capabilities","title":"Linux Capabilities","text":"<p>Finit supports Linux capabilities, allowing services to run with minimal required privileges instead of running as root. This significantly improves system security by following the principle of least privilege.</p>"},{"location":"config/capabilities/#overview","title":"Overview","text":"<p>Linux capabilities divide the traditional root privileges into distinct units that can be independently granted to processes. For example, a web server only needs the capability to bind to privileged ports (&lt; 1024), not full root access.</p> <p>Finit uses the modern IAB (Inheritable, Ambient, Bounding) API from libcap, which is the same approach used by other modern service managers like dinit.</p>"},{"location":"config/capabilities/#basic-usage","title":"Basic Usage","text":"<p>Capabilities are specified using the <code>caps:</code> directive in service configuration:</p> <pre><code>service [2345] name:nginx \\\n        @www-data:www-data \\\n        caps:^cap_net_bind_service \\\n        /usr/sbin/nginx -g 'daemon off;' \\\n        -- Web server\n</code></pre> <p>This example allows nginx to bind to privileged ports (like 80 and 443) while running as the unprivileged <code>www-data</code> user.</p>"},{"location":"config/capabilities/#iab-format","title":"IAB Format","text":"<p>The capability string uses the IAB (Inheritable, Ambient, Bounding) format with the following prefixes:</p> <ul> <li><code>^</code> Ambient (and Inheritable) - Recommended for most use cases</li> <li>Capabilities survive across <code>exec()</code> calls</li> <li>Automatically raised to effective after exec</li> <li> <p>Example: <code>^cap_net_bind_service</code></p> </li> <li> <p><code>%</code> Inheritable only</p> </li> <li>Requires the executed binary to have matching file capabilities</li> <li>Less common, more complex setup</li> <li> <p>Example: <code>%cap_net_admin</code></p> </li> <li> <p><code>!</code> Bounding - Block capability from bounding set</p> </li> <li>Prevents the service from ever acquiring this capability</li> <li>Useful for security hardening</li> <li>Example: <code>!cap_sys_admin</code></li> </ul> <p>Multiple capabilities can be specified as a comma-separated list:</p> <pre><code>caps:^cap_net_raw,^cap_net_admin,^cap_net_bind_service\n</code></pre>"},{"location":"config/capabilities/#common-use-cases","title":"Common Use Cases","text":""},{"location":"config/capabilities/#web-server-privileged-ports","title":"Web Server (Privileged Ports)","text":"<p>Allow a web server to bind to ports 80 and 443 without running as root:</p> <pre><code>service [2345] name:webserver \\\n        @www-data:www-data \\\n        caps:^cap_net_bind_service \\\n        /usr/sbin/nginx -g 'daemon off;'\n</code></pre>"},{"location":"config/capabilities/#network-monitoring-raw-sockets","title":"Network Monitoring (Raw Sockets)","text":"<p>Allow packet capture without root privileges:</p> <pre><code>service [2345] name:tcpdump \\\n        @tcpdump \\\n        caps:^cap_net_raw,^cap_net_admin \\\n        /usr/sbin/tcpdump -i eth0 -w /var/log/capture.pcap\n</code></pre>"},{"location":"config/capabilities/#ntp-daemon-system-time","title":"NTP Daemon (System Time)","text":"<p>Allow time synchronization without full root:</p> <pre><code>service [2345] name:ntpd \\\n        @ntp \\\n        caps:^cap_sys_time,^cap_sys_nice \\\n        /usr/sbin/ntpd -n\n</code></pre>"},{"location":"config/capabilities/#available-capabilities","title":"Available Capabilities","text":"<p>Common capabilities include (see <code>man 7 capabilities</code> for the complete list):</p> <ul> <li><code>cap_chown</code> - Make arbitrary changes to file UIDs and GIDs</li> <li><code>cap_dac_override</code> - Bypass file read, write, and execute permission checks</li> <li><code>cap_dac_read_search</code> - Bypass file read permission checks</li> <li><code>cap_fowner</code> - Bypass permission checks on operations that normally require filesystem UID</li> <li><code>cap_kill</code> - Bypass permission checks for sending signals</li> <li><code>cap_net_admin</code> - Perform various network-related operations</li> <li><code>cap_net_bind_service</code> - Bind to privileged ports (&lt; 1024)</li> <li><code>cap_net_raw</code> - Use RAW and PACKET sockets</li> <li><code>cap_setgid</code> - Make arbitrary manipulations of process GIDs</li> <li><code>cap_setuid</code> - Make arbitrary manipulations of process UIDs</li> <li><code>cap_sys_admin</code> - Perform system administration operations (very powerful!)</li> <li><code>cap_sys_module</code> - Load and unload kernel modules</li> <li><code>cap_sys_nice</code> - Raise process nice value and change scheduling</li> <li><code>cap_sys_time</code> - Set system clock</li> </ul>"},{"location":"config/capabilities/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Use the minimum required capabilities</li> <li>Only grant what the service actually needs</li> <li> <p>Don't grant <code>cap_sys_admin</code> unless absolutely necessary</p> </li> <li> <p>Specify a user (preferably non-root)</p> </li> <li>The <code>@user</code> directive is required for <code>caps:</code> to take effect</li> <li>For ambient capabilities (<code>^</code>), use a non-root user (not <code>@root</code>)</li> <li> <p>Example: <code>@www-data</code>, <code>@nginx</code>, <code>@tcpdump</code></p> </li> <li> <p>Use ambient capabilities (<code>^</code>)</p> </li> <li>The <code>^</code> prefix ensures capabilities survive exec()</li> <li> <p>Simpler than setting file capabilities on binaries</p> </li> <li> <p>Block dangerous capabilities</p> </li> <li>Use <code>!</code> to explicitly block capabilities you don't want</li> <li> <p>Example: <code>!cap_sys_admin,!cap_sys_module</code></p> </li> <li> <p>Test with <code>getpcaps</code></p> </li> <li>After starting a service, verify its capabilities:      <pre><code>getpcaps $(pidof nginx)\n</code></pre></li> <li>Should show only the capabilities you granted</li> </ol>"},{"location":"config/capabilities/#verification","title":"Verification","text":"<p>After configuring a service with capabilities, verify it works correctly:</p> <pre><code># Start the service\ninitctl start webserver\n\n# Check the process capabilities\ngetpcaps $(pidof nginx)\n\n# Should show something like:\n# 12345: cap_net_bind_service=eip\n\n# Verify the user\nps -o user,pid,cmd -p $(pidof nginx)\n\n# Should show the service running as the specified user\n</code></pre>"},{"location":"config/capabilities/#requirements","title":"Requirements","text":"<ul> <li>Linux kernel 4.3+ (for ambient capabilities support)</li> <li>libcap library installed</li> <li>Finit built with <code>--enable-libcap</code></li> </ul>"},{"location":"config/capabilities/#limitations","title":"Limitations","text":"<ul> <li>The <code>caps:</code> directive requires <code>@user</code> to be specified for it to take effect</li> <li>Without <code>@user</code>, the service runs as root with full capabilities and     the <code>caps:</code> configuration is silently ignored</li> <li>You can use <code>@root</code> with <code>caps:</code>, but see below about ambient capabilities</li> <li>For ambient capabilities (<code>^</code>, recommended), the user must be non-root</li> <li>Using <code>@root</code> with <code>caps:^...</code> will not work effectively, as ambient     capabilities are only added to the effective set when euid \u2260 0</li> <li>Use inheritable (<code>%</code>) or bounding (<code>!</code>) capabilities with <code>@root</code> if needed</li> <li>Services without <code>caps:</code> use standard privilege dropping:</li> <li>Services with <code>@user</code> (non-root) have no special capabilities</li> <li>Services without <code>@user</code> run as root with full capabilities</li> <li>Some very old binaries may not work correctly with ambient capabilities</li> <li>File system capabilities are not managed by Finit (use <code>setcap</code> for that)</li> </ul>"},{"location":"config/capabilities/#see-also","title":"See Also","text":"<ul> <li>capabilities(7) - Linux capabilities overview</li> <li>cap_iab(3) - IAB capability API documentation</li> <li>setcap(8) - Set file capabilities</li> <li>getcap(8) - Query file capabilities</li> <li>capsh(1) - Capability shell wrapper</li> </ul>"},{"location":"config/cgroups/","title":"Cgroups","text":"<p>Finit provides three different cgroup directives for controlling resource allocation:</p> <ol> <li> <p>Top-level cgroup definition: <code>cgroup NAME settings</code></p> <ul> <li>Defines a top-level cgroup (e.g., <code>init</code>, <code>system</code>, <code>user</code>) with default settings</li> <li>Space-separated syntax</li> <li>Example: <code>cgroup system cpu.weight:9700</code></li> </ul> </li> <li> <p>Global cgroup selector: <code>cgroup.NAME[,options]</code> (standalone directive)</p> <ul> <li>Sets the default cgroup for subsequent services in a <code>.conf</code> file</li> <li>Dot-separated with optional comma-separated options</li> <li>Example: <code>cgroup.maint</code> or <code>cgroup.system,delegate</code></li> </ul> </li> <li> <p>Per-service cgroup option: <code>cgroup.NAME[,options]</code> or <code>cgroup:options</code></p> <ul> <li>Overrides the cgroup for a specific service</li> <li>Part of the service directive line</li> <li>Example: <code>service [...] cgroup.maint,mem.max:1G /path/to/cmd</code></li> </ul> </li> </ol> <p>Note</p> <p>Linux cgroups and details surrounding values are not explained in the Finit documentation.  The Linux admin-guide covers this well: https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html</p>"},{"location":"config/cgroups/#top-level-cgroup-definition","title":"Top-level Cgroup Definition","text":"<p>Syntax: <code>cgroup NAME settings</code></p> <pre><code># Top-level cgroups and their default settings.  All groups mandatory\n# but more can be added, max 8 groups in total currently.  The cgroup\n# 'root' is also available, reserved for RT processes.  Settings are\n# as-is, only one shorthand 'mem.' exists, other than that it's the\n# cgroup v2 controller default names.\ncgroup init   cpu.weight:100\ncgroup user   cpu.weight:100\ncgroup system cpu.weight:9800\n</code></pre> <p>Adding an extra cgroup <code>maint/</code> will require you to adjust the weight of the above three.  We leave <code>init/</code> and <code>user/</code> as-is reducing weight of <code>system/</code> to 9700.</p> <pre><code>cgroup system cpu.weight:9700\n\n# Example extra cgroup 'maint'\ncgroup maint  cpu.weight:100\n</code></pre> <p>By default, the <code>system/</code> cgroup is selected for almost everything.  The <code>init/</code> cgroup is reserved for PID 1 itself and its closest relatives. The <code>user/</code> cgroup is for local TTY logins spawned by getty.</p>"},{"location":"config/cgroups/#global-cgroup-selector","title":"Global Cgroup Selector","text":"<p>Syntax: <code>cgroup.NAME[,options]</code> (standalone directive)</p> <p>To select a different top-level cgroup, e.g. <code>maint/</code>, for a group of run/task/service directives in a <code>.conf</code> file, use the <code>cgroup.NAME</code> directive as a standalone line:</p> <pre><code>cgroup.maint\nservice [...] &lt;...&gt; /path/to/foo args -- description\nservice [...] &lt;...&gt; /path/to/bar args -- description\n</code></pre> <p>Both services will run in the <code>maint/</code> cgroup.</p> <p>You can also include options with the global selector:</p> <pre><code>cgroup.system,delegate\nservice [...] &lt;...&gt; /path/to/foo args -- description\n</code></pre>"},{"location":"config/cgroups/#per-service-cgroup-option","title":"Per-Service Cgroup Option","text":"<p>Syntax: <code>cgroup.NAME[,options]</code> or <code>cgroup:options</code> (service option)</p> <p>To override the cgroup for a specific service, use the <code>cgroup.NAME</code> option within the service directive:</p> <pre><code>service [...] &lt;...&gt; cgroup.maint /path/to/foo args -- description\n</code></pre> <p>This form also allows per-service limits. Two syntaxes are supported:</p> <p>New comma-separated syntax (recommended):</p> <pre><code>service [...] &lt;...&gt; cgroup.maint,cpu.max:10000,mem.max:655360 /path/to/foo args -- description\n</code></pre> <p>Old colon-separated syntax (legacy):</p> <pre><code>service [...] &lt;...&gt; cgroup.maint:cpu.max:10000,mem.max:655360 /path/to/foo args -- description\n</code></pre> <p>You can also apply options to the current default cgroup (without changing it) using the <code>cgroup:options</code> syntax:</p> <pre><code>service [...] &lt;...&gt; cgroup:cpu.max:10000,mem.max:655360 /path/to/foo args -- description\n</code></pre> <p>Both syntaxes work identically. The new comma-separated syntax is recommended as it's more consistent with other option parsing in Finit.</p> <p>Note the <code>mem.</code> exception to the rule: every cgroup setting maps directly to cgroup v2 syntax. I.e., <code>cpu.max</code> maps to the file <code>/sys/fs/cgroup/maint/foo/cpu.max</code>. There is no filtering, except for expanding the shorthand <code>mem.</code> to <code>memory.</code>. If the file is not available, either the cgroup controller is not available in your Linux kernel, or the name is misspelled.</p>"},{"location":"config/cgroups/#overriding-cgroup-leaf-names","title":"Overriding Cgroup Leaf Names","text":"<p>By default, the cgroup leaf directory name is derived from the service configuration filename (without the <code>.conf</code> extension). For example, a service defined in <code>system/10-hotplug.conf</code> would create a cgroup at <code>/sys/fs/cgroup/system/10-hotplug/</code> by default.</p> <p>To use a more descriptive name (recommended for clarity), you can specify <code>name:</code> in the cgroup directive:</p> <pre><code>service [...] &lt;...&gt; cgroup.system,name:udevd /lib/systemd/systemd-udevd -- Device event daemon\n</code></pre> <p>This creates the cgroup at <code>/sys/fs/cgroup/system/udevd/</code> instead.</p> <p>The syntax supports combining the name override with other options:</p> <pre><code>service [...] &lt;...&gt; cgroup.system,name:udevd,cpu.max:10000 /lib/systemd/systemd-udevd -- Device event daemon\n</code></pre> <p>Or with delegation:</p> <pre><code>service [2345] @podman:podman \\\n    cgroup.containers,name:podman,delegate,mem.max:4G \\\n    /usr/bin/podman system service -- Podman API\n</code></pre> <p>A daemon using <code>SCHED_RR</code> currently needs to run outside the default cgroups.</p> <pre><code>service [...] &lt;...&gt; cgroup.root /path/to/daemon arg -- Real-Time process\n</code></pre>"},{"location":"config/cgroups/#cgroup-delegation","title":"Cgroup Delegation","text":"<p>For services that need to create their own child cgroups (container runtimes like Docker, Podman, systemd-nspawn, LXC), use the <code>delegate</code> option:</p> <pre><code>service [2345] @dockerd:dockerd \\\n    cgroup.system,delegate /usr/bin/dockerd -- Docker daemon\n</code></pre> <p>Or with the old colon syntax:</p> <pre><code>service [2345] @dockerd:dockerd \\\n    cgroup.system:delegate /usr/bin/dockerd -- Docker daemon\n</code></pre> <p>This allows the container runtime to:</p> <ul> <li>Create child cgroups for containers</li> <li>Manage controller settings for containers</li> <li>Move processes between cgroups</li> </ul> <p>When delegation is enabled, Finit:</p> <ol> <li>Creates the service cgroup as a domain group (not a leaf)</li> <li>Enables all available controllers in <code>cgroup.subtree_control</code></li> <li>Changes ownership of delegation files to the service user</li> <li>Moves the service process to the cgroup root</li> <li>Lets the container runtime manage its own subdirectories</li> </ol> <p>Requirements:</p> <ul> <li>The service should specify <code>@user:group</code> for proper ownership</li> <li>Controllers are delegated from the parent cgroup</li> </ul> <p>Example with additional config (new syntax):</p> <pre><code>service [2345] @podman:podman \\\n    cgroup.containers,delegate,mem.max:4G \\\n    /usr/bin/podman system service -- Podman API\n</code></pre> <p>Or with old syntax:</p> <pre><code>service [2345] @podman:podman \\\n    cgroup.containers:delegate,mem.max:4G \\\n    /usr/bin/podman system service -- Podman API\n</code></pre> <p>Both examples delegate the cgroup while also setting a 4GB memory limit.</p> <p>Container template example:</p> <p>Here's a real-world example from Infix OS for running rootful podman container instances using delegation:</p> <pre><code>sysv log:prio:local1,tag:%i kill:30 pid:!/run/container:%i.pid \\\n    pre:0,/usr/sbin/container cleanup:0,/usr/sbin/container \\\n    cgroup.system,delegate                                   \\\n    [2345] &lt;!&gt; :%i container -n %i -- container %i\n</code></pre> <p>This template uses <code>sysv</code> type with delegation, demonstrating that cgroup delegation works with different service types, not just <code>service</code>.</p> <p>Cgroup structure with delegation:</p> <p>Initially, the service process runs directly in the cgroup root:</p> <pre><code>/sys/fs/cgroup/system/container@web/\n\u251c\u2500\u2500 cgroup.procs            (service PID - owned by service user)\n\u251c\u2500\u2500 cgroup.subtree_control  (+cpu +memory +io - owned by service user)\n\u2514\u2500\u2500 (container children will be created here)\n</code></pre> <p>Once the container runtime creates child cgroups (e.g., <code>libpod-*/</code>), cgroups v2 enforces the \"no internal processes\" rule. When Finit detects this (<code>EBUSY</code> error), it automatically creates an <code>supervisor/</code> subdirectory and moves service-related processes there:</p> <pre><code>/sys/fs/cgroup/system/container@web/\n\u251c\u2500\u2500 cgroup.procs            (empty)\n\u251c\u2500\u2500 cgroup.subtree_control  (+cpu +memory +io)\n\u251c\u2500\u2500 supervisor/             (service processes)\n\u2502   \u2514\u2500\u2500 cgroup.procs        (conmon PIDs, etc.)\n\u2514\u2500\u2500 libpod-$HASH/           (container processes)\n    \u2514\u2500\u2500 cgroup.procs        (container PIDs)\n</code></pre> <p>This happens automatically - no configuration needed. Without delegation, the cgroup would be a leaf and the container runtime could not create child cgroups.</p>"},{"location":"config/env/","title":"Environment Variables","text":""},{"location":"config/env/#environment-variables","title":"Environment Variables","text":"<p>In Finit v4.3 support for setting environment variables in <code>finit.conf</code>, and any <code>*.conf</code>, was added.  It is worth noting that these are global and shared with all services -- the only way to have a service-local environment is detailed in Services Environment.</p> <p>The syntax for global environment variables is straight forward.  In Finit v4.4 the <code>set</code> keyword was added for completeness, but the old syntax (without the <code>set</code> prefix) is still honored:</p> <pre><code>set foo=bar\nset baz=\"qux\"\n</code></pre> <p>On reload of .conf files, all tracked environment variables are cleared so if <code>foo=bar</code> is removed from <code>finit.conf</code>, or any <code>finit.d/*.conf</code> file, it will no longer be used by Finit or any new (!) started run/tasks or services.  The environment of already started processes can not be changed.</p> <p>The only variables reset to sane defaults on .conf reload are:</p> <pre><code>PATH=_PATH_STDPATH\nSHELL=_PATH_BSHELL\nLOGNAME=root\nUSER=root\n</code></pre> <p>It is entirely possible to override these as well from the .conf files, but be careful.  Changing SHELL changes the behavior of <code>system()</code> and a lot of other commands as well.</p>"},{"location":"config/files/","title":"Files & Layout","text":""},{"location":"config/files/#files-layout","title":"Files &amp; Layout","text":"<p>Originally Finit was configured using a single file, <code>/etc/finit.conf</code>, and although still possible to use a single configuration file, today the following layout is recommended:</p> <pre><code>/\n|- etc/\n|  |- finit.d/\n|  |   |- available/\n|  |   |  `- my-service.conf\n|  :   |- enabled/\n|  :   |  `- my-service.conf -&gt; ../available/my-service.conf\n|  :   :\n|  :   |- static-service.conf\n|  :   `- another-static.conf\n|  :\n|  `- finit.conf\n|- lib\n|   `- finit/\n|       `- system/\n|           |- 10-hotplug.conf\n|           `- ...\n`- run/\n    `- finit/\n        `- system/\n            |- dbus.conf\n            |- keventd.conf\n            |- runparts.conf\n            |- watchdogd.conf\n            `- ...\n</code></pre> <p>Configuration files in <code>/etc</code> are provided by the user, or projects like finit-skel and extended by the user.</p> <p>The files in <code>/lib/finit/system/*.conf</code> are system critical services and setup provided by Finit, e.g. udev/mdev that must run very early at system bootstrap.  This system directory was introduced in Finit v4.4 to replace the hard-coded services provided by plugins before.  All .conf files in this directory be either replaced by a system administrator or overridden by a file with the same name in <code>/etc/finit.d/</code>.</p> <p>The files in <code>/run/finit/system/*.conf</code> are created by plugins and Finit bundled services like runparts, watchdog, and <code>keventd</code> if they are enabled.  Like <code>/lib/finit/system/*.conf</code>, these files can be overridden by file with the same name in <code>/etc/finit.d/</code>.</p> <p>Services in the <code>available/</code> and <code>enabled/</code> sub-directories are called dynamic services, in contrast to static services -- the only difference being where they are installed and if the <code>initctl</code> tool can manage them with the <code>enable</code> and <code>disable</code> commands.  An administrator can always create files and symlinks manually.</p> <p>At bootstrap, and <code>initctl reload</code>, all .conf files are read, starting with <code>finit.conf</code>, then <code>/lib/finit/system/*.conf</code>, <code>finit.d/*.conf</code>, and finally all <code>finit.d/enabled/*.conf</code> files.  Each directory is a unique group, where files within each group are sorted alphabetically.</p> <p>Example:</p> <pre><code>/lib/finit/system/10-hotplug.conf\n/lib/finit/system/90-testserv.conf\n/run/finit/system/dbus.conf\n/run/finit/system/runparts.conf\n/etc/finit.d/10-abc.conf\n/etc/finit.d/20-abc.conf\n/etc/finit.d/enabled/1-aaa.conf\n/etc/finit.d/enabled/1-abc.conf\n</code></pre> <p>The resulting combined configuration is read line by line, each <code>run</code>, <code>task</code>, and <code>service</code> added to an ordered list that ensures they are started in the same order.  This is important because of the blocking properties of the <code>run</code> statement.  For an example on the relation of <code>service</code> and <code>run</code> statements, and dependency handling between them, see Conditional Loading, below.</p> <p>Note</p> <p>The names <code>finit.conf</code> and <code>finit.d/</code> are only defaults.  They can be changed at compile-time with two <code>configure</code> options: <code>--with-config=/etc/foo.conf</code> and <code>--with-rcsd=/var/foo.d</code>.</p> <p>They can also be overridden from the kernel command line using: <code>-- finit.config=/etc/bar.conf</code> and in that file use the top-level configuration directive <code>rcsd /path/to/finit.d</code>.</p>"},{"location":"config/files/#filesystem-layout","title":"Filesystem Layout","text":"<p>Finit is most comfortable with a traditional style Linux filesystem layout, as specified in the FHS:</p> <pre><code>/.\n |- bin/\n |- dev/          # Mounted automatically if devtmpfs is available\n |   |- pts/      # Mounted automatically by Finit if it exists\n |   `- shm/      # Mounted automatically by Finit if it exists\n |- etc/\n |   |- finit.d/\n |   |   |- available/\n |   |   `- enabled/\n |    `- finit.conf\n |- home/\n |- lib/\n |- libexec/\n |- mnt/\n |- proc/         # Mounted automatically by Finit if it exists\n |- root/\n |- run/          # Mounted automatically by Finit if it exists\n |   `- lock/     # Created automatically if Finit mounts /run\n |- sbin/\n |- sys/          # Mounted automatically by Finit if it exists\n |- tmp/          # Mounted automatically by Finit if it exists\n |- usr/\n `- var/\n     |- cache/\n     |- db/\n     |- lib/\n     |   `- misc/\n     |- lock/\n     |- log/\n     |- run -&gt; ../run\n     |- spool/\n     `- tmp/\n</code></pre> <p>Finit starts by mounting the critical file systems <code>/dev</code>, <code>/proc/</code>, and <code>/sys</code>, unless they are already mounted.  When all plugins and other, core Finit functions, have been set up, all relevant filesystems (where <code>PASS &gt; 0</code>) are checked and mounted from the selected <code>fstab</code>, either the default <code>/etc/fstab</code>, or any custom one selected from the command line, or at build time.</p> <p>To provide a smooth ride, file system not listed in the given <code>fstab</code>, e.g. <code>/tmp</code> and <code>/run</code>, are automatically mounted by Finit, as listed above, provided their respective mount point exists.</p> <p>With all filesystems mounted, Finit calls <code>swapon</code>.</p> <p>Tip</p> <p>To see what happens when all filesystems are mounted, have a look at the <code>bootmisc.so</code> plugin.</p> <p>At shutdown, and after having stopped all services and other lingering processes have been killed, filesystems are unmounted in the reverse order, and <code>swapoff</code> is called.</p>"},{"location":"config/files/#managing-services","title":"Managing Services","text":"<p>Using <code>initctl disable my-service</code> the symlink (above) is removed and the service is queued for removal.  Several changes can be made to the system, but it is not until <code>initctl reload</code> is called that the changes are activated.</p> <p>To add a new static service, drop a <code>.conf</code> file in <code>/etc/finit.d/</code> and run <code>initctl reload</code>.  (It is also possible to <code>SIGHUP</code> PID 1, or call <code>finit q</code>, but that has been deprecated with the <code>initctl</code> tool).  Finit monitors all known active <code>.conf</code> files, so if you want to force a restart of any service you can touch its corresponding <code>.conf</code> file in <code>/etc/finit.d</code> and call <code>initctl reload</code>.  Finit handles all conditions and dependencies between services automatically, see the section on Service Synchronization for more details.</p> <p>On <code>initctl reload</code> the following is checked for all services:</p> <ul> <li>If a service's <code>.conf</code> file has been removed, or its conditions are no   longer satisfied, the service is stopped.</li> <li>If the file is modified, or a service it depends on has been reloaded,   the service is reloaded (stopped and started).</li> <li>If a new service is added it is automatically started \u2014 respecting   runlevels and return values from any callbacks.</li> </ul> <p>For more info on the different states of a service, see the separate document Finit Services.</p>"},{"location":"config/files/#alternate-finitd","title":"Alternate finit.d/","text":"<p>Syntax: <code>rcsd /path/to/finit.d</code></p> <p>The Finit rcS.d directory is set at compile time with:</p> <pre><code>./configure --with-rcsd=/etc/finit.d\n</code></pre> <p>A system with multiple use-cases may be bootstrapped with different configurations, starting with the kernel command line option:</p> <pre><code>-- finit.config=/etc/factory.conf\n</code></pre> <p>This file in turn can use the <code>rcsd</code> directive to tell Finit to use another set of .conf files, e.g.:</p> <pre><code>rcsd /etc/factory.d\n</code></pre> <p>Note</p> <p>This directive is only available from the top-level bootstrap .conf file, usually <code>/etc/finit.conf</code>.</p>"},{"location":"config/files/#including-finit-configs","title":"Including Finit Configs","text":"<p>Syntax: <code>include &lt;CONF&gt;</code></p> <p>Include another configuration file.  Absolute path required.</p>"},{"location":"config/limitations/","title":"Limitations","text":""},{"location":"config/limitations/#limitations","title":"Limitations","text":"<p>As of Finit v4 there are no limitations to where <code>.conf</code> settings can be placed.  Except for the system/global <code>rlimit</code> and <code>cgroup</code> top-level group declarations, which can only be set from <code>/etc/finit.conf</code>, since it is the first <code>.conf</code> file Finit reads.</p> <p>Originally, <code>/etc/finit.conf</code> was the only way to set up a Finit system. Today it is mainly used for bootstrap settings like system hostname, early module loading for watchdogd, network bringup and system shutdown. These can now also be set in any <code>.conf</code> file in <code>/etc/finit.d</code>.</p> <p>There is, however, nothing preventing you from having all configuration settings in <code>/etc/finit.conf</code>.</p> <p>Important</p> <p>The default <code>rcsd</code>, i.e., <code>/etc/finit.d</code>, was previously the Finit runparts directory.  Finit &gt;=v4.0 no longer has a default <code>runparts</code> directory, make sure to update your setup, or the finit configuration, accordingly.</p>"},{"location":"config/logging/","title":"Logging","text":""},{"location":"config/logging/#general-logging","title":"General Logging","text":"<p>Syntax: <code>log size:200k count:5</code></p> <p>Log rotation for run/task/services using the <code>log</code> sub-option with redirection to a log file.  Global setting, applies to all services.</p> <p>The size can be given as bytes, without a specifier, or in <code>k</code>, <code>M</code>, or <code>G</code>, e.g. <code>size:10M</code>, or <code>size:3G</code>.  A value of <code>size:0</code> disables log rotation.  The default is <code>200k</code>.</p> <p>The count value is recommended to be between 1-5, with a default 5. Setting count to 0 means the logfile will be truncated when the MAX size limit is reached.</p>"},{"location":"config/logging/#redirecting-output","title":"Redirecting Output","text":"<p>The <code>run</code>, <code>task</code>, and <code>service</code> stanzas also allow the keyword <code>log</code> to redirect <code>stderr</code> and <code>stdout</code> of the application to a file or syslog using the native <code>logit</code> tool.  This is useful for programs that do not support syslog on their own, which is sometimes the case when running in the foreground.</p> <p>The full syntax is:</p> <pre><code>log:/path/to/file\nlog:prio:facility.level,tag:ident\nlog:console\nlog:null\nlog\n</code></pre> <p>Default <code>prio</code> is <code>daemon.info</code> and default <code>tag</code> is the basename of the service or run/task command.</p> <p>Log rotation is controlled using the global <code>log</code> setting.</p> <p>Example:</p> <pre><code>service log:prio:user.warn,tag:ntpd /sbin/ntpd pool.ntp.org -- NTP daemon\n</code></pre>"},{"location":"config/logging/#output-buffering","title":"Output Buffering","text":"<p>When using the <code>log</code> directive, Finit redirects the service's stdout and stderr to a pipe connected to a logger process.  Programs detect this as non-interactive output (i.e., <code>isatty()</code> returns false) and typically switch from line-buffered to fully-buffered mode.</p> <p>Most well-behaved daemons explicitly flush their output or use syslog directly, so this is rarely an issue.  However, if a service's log messages appear delayed or batched, you can force line-buffered output by wrapping the command with <code>stdbuf</code>:</p> <pre><code>service log /usr/bin/stdbuf -oL /path/to/command -- My service\n</code></pre> <p>The <code>-oL</code> option forces line-buffered output, and <code>-o0</code> forces unbuffered output.  See <code>stdbuf(1)</code> for details.</p> <p>Note</p> <p>Using <code>stdbuf</code> is rarely necessary. Only use it if you observe actual buffering issues with a specific service.</p>"},{"location":"config/rescue/","title":"Rescue Mode","text":""},{"location":"config/rescue/#rescue-mode","title":"Rescue Mode","text":"<p>Finit supports a rescue mode which is activated by the <code>rescue</code> option on the kernel command line.  See cmdline docs for how to activate it.</p> <p>This rescue mode can be disabled at configure time using:</p> <pre><code>configure --without-rescue\n</code></pre> <p>The rescue mode comes in two flavors; traditional and fallback.</p> <p>Note</p> <p>In this mode <code>initctl</code> will not work.  Use the <code>-f</code> flag to force <code>reboot</code>, <code>shutdown</code>, or <code>poweroff</code>.</p>"},{"location":"config/rescue/#traditional","title":"Traditional","text":"<p>This is what most users expect.  A very early maintenance login prompt, served by the system <code>sulogin</code> program from util-linux, or BusyBox.  If that is not found in <code>$PATH</code>, the bundled <code>/libexec/finit/sulogin</code> program is used instead.  If a successful login is made, or if the user exits (Ctrl-D), the rescue mode is ended and the system boots up normally.</p> <p>Warning</p> <p>The bundled sulogin in Finit can at configure time be given another user than the default (root).  If the sulogin user does not have a password, or the account is locked, the user is presented with a prompt: <code>\"Press enter to enter maintenance mode.\"</code>, which will open up a root shell without prompting for password!</p>"},{"location":"config/rescue/#fallback","title":"Fallback","text":"<p>If no <code>sulogin</code> program is found, Finit tries to bring up as much of its own functionality as possible, yet limiting many aspects, meaning; no network, no <code>fsck</code> of file systems in <code>/etc/fstab</code>, no <code>/etc/rc.local</code>, no <code>runparts</code>, and most plugins are skipped (except those that provide functionality for the condition subsystem).</p> <p>Instead of reading <code>/etc/finit.conf</code> et al, system configuration is read from <code>/lib/finit/rescue.conf</code>, which can be freely modified by the system administrator.</p> <p>The bundled default <code>rescue.conf</code> contains nothing more than:</p> <pre><code>runlevel 1\ntty [12345] rescue\n</code></pre> <p>The <code>tty</code> has the <code>rescue</code> option set, which works similar to the board bring-up tty option <code>notty</code>.  The major difference being that <code>sulogin</code> is started to query for root/admin password.  If <code>sulogin</code> is not found, <code>rescue</code> behaves like <code>notty</code> and gives a plain root shell prompt.</p> <p>If Finit cannot find <code>/lib/finit/rescue.conf</code> it defaults to:</p> <pre><code>tty [12345] rescue\n</code></pre> <p>There is no way to exit the fallback rescue mode.</p>"},{"location":"config/runlevels/","title":"Runlevels","text":""},{"location":"config/runlevels/#runlevels","title":"Runlevels","text":"<p>Finit supports runlevels, but unlike other init systems runlevels are declared per service/run/task/sysv command.  When booting up a system Finit pass through three phases:</p> <ol> <li>Setting up the console, parsing any command line options, and other     housekeeping tasks like mounting all filesystems, and calling <code>fsck</code></li> <li>Starting all run/task/services in runlevel S, then waiting for all     services to have started, and all run/tasks to have completed</li> <li>Go to runlevel 2, or whatever the user has set in the configuration</li> </ol> <p>Available runlevels:</p> <ul> <li><code>S</code>: bootStrap</li> <li><code>1</code>: Single user mode</li> <li><code>2-5</code>: traditional multi-user mode</li> <li><code>6</code>: reboot</li> <li><code>7-9</code>: multi-user mode (extra)</li> <li><code>0</code>: shutdown</li> </ul> <p>Runlevel S (bootStrap), is for tasks supposed to run once at boot, and services like <code>syslogd</code>, which need to start early and run throughout the lifetime of your system.</p> <p>Example:</p> <pre><code>task [S] /lib/console-setup/console-setup.sh\nservice [S12345] env:-/etc/default/rsyslog rsyslogd -n $RSYSLOGD_ARGS\n</code></pre> <p>When bootstrap has completed, Finit moves to runlevel 2.  This can be changed in <code>/etc/finit.conf</code> using the <code>runlevel N</code> directive, or by a script running in runlevel S that calls, e.g., <code>initctl runlevel 9</code>. The latter is useful if startup scripts detect problems outside of Finit's control, e.g., critical services/devices missing or hardware problems.</p> <p>Each runlevel must be allowed to \"complete\".  Meaning, all services in runlevel S must have started and all run/tasks have been started and collected (exited).  Finit waits 120 seconds for all run/tasks in S to complete before proceeding to 2.</p> <p>Finit first stops everything that is not allowed to run in 2, and then brings up networking.  Networking is expected to be available in all runlevels except: S, 1 (single user level), 6, and 0.  Networking is enabled either by the <code>network script</code> directive, or if you have an <code>/etc/network/interfaces</code> file, Finit calls <code>ifup -a</code> -- at the very least the loopback interface is brought up.</p> <p>Note</p> <p>When moving from runlevel S to 2, all run/task/services that were constrained to runlevel S only are dropped from bookkeeping.  So when reaching the prompt, <code>initctl</code> will not show these run/tasks.  This is a safety mechanism to prevent bootstrap-only tasks from accidentally being run again.  E.g., <code>console-setup.sh</code> above.</p>"},{"location":"config/runlevels/#runlevel-configuration","title":"Runlevel Configuration","text":"<p>Syntax: <code>runlevel &lt;N&gt;</code></p> <p>The system runlevel to go to after bootstrap (S) has completed.  <code>N</code> is the runlevel number 0-9, where 6 is reserved for reboot and 0 for halt. Completed in this context means all services have been started and all run/tasks have been started and collected.</p> <p>It is recommended to keep runlevel 1 as single-user mode, because Finit disables networking in this mode.</p> <p>Default: 2</p> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#networking","title":"Networking","text":"<p>Syntax: <code>network &lt;PATH&gt;</code></p> <p>Script or program to bring up networking, with optional arguments.</p> <p>Deprecated.  We recommend using dedicated task/run stanzas per runlevel, or <code>/etc/network/interfaces</code> if you have a system with <code>ifupdown</code>, like Debian, Ubuntu, Linux Mint, or an embedded BusyBox system.</p> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#system-hostname","title":"System Hostname","text":"<p>Syntax: <code>host &lt;NAME&gt;</code>, or <code>hostname &lt;NAME&gt;</code></p> <p>Set system hostname to NAME, unless <code>/etc/hostname</code> exists in which case the contents of that file is used.</p> <p>Deprecated.  We recommend using <code>/etc/hostname</code> instead.</p> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#kernel-modules","title":"Kernel Modules","text":"<p>Syntax: <code>module &lt;MODULE&gt; [ARGS]</code></p> <p>Load a kernel module, with optional arguments.  Similar to <code>insmod</code> command line tool.</p> <p>Deprecated, there is both a <code>modules-load.so</code> and a <code>modprobe.so</code> plugin that can handle module loading better.  The former supports loading from <code>/etc/modules-load.d/</code>, the latter uses kernel modinfo to automatically load (or coldplug) every required module.  For hotplug we recommend the BusyBox mdev tool, add to <code>/etc/mdev.conf</code>:</p> <pre><code>$MODALIAS=.*  root:root       0660    @modprobe -b \"$MODALIAS\"\n</code></pre> <p>Note</p> <p>Only read and executed in runlevel S (bootstrap).</p>"},{"location":"config/runlevels/#resource-limits","title":"Resource Limits","text":"<p>Syntax: <code>rlimit [hard|soft] RESOURCE &lt;LIMIT|unlimited&gt;</code></p> <p>Set the hard or soft limit for a resource, or both if that argument is omitted.  <code>RESOURCE</code> is the lower-case <code>RLIMIT_</code> string constants from <code>setrlimit(2)</code>, without prefix.  E.g. to set <code>RLIMIT_CPU</code>, use <code>cpu</code>.</p> <p>LIMIT is an integer that depends on the resource being modified, see setrlimit(2), or the kernel <code>/proc/PID/limits</code> file, for details.  Finit versions before v3.1 used <code>infinity</code> for <code>unlimited</code>, which is still supported, albeit deprecated.</p> <pre><code># No process is allowed more than 8MB of address space\nrlimit hard as 8388608\n\n# Core dumps may be arbitrarily large\nrlimit soft core infinity\n\n# CPU limit for all services, soft &amp; hard = 10 sec\nrlimit cpu 10\n</code></pre> <p><code>rlimit</code> can be set globally, in <code>/etc/finit.conf</code>, or locally per each <code>/etc/finit.d/*.conf</code> read.  I.e., a set of task/run/service stanzas can share the same rlimits if they are in the same .conf.</p>"},{"location":"config/runlevels/#miscellaneous-settings","title":"Miscellaneous Settings","text":"<p>Syntax: <code>reboot-delay &lt;0-60&gt;</code></p> <p>Optional delay at reboot (or shutdown or halt) to allow kernel filesystem threads to complete after calling <code>sync(2)</code> before rebooting.  This applies primarily to filesystems that do not have a reboot notifier implemented.  At the point of writing, the only known filesystems affected are: ubifs, jffs2.</p> <p>Default: 0 (disabled)</p> <p>When enabled (non-zero), this delay runs after file systems have been unmounted and the root filesystem has been remounted read-only, and sync(2) has been called, twice.</p> <p>\"On Linux, sync is only guaranteed to schedule the dirty blocks for writing; it can actually take a short time before all the blocks are finally written.</p> <p>Syntax: <code>reboot-watchdog &lt;on|off|true|false|1|0&gt;</code></p> <p>Controls whether the system should reboot via the watchdog timer (WDT) or directly via the SoC/kernel.  When enabled, Finit will:</p> <ol> <li>Send <code>SIGPWR</code> to the registered watchdog daemon before shutdown</li> <li>Send <code>SIGTERM</code> to the watchdog daemon and wait up to 10 seconds     for the watchdog to trigger a hardware reset</li> </ol> <p>When disabled (default), Finit skips the watchdog reboot logic and calls the kernel's <code>reboot(2)</code> syscall directly for a clean SoC reboot.</p> <p>Default: off (reboot via SoC)</p> <p>Note</p> <p>This setting only affects reboots.  The watchdog daemon will still run and monitor the system during normal operation.</p>"},{"location":"config/runparts/","title":"Run-parts Scripts","text":""},{"location":"config/runparts/#run-parts-scripts","title":"Run-parts Scripts","text":"<p>Syntax: <code>runparts [progress] [sysv] &lt;DIR&gt;</code></p> <p>Call run-parts(8) on <code>DIR</code> to run start scripts.  All executable files in the directory are called, in alphabetic order.  The scripts in this directory are executed at the very end of runlevel <code>S</code>.</p> <p>A common use-case for runparts scripts is to create and enable/disable services, which Finit will then apply when changing runlevel from S to whatever the next runlevel is set to be (default 2).  E.g., generate a <code>/etc/chrony.conf</code> and call <code>initctl enable chronyd</code>.</p> <p>Options:</p> <ul> <li><code>progress</code>: display the progress of each script being executed</li> <li><code>sysv</code>: run only SysV style scripts, i.e., <code>SNNfoo</code>, or <code>KNNbar</code>,    where <code>NN</code> is a number (0-99).</li> </ul> <p>If global debug mode is enabled, the <code>runparts</code> program is also called with the debug flag.</p> <p>Limitations:</p> <p>Scripts called from <code>runparts</code>, or hook scripts (see below), are limited in their interaction with Finit.  Like the standalone <code>run</code> stanza and the <code>/etc/rc.local</code> shell script, Finit waits for their completion before continuing.  None of them can issue commands to start, stop, or restart other services.  Also, ensure all your services and programs either terminate or start in the background or you will block Finit.</p> <p>Note</p> <p><code>runparts</code> scripts are only read and executed in runlevel S.  See hook scripts for other ways to run scripts at certain points during the complete lifetime of the system.</p> <p>Recommendations:</p> <p>It can be beneficial to use <code>01-name</code>, <code>02-othername</code>, etc., to ensure the scripts are started in that order, e.g., if there is a dependency order between scripts.  Symlinks to existing daemons can talso be used, but make sure they daemonize (background) themselves properly, otherwise Finit will lock up.</p> <p>If <code>S[0-9]foo</code> and <code>K[0-9]bar</code> style naming is used, the executable will be called with an extra argument, <code>start</code> and <code>stop</code>, respectively. E.g., <code>S01foo</code> will be called as <code>S01foo start</code>.  Of course, <code>S01foo</code> and <code>K01foo</code> may be a symlink to to <code>another/directory/foo</code>.</p>"},{"location":"config/service-env/","title":"Environment","text":""},{"location":"config/service-env/#service-environment","title":"Service Environment","text":"<p>Finit supports sourcing environment variables from <code>/etc/default/*</code>, or similar <code>--with-sysconfig=DIR</code>.  This is a common pattern from SysV init scripts, where the start-stop script is a generic script for the given service, <code>foo</code>, and the options for the service are sourced from the file <code>/etc/default/foo</code>.  Like this:</p> <ul> <li> <p><code>/etc/default/foo</code>:</p> <pre><code>FOO_OPTIONS=--extra-arg=\"bar\" -s -x\n</code></pre> </li> <li> <p><code>/etc/finit.conf</code>:</p> <pre><code>service [2345] env:-/etc/default/foo foo -n $FOO_OPTIONS -- Example foo daemon\n</code></pre> </li> </ul> <p>Here the service <code>foo</code> is started with <code>-n</code>, to make sure it runs in the foreground, and the with the options found in the environment file.  With the <code>ps</code> command we can see that the process is started with:</p> <pre><code>foo -n --extra-arg=bar -s -x\n</code></pre> <p>Note</p> <p>The leading <code>-</code> in <code>env:</code> determines if Finit should treat a missing environment file as blocking the start of the service or not.  When <code>-</code> is used, a missing environment file does not block the start.</p>"},{"location":"config/service-opts/","title":"Options","text":""},{"location":"config/service-opts/#service-options","title":"Service Options","text":"<p>The run/task/tty/service/sysv directives take modifiers, or options, to control their behavior.  This section lists them with their limitations. All modifiers must be placed between the directive and its command.</p> <p>The name of a service, shown by the <code>initctl</code> tool, defaults to the basename of the service executable. It can be changed with the <code>name:</code> option:</p> <pre><code>name:&lt;service-name&gt;\n</code></pre> <p>For multiple instances of a service, with the same <code>name</code>, set the identifier <code>:ID</code> to prevent Finit from replacing previous instances:</p> <pre><code>service name:ssdp :eth1 ssdpd eth1 -- Windows discovery on eth1\nservice name:ssdp :eth2 ssdpd eth2 -- Windows discovery on eth2\n</code></pre> <p>The <code>initctl</code> tool will list these two services as:</p> <ul> <li>ssdp:eth1</li> <li>ssdp:eth2</li> </ul> <p>Conflicting services that must be prevented from starting, use the <code>conflict:</code> option:</p> <pre><code>service [S12345789] udevd -- Device event management daemon\nrun [S] conflict:udevd mdev -s -- Populating device tree\n</code></pre> <p>Multiple conflicting services can be separated using <code>,</code>:</p> <pre><code>service :1 abc\nservice :2 abc\nservice conflict:abc:1,abc:2 cde\n</code></pre> <p>If a service should not be automatically started, it can be configured as manual with the optional <code>manual</code> argument. The service can then be started at any time by running <code>initctl start &lt;service&gt;</code>.</p> <pre><code>manual:yes\n</code></pre> <p>Other run/task/service options are:</p> <ul> <li><code>caps:...</code> -- see the Linux Capabilities section</li> <li><code>cgroup.NAME[,opts]</code> or <code>cgroup:opts</code> -- see the Cgroups section</li> <li><code>env:[-]/path/to/env</code> -- see the Service Environment section</li> <li><code>log:...</code> -- see Redirecting Output</li> <li><code>nowarn</code> -- see Conditional Loading</li> <li><code>notify:...</code> -- see Service Synchronization</li> <li><code>if:...</code> -- see Conditional Execution</li> <li><code>type:forking</code> -- see description of the service directive</li> </ul> <p>As mentioned previously, services are automatically started, restarted, and stopped, depending on the configuration and conditions.  Within the confines of that the following options are available:</p> <ul> <li><code>restart:NUM</code> -- number of times Finit tries to restart a crashing     service, default: 10, max: 255.  When this limit is reached the     service is marked crashed and must be restarted manually with     <code>initctl restart NAME</code></li> <li><code>restart_sec:SEC</code> -- number of seconds before Finit tries to restart     a crashing service, default: 2 seconds for the first five retries,     then back-off to 5 seconds.  The maximum of this configured value     and the above (2 and 5) will be used</li> <li><code>restart:always</code> -- no upper limit on the number of times Finit     tries to restart a crashing service.  Same as <code>restart:-1</code></li> <li><code>norestart</code> -- dont restart on failures, same as <code>restart:0</code></li> <li><code>respawn</code> -- bypasses the <code>restart</code> mechanism completely, allows     endless restarts.  Useful in many use-cases, but not what <code>service</code>     was originally designed for so not the default behavior</li> <li><code>oncrash:reboot</code> -- when all retries have failed, and the service     has crashed, if this option is set the system is rebooted</li> <li><code>oncrash:script</code> -- similarly, but instead of rebooting, call the     <code>post:script</code> action with exit code <code>crashed</code>, see below</li> <li><code>reload:'script [args]'</code> -- some services do not support <code>SIGHUP</code> but     may have other ways to update the configuration of a running daemon.     When <code>reload:script</code> is defined it is preferred over <code>SIGHUP</code>.  Like     systemd, Finit sets <code>$MAINPID</code> as a convenience to scripts, which in     effect also allow <code>reload:'kill -HUP $MAINPID'</code></li> <li><code>stop:'script [args]'</code> -- some services may require alternate methods     to be stopped.  If a <code>stop:script</code> is defined it is preferred over     <code>SIGTERM</code> and <code>stop</code>, for <code>service</code> and <code>sysv</code>, respectively.     Similar to <code>reload:script</code>, Finit sets <code>$MAINPID</code></li> </ul> <p>Caution</p> <p>Both <code>reload:script</code> and <code>stop:script</code> are called as PID 1, without any timeout!  Meaning, it is up to you to ensure the script is not blocking for seconds at a time or never terminates.</p> <p>When stopping a service (run/task/sysv/service), either manually or when moving to another runlevel, Finit starts by sending <code>SIGTERM</code>, to allow the process to shut down gracefully (unless a <code>stop:'script'</code> is used). However, if the process has not been collected within 3 seconds, Finit will send <code>SIGKILL</code>.  To stop the process using a different signal than <code>SIGTERM</code>, use <code>halt:SIGNAL</code>, e.g., <code>halt:SIGPWR</code>.  To change the delay between the stop signal and KILL, use the option <code>kill:&lt;1-60&gt;</code>, e.g., <code>kill:10</code> to wait 10 seconds before sending <code>SIGKILL</code>.</p> <p>Services, including the <code>sysv</code> variant, support pre/post/ready and cleanup scripts:</p> <ul> <li><code>pre:[0-3600,]script</code> -- called before the sysv/service is stated</li> <li><code>post:[0-3600,]script</code> -- called after the sysv/service has stopped</li> <li><code>ready:[0-3600,]script</code> -- called when the sysv/service is ready</li> <li><code>cleanup:[0-3600,]script</code> -- called when run/task/sysv/service is removed</li> </ul> <p>The optional number (0-3600) is the timeout before Finit kills the script, it defaults to the kill delay value and can be disabled by setting it to zero.  These scripts run as the same <code>@USER:GROUP</code> as the service itself, with any <code>env:file</code> sourced.  The scripts are executed from the <code>$HOME</code> of the given user.  The scripts are not called with any argument, but get a set of environment variables:</p> <ul> <li><code>SERVICE_IDENT=foo:1</code></li> <li><code>SERVICE_NAME=foo</code></li> <li><code>SERVICE_ID=1</code></li> </ul> <p>The <code>post:script</code> is called with an additional set of environment variables.  Yes, the text is correct, the naming was an accident:</p> <ul> <li><code>EXIT_CODE=[exited,signal,crashed]</code>: normal exit, signaled, or    crashed</li> <li><code>EXIT_STATUS=[num,SIGNAME]</code>: set to one of exit status code from    the program, if it exited normally, or the signal name (<code>HUP</code>,    <code>TERM</code>, etc.) if it exited due to signal</li> </ul> <p>When a run/task/sys/service is removed (disable + reload) it is first stopped and then removed from the runlevel.  The <code>post:script</code> always runs when the process has stopped, and the <code>cleanup:script</code> runs when the the stanza has been removed from the runlevel.</p> <p>Important</p> <p>These script actions are intended for setup, cleanup, and readiness notification.  It is up to the user to ensure the scripts terminate.</p>"},{"location":"config/service-sync/","title":"Synchronization","text":""},{"location":"config/service-sync/#service-synchronization","title":"Service Synchronization","text":"<p>Finit was created for fast booting systems.  Faster than a regular SysV Init based system at the time.  Early on the need for a guaranteed start order of services (daemons) arose.  I.e., service <code>A</code> must be guaranteed to have started (and be ready!) before <code>B</code>.  The model that was chosen to determine this was very simple: PID files.</p> <p>Early on in UNIX daemons were controlled with basic IPC like signals, and the way for a user to know that a daemon was ready to respond to signals (minimally having set up its signal handler), was to tell the user;</p> <p>\"Hey, you can send signals to me using the PID in this file: <code>/var/run/daemon.pid</code>\".</p> <p>Since most systems run fairly unchanged after boot, Finit could rely on the PID file for <code>A</code> being created before launching <code>B</code>.  This method has worked well for a long time, and for systems based on Open Source it was easy to either add PID file support to a daemon without support for it, or fix ordering issues (PID file created before signal handler is set up) in existing daemons.</p> <p>However, with the advent of other Init systems (Finit is rather old), most notably systemd and s6, other methods for signaling \"readiness\" arrived and daemons were adapted to these new schemes to a larger extent.</p> <p>As of Finit v4.4 partial support for systemd and s6 style readiness notification is available, and the native PID file mode of operation is, as of Finit v4.6 optional, by default it is still enabled, but this can be changed in <code>finit.conf</code>:</p> <pre><code>readiness none\n</code></pre> <p>This will be made the default in Finit 5.0.  In this mode of operation, every service needs to explicitly declare their readiness notification, like this:</p> <pre><code>service notify:pid     watchdogd\nservice notify:systemd foo\nservice notify:s6      bar\nservice notify:none    qux\n</code></pre> <p>The <code>notify:none</code> syntax is for completeness in systems which run in <code>readiness pid</code> mode (default).  Services declared with <code>notify:none</code> will transition to ready as soon as Finit has started them, e.g., <code>service/qux/ready</code>.</p> <p>To synchronize two services the following condition can be used:</p> <pre><code>service notify:pid                 watchdogd\nservice &lt;service/watchdogd/ready&gt;  stress-ng --cpu 8\n</code></pre> <p>For details on the syntax and options, see below.</p> <p>Note</p> <p>On <code>initctl reload</code> conditions are set in \"flux\", while figuring out which services to stop, start or restart.  Services that need to be restarted have their <code>ready</code> condition removed before Finit issue a SIGHUP (if they support that), or stop-starting them.  A daemon is expected to reassert its readiness, e.g. systemd style daemons to write <code>READY=1\\n</code>.</p> <p>However, the s6 notify mode does not support this because in s6 you are expected to close your notify descriptor after having written <code>\\n</code>.  This means s6 style daemons currently must be stop-started. (Declare the service with <code>&lt;!&gt;</code> in its condition statement.)</p> <p>For default, PID file style readiness notification, daemons are expected to either create their PID files, or touch it using <code>utimensat()</code> to reassert readiness.  Triggering both the <code>&lt;pid/&gt;</code> and <code>&lt;.../ready&gt;</code> conditions.</p>"},{"location":"config/service-wrappers/","title":"Wrapper Scripts","text":""},{"location":"config/service-wrappers/#service-wrapper-scripts","title":"Service Wrapper Scripts","text":"<p>If your service requires to run additional commands, executed before the service is actually started, like the systemd <code>ExecStartPre</code>, you can use a wrapper shell script to start your service.</p> <p>The Finit service <code>.conf</code> file can be put into <code>/etc/finit.d/available</code>, so you can control the service using <code>initctl</code>.  Then use the path to the wrapper script in the Finit <code>.conf</code> service stanza.  The following example employs a wrapper script in <code>/etc/start.d</code>.</p> <p>Example:</p> <ul> <li> <p><code>/etc/finit.d/available/program.conf</code>:</p> <pre><code>service [235] &lt;!&gt; /etc/start.d/program -- Example Program\n</code></pre> </li> <li> <p><code>/etc/start.d/program:</code></p> <pre><code>#!/bin/sh\n# Prepare the command line options\nOPTIONS=\"-u $(cat /etc/username)\"\n\n# Execute the program\nexec /usr/bin/program $OPTIONS\n</code></pre> </li> </ul> <p>Note</p> <p>The example sets <code>&lt;!&gt;</code> to denote that it doesn't support <code>SIGHUP</code>. That way Finit will stop/start the service instead of sending SIGHUP at restart/reload events.</p>"},{"location":"config/services/","title":"Syntax","text":""},{"location":"config/services/#services","title":"Services","text":"<p>Syntax: <code>service [LVLS] &lt;COND&gt; /path/to/daemon ARGS -- Optional description</code></p> <p>Service, or daemon, to be monitored and automatically restarted if it exits prematurely.  Finit tries to restart services that die, by default 10 times before giving up and marking them as crashed.  After which they have to be manually restarted with <code>initctl restart NAME</code>.  The limits controlling this are configurable, see the options below.</p> <p>Tip</p> <p>To allow endless restarts, see the <code>respawn</code> option</p> <p>For daemons that support it, we recommend appending <code>--foreground</code>, <code>--no-background</code>, <code>-n</code>, <code>-F</code>, or similar command line argument to prevent them from forking off a sub-process in the background.  This is the most reliable way to monitor a service.</p> <p>However, not all daemons support running in the foreground, or they may start logging to the foreground as well, these are forking daemons and are supported using the same syntax as forking <code>sysv</code> services, using the <code>pid:!/path/to/pidfile.pid</code> syntax.  There is an alternative syntax that may be more intuitive, where Finit can also guess the PID file based on the daemon's command name:</p> <pre><code>service type:forking ntpd -- NTP daemon\n</code></pre> <p>This example lets BusyBox <code>ntpd</code> daemonize itself.  Finit uses the basename of the binary to guess the PID file to watch for the PID: <code>/var/run/ntpd.pid</code>.  If Finit guesses wrong, you have to submit the full <code>pid:!/path/to/file.pid</code>.</p> <p>Example:</p> <p>In the case of <code>ospfd</code> (below), we omit the <code>-d</code> flag (daemonize) to prevent it from forking to the background:</p> <pre><code>service [2345] &lt;pid/zebra&gt; /sbin/ospfd -- OSPF daemon\n</code></pre> <p><code>[2345]</code> denote the runlevels <code>ospfd</code> is allowed to run in, they are optional and default to level 2-5 if omitted.</p> <p><code>&lt;...&gt;</code> is the condition for starting <code>ospfd</code>.  In this example Finit waits for another service, <code>zebra</code>, to have created its PID file in <code>/var/run/quagga/zebra.pid</code> before starting <code>ospfd</code>.  Finit watches all files in <code>/var/run</code>, for each file named <code>*.pid</code>, or <code>*/pid</code>, Finit opens it and find the matching <code>NAME:ID</code> using the PID.</p> <p>Some services do not maintain a PID file and rather than patching each application Finit provides a workaround.  A <code>pid</code> keyword can be set to have Finit automatically create (when starting) and later remove (when stopping) the PID file.  The file is created in the <code>/var/run</code> directory using the <code>basename(1)</code> of the service.  The default can be modified with an optional <code>pid:</code>-argument:</p> <pre><code>pid[:[/path/to/]filename[.pid]]\n</code></pre> <p>For example, by adding <code>pid:/run/bar.pid</code> to the service <code>/sbin/bar</code>, that PID file will, not only be created and removed automatically, but also be used by the Finit condition subsystem.  So a service/run/task can depend on <code>&lt;pid/bar&gt;</code>, like this foo will not be started until bar has started:</p> <pre><code>service pid:/run/bar.pid bar -- Bar Service\nservice &lt;pid/bar&gt; foo -- Foo Service\n</code></pre> <p>Needless to say, it is better if <code>bar</code> creates its own PID file when it has completed starting up and is ready for service.</p> <p>As an alternative \"readiness\" notification, Finit supports both systemd and s6 style notification.  This can be enabled by using the <code>notify</code> option:</p> <ul> <li><code>notify:systemd</code> -- tells Finit the service uses the <code>sd_notify()</code>     API to signal PID 1 when it has completed its startup and is ready     to service events.  The sd_notify() API expects <code>NOTIFY_SOCKET</code>     to be set to the socket where the application can send <code>\"READY=1\\n\"</code>     when it is starting up or has processed a <code>SIGHUP</code>.</li> <li><code>notify:s6</code> -- puts Finit in s6 compatibility mode.  Compared to the     systemd notification, s6 expect compliant daemons to send <code>\"\\n\"</code>     and then close their socket.  Finit takes care of \"hard-wiring\" the     READY state as long as the application is running, events across any     <code>SIGHUP</code>.  Since s6 can give its applications the descriptor number     (must be &gt;3) on then command line, Finit provides the following     syntax (<code>%n</code> is replaced by Finit with then descriptor number):<pre><code>service [S12345789] notify:s6 mdevd -O 4 -D %n\n</code></pre> </li> </ul> <p>When a service is ready, either by Finit detecting its PID file, or their respective readiness mechanism has been triggered, Finit creates then service's ready condition which other services can depend on:</p> <pre><code>$ initctl -v cond get service/mdevd/ready\non\n</code></pre> <p>This can be used to synchronize the start of another run/task/service:</p> <pre><code>task [S] &lt;service/mdevd/ready&gt; @root:root mdevd-coldplug\n</code></pre> <p>Finit waits for <code>mdevd</code> to notify it, before starting <code>mdevd-coldplug</code>. Notice how both start in runlevel S, and the coldplug task only runs in S.  When the system moves to runlevel 2 (the default), coldplug is no longer part of the running configuration (<code>initctl show</code>), this is to ensure that coldplug is not called more than once.</p> <p>For a detailed description of conditions, and how to debug them,  see the Finit Conditions document.</p>"},{"location":"config/services/#non-privileged-services","title":"Non-privileged Services","text":"<p>Every <code>run</code>, <code>task</code>, or <code>service</code> can also list the privileges the <code>/path/to/cmd</code> should be executed with.  Prefix the command with <code>@USR[:GRP[,SUPP,...]]</code>, where group and supplementary groups are optional, like this:</p> <pre><code>run [2345] @joe:users logger \"Hello world\"\n</code></pre> <p>Finit reads the user's supplementary group membership from <code>/etc/group</code> automatically.  Any groups the user belongs to will be inherited by the service.</p> <p>To specify additional supplementary groups beyond those in <code>/etc/group</code>, append them after the primary group, separated by commas:</p> <pre><code>service @caddy:caddy,ssl-cert /usr/bin/caddy run\n</code></pre> <p>This runs the <code>caddy</code> service as user <code>caddy</code>, with primary group <code>caddy</code>, inheriting any groups <code>caddy</code> is a member of in <code>/etc/group</code>, plus the additional <code>ssl-cert</code> group.  This is useful when a service needs access to resources owned by groups not listed in <code>/etc/group</code>.</p> <p>For multiple instances of the same command, e.g. a DHCP client or multiple web servers, add <code>:ID</code> somewhere between the <code>run</code>, <code>task</code>, <code>service</code> keyword and the command, like this:</p> <pre><code>service :80  [2345] httpd -f -h /http -p 80   -- Web server\nservice :8080[2345] httpd -f -h /http -p 8080 -- Old web server\n</code></pre> <p>Without the <code>:ID</code> to the service the latter will overwrite the former and only the old web server would be started and supervised.</p>"},{"location":"config/services/#conditional-loading","title":"Conditional Loading","text":"<p>Finit support conditional loading of stanzas.  The following example is take from the <code>system/hotplug.conf</code> file in the Finit distribution. Here we only show a simplified subset.</p> <p>Starting with the <code>nowarn</code> option.</p> <pre><code>service nowarn name:udevd pid:udevd /lib/systemd/systemd-udevd\nservice nowarn name:udevd pid:udevd udevd\n</code></pre> <p>When loading the .conf file Finit looks for <code>/lib/systemd/systemd-udevd</code> if that is not found Finit automatically logs a warning.  The <code>nowarn</code> option disables this warning so that the second line can be evaluated, which also provides a service named <code>udevd</code>.</p> <pre><code>run nowarn if:udevd &lt;pid/udevd&gt; :1 udevadm settle -t 0\n</code></pre> <p>This line is only loaded if we know of a service named <code>udevd</code>.  Again, we do not warn if <code>udevadm</code> is not found, execution will also stop here until the PID condition is asserted, i.e., Finit detecting udevd has started.</p> <pre><code>run nowarn conflict:udevd [S] mdev -s -- Populating device tree\n</code></pre> <p>If <code>udevd</code> is not available, we try to run <code>mdev</code>, but if that is not found, again we do not warn.</p> <p>Conditional loading statements can also be negated, so the previous stanza can also be written as:</p> <pre><code>run nowarn if:!udevd [S] mdev -s -- Populating device tree\n</code></pre> <p>The reason for using <code>conflict</code> in this example is that a conflict can be resolved.  Stanzas marked with <code>conflict:foo</code> are rechecked at runtime.</p>"},{"location":"config/services/#conditional-execution","title":"Conditional Execution","text":"<p>Similar to conditional loading of stanzas there is conditional runtime execution.  This can be confusing at first, since Finit already has a condition subsystem, but this is more akin to the qualification to a runlevel.  E.g., a <code>task [123]</code> is qualified to run only in runlevel 1, 2, and 3.  It is not considered for other runlevels.</p> <p>Conditional execution qualify a run/task/service based on a condition. Consider this (simplified) example from the Infix operating system:</p> <pre><code>run [S]                       name:startup &lt;pid/sysrepo&gt; confd -b --load startup-config\nrun [S] if:&lt;usr/fail-startup&gt; name:failure &lt;pid/sysrepo&gt; confd    --load failure-config\n</code></pre> <p>The two run statements reside in the same .conf file so Finit runs them in true sequence.  If loading the file <code>startup-config</code> fails confd sets the condition <code>usr/fail-startup</code>, thus allowing the next run statement to load <code>failure-config</code>.</p> <p>Notice the critical difference between the <code>&lt;pid/sysrepo&gt;</code> condition and <code>if:&lt;usr/fail-startup&gt;</code>.  The former is a condition for starting and the latter is a condition to check if a run/task/service is qualified to even be considered.</p> <p>Conditional execution statements can also be negated, so provided the file loaded did the opposite, i.e., set a condition on success, the previous stanza can also be written as:</p> <pre><code>run [S] if:&lt;!usr/startup-ok&gt; name:failure &lt;pid/sysrepo&gt; confd ...\n</code></pre>"},{"location":"config/sysv/","title":"SysV Compatibility","text":""},{"location":"config/sysv/#sysv-init-compatibility","title":"SysV Init Compatibility","text":"<p>It is not possible to run unmodified SysV init systems with Finit.  This was never the intention and is not the strength of Finit.  However, it comes with a few SysV Init compatibility features to ease the transition from a serialized boot process.</p>"},{"location":"config/sysv/#sysv-init-scripts","title":"SysV Init Scripts","text":"<p>Syntax: <code>sysv [LVLS] &lt;COND&gt; /path/to/init-script -- Optional description</code></p> <p><code>&lt;COND&gt;</code> is described in the Services section.</p> <p>Similar to <code>task</code> is the <code>sysv</code> stanza, which can be used to call SysV style scripts.  The primary intention for this command is to be able to reuse much of existing setup and init scripts in Linux distributions.</p> <p>When entering an allowed runlevel, Finit calls <code>init-script start</code>, when entering a disallowed runlevel, Finit calls <code>init-script stop</code>, and if the Finit .conf, where <code>sysv</code> stanza is declared, is modified, Finit calls <code>init-script restart</code> on <code>initctl reload</code>.  Similar to how <code>service</code> stanzas work.</p> <p>Forking services started with <code>sysv</code> scripts can be monitored by Finit by declaring the PID file to look for: <code>pid:!/path/to/pidfile.pid</code>. Notice the leading <code>!</code>, it signifies Finit should not try to create the file, but rather watch that file for the resulting forked-off PID.  This syntax also works for forking daemons that do not have a command line option to run it in the foreground, more on this below in <code>service</code>.</p> <p>Tip</p> <p>See also SysV Init Compatibility.</p>"},{"location":"config/sysv/#runparts-directory","title":"<code>runparts DIRECTORY</code>","text":"<p>For a directory with traditional start/stop scripts that should run, in order, at bootstrap, Finit provides the <code>runparts</code> directive.  It runs in runlevel S, at the very end of it (before calling <code>/etc/rc.local</code>) making it perfect for most scenarios.</p> <p>For syntax details, see the Run-parts Scripts section. Here is an example take from a Debian installation:</p> <pre><code>runparts /etc/rc2.d\n</code></pre> <p>Files in these directories are usually named <code>SNNfoo</code> and <code>KNNfoo</code>, which Finit knows about and automatically appends the correct argument:</p> <pre><code>/bin/sh -c /etc/rc2.d/S01openbsd-inetd start\n</code></pre> <p>or</p> <pre><code>/bin/sh -c /etc/rc0.d/K01openbsd-inetd stop\n</code></pre> <p>Files that do not match this pattern are started similarly but without the extra command line argument.</p>"},{"location":"config/sysv/#startstop-scripts","title":"Start/Stop Scripts","text":"<p>For syntax details, see SysV Init Scripts, above. Here follows an example taken from a Debian installation:</p> <pre><code>sysv [2345] &lt;pid/syslogd&gt; /etc/init.d/openbsd-inetd -- OpenBSD inet daemon\n</code></pre> <p>The init script header could be parsed to extract <code>Default-Start:</code> and other parameters for the <code>sysv</code> command to Finit.  There is currently no way to detail a generic syslogd dependency in Finit, so <code>Should-Start:</code> in the header must be mapped to the condition system in Finit using an absolute reference, here we depend on the sysklogd project's syslogd.</p>"},{"location":"config/sysv/#etcrclocal","title":"<code>/etc/rc.local</code>","text":"<p>One often requested feature, early on, was a way to run a site specific script to set up, e.g., static routes or firewall rules.  A user can add a <code>task</code> or <code>run</code> command in the Finit configuration for this, but for compatibility reasons the more widely know <code>/etc/rc.local</code> is used if it exists, and is executable.  It is called very late in the boot process when the system has left runlevel S, stopped all old and started all new services in the target runlevel (default 2).</p> <p>In Finit releases before v4.5 this script blocked Finit execution and made it as good as impossible to call <code>initctl</code> during that time.</p>"},{"location":"config/sysv/#init-q","title":"<code>init q</code>","text":"<p>When <code>/sbin/finit</code> is installed as <code>/sbin/init</code>, it is possible to use <code>init q</code> to reload the configuration.  This is the same as calling <code>initctl reload</code>.</p>"},{"location":"config/task-and-run/","title":"One-shot Tasks","text":""},{"location":"config/task-and-run/#run-sequence","title":"run (sequence)","text":"<p>Syntax: <code>run [LVLS] &lt;COND&gt; /path/to/cmd ARGS -- Optional description</code></p> <p><code>&lt;COND&gt;</code> is described in the Services section.</p> <p>One-shot command to run in sequence when entering a runlevel, with optional arguments and description.  <code>run</code> commands are guaranteed to be completed before running the next command.  Useful when serialization is required.</p> <p>Warning</p> <p>Try to avoid the <code>run</code> command.  It blocks much of the functionality in Finit, like (re)starting other (perhaps crashing) services while a <code>run</code> task is executing.  Use other synchronization mechanisms instead, like conditions.</p> <p>Incomplete list of unsupported <code>initctl</code> commands in <code>run</code> tasks:</p> <ul> <li><code>initctl runlevel N</code>, setting runlevel</li> <li><code>initctl reboot</code></li> <li><code>initctl halt</code></li> <li><code>initctl poweroff</code></li> <li><code>initctl suspend</code></li> </ul> <p>To prevent <code>initctl</code> from calling Finit when enabling and disabling services from inside a <code>run</code> task, use the <code>--force</code> option.  See also the <code>--quiet</code> and <code>--batch</code> options.</p>"},{"location":"config/task-and-run/#task-parallel","title":"task (parallel)","text":"<p>Syntax: <code>task [LVLS] &lt;COND&gt; /path/to/cmd ARGS -- Optional description</code></p> <p><code>&lt;COND&gt;</code> is described in the Services section.</p> <p>One-shot like 'run', but starts in parallel with the next command.</p> <p>Both <code>run</code> and <code>task</code> commands are run in a shell, so basic pipes and redirects can be used:</p> <pre><code>task [s] echo \"foo\" | cat &gt;/tmp/bar\n</code></pre> <p>Please note, <code>;</code>, <code>&amp;&amp;</code>, <code>||</code>, and similar are not supported.  Any non-trivial constructs are better placed in a separate shell script.</p>"},{"location":"config/templating/","title":"Templating","text":""},{"location":"config/templating/#templating","title":"Templating","text":"<p>Finit comes with rudimentary support for templating, similar to that of systemd.  Best illustrated with an example:</p> <pre><code>$ initctl show avahi-autoipd@\nservice :%i avahi-autoipd --syslog %i -- ZeroConf for %i\n</code></pre> <p>To enable ZeroConf for, e.g., <code>eth0</code>, use</p> <pre><code>$ initctl enable avahi-autoipd@eth0.conf\n</code></pre> <p>The enabled symlink will be set up to <code>avahi-autoipd@.conf</code> and every instance of <code>%i</code> will in the instantiated directive be replaced with <code>eth0</code>.  Inspect the resulting instantiated template with <code>initctl show avahi-autoipd:eth0</code> and check the status of a running instance with:</p> <pre><code>$ initctl status avahi-autoipd:eth0\n     Status : running\n   Identity : avahi-autoipd:eth0\nDescription : ZeroConf for eth0\n     Origin : /etc/finit.d/enabled/avahi-autoipd@eth0.conf\nEnvironment : -/etc/default/avahi-autoipd-eth0\n    Command : avahi-autoipd $AVAHI_AUTOIPD_ARGS eth0\n   PID file : /run/avahi-autoipd.eth0.pid\n        PID : 4190\n       User : root\n      Group : root\n     Uptime : 24 sec\n   Restarts : 0 (0/10)\n  Runlevels : [---2345-789]\n     Memory : 20.0k\n     CGroup : /system/avahi-autoipd@eth0 cpu 0 [100, max] mem [0, max]\n              \u2514\u2500 4190 avahi-autoipd: [eth0] bound 169.254.1.9  \n\nJul  8 11:51:42 infix-c0-ff-ee finit[1]: Starting avahi-autoipd:eth0[4190]\n</code></pre>"},{"location":"config/tty/","title":"TTY & Console","text":""},{"location":"config/tty/#ttys-and-consoles","title":"TTYs and Consoles","text":"<p>Syntax: <code>tty [LVLS] &lt;COND&gt; DEV [BAUD] [noclear] [nowait] [nologin] [TERM]</code> <code>tty [LVLS] &lt;COND&gt; CMD &lt;ARGS&gt; [noclear] [nowait]</code> <code>tty [LVLS] &lt;COND&gt; [notty] [rescue]</code></p> <p>The first variant of this option uses the built-in getty on the given TTY device DEV, in the given runlevels.  DEV may be the special keyword <code>@console</code>, which is expanded from <code>/sys/class/tty/console/active</code>, useful on embedded systems.</p> <p>The default baud rate is 0, i.e., keep kernel default.</p> <p>The <code>tty</code> stanza inherits runlevel, condition (and other feature) parsing from the <code>service</code> stanza.  So TTYs can run in one or many runlevels and depend on any condition supported by Finit.  This is useful e.g. to depend on <code>&lt;pid/elogind&gt;</code> before starting a TTY.</p> <p>Example:</p> <pre><code>tty [12345] /dev/ttyAMA0 115200 noclear vt220\n</code></pre> <p>The second <code>tty</code> syntax variant is for using an external getty, like agetty or the BusyBox getty.</p> <p>The third variant is for board bringup and the <code>rescue</code> boot mode.  No device node is required in this variant, the same output that the kernel uses is reused for stdio.  If the <code>rescue</code> option is omitted, a shell is started (<code>nologin</code>, <code>noclear</code>, and <code>nowait</code> are implied), if the rescue option is set the bundled <code>/libexec/finit/sulogin</code> is started to present a bare-bones root login prompt.  If the root (uid:0, gid:0) user does not have a password set, no rescue is possible.  For more information, see the Rescue Mode section.</p> <p>By default, the first two syntax variants clear the TTY and wait for the user to press enter before starting getty.</p> <p>Example:</p> <pre><code>tty [12345] /sbin/getty  -L 115200 /dev/ttyAMA0 vt100\ntty [12345] /sbin/agetty -L ttyAMA0 115200 vt100 nowait\n</code></pre> <p>The <code>noclear</code> option disables clearing the TTY after each session. Clearing the TTY when a user logs out is usually preferable.</p> <p>The <code>nowait</code> option disables the <code>press Enter to activate console</code> message before actually starting the getty program.  On small and embedded systems running multiple unused getty wastes both memory and CPU cycles, so <code>wait</code> is the preferred default.</p> <p>The <code>nologin</code> option disables getty and <code>/bin/login</code>, and gives the user a root (login) shell on the given TTY <code>&lt;DEV&gt;</code> immediately. Needless to say, this is a rather insecure option, but can be very useful for developer builds, during board bringup, or similar.</p> <p>Notice the ordering, the <code>TERM</code> option to the built-in getty must be the last argument.</p> <p>Embedded systems may want to enable automatic <code>DEV</code> by supplying the special <code>@console</code> device.  This works regardless weather the system uses <code>ttyS0</code>, <code>ttyAMA0</code>, <code>ttyMXC0</code>, or anything else.  Finit figures it out by querying sysfs: <code>/sys/class/tty/console/active</code>.  The speed can be omitted to keep the kernel default.</p> <p>Most systems get by fine by just using <code>console</code>, which will evaluate to <code>/dev/console</code>.  If you have to use <code>@console</code> to get any output, you may have some issue with your kernel config.</p> <p>Example:</p> <pre><code>tty [12345] @console noclear vt220\n</code></pre> <p>On really bare bones systems, or for board bringup, Finit can give you a shell prompt as soon as bootstrap is done, without opening any device node:</p> <pre><code>tty [12345789] notty\n</code></pre> <p>This should of course not be enabled on production systems.  Because it may give a user root access without having to log in.  However, for board bringup and system debugging it can come in handy.</p> <p>One can also use the <code>service</code> stanza to start a stand-alone shell:</p> <pre><code>service [12345] /bin/sh -l\n</code></pre>"}]}